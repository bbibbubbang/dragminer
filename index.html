<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>í´ë¦­ì»¤ ê´‘ì‚°</title>
  <style>
    :root{ --bg:#0f1220;--panel:#161a2e;--accent:#6ee7ff;--accent2:#a78bfa;--text:#eaf2ff;--muted:#9aa3b2;--danger:#ff6b6b;--ok:#22c55e; --bar:#1b2342; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0; overscroll-behavior-y: none; overscroll-behavior-x: none;}
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif; background:linear-gradient(180deg, #0b0e1a 0%, #0f1220 100%); color:var(--text);}
    body.lock-v{ overflow:hidden; }
    .app{max-width:520px;margin:0 auto;display:flex;flex-direction:column;min-height:100vh;}
    header{position:sticky;top:0;z-index:10;background:rgba(15,18,32,0.9);backdrop-filter: blur(6px);border-bottom:1px solid #22263f}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;gap:8px}
    .hud{display:flex;flex-direction:column;gap:2px;min-width:0}
    .hud-line{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
    .btn{appearance:none;border:none;background:var(--accent2);color:#0b0e1a;border-radius:12px;padding:10px 14px;font-weight:700;transition:transform .04s}
    .btn:active{transform:scale(.98)}
    .btn.secondary{background:#243b55;color:#eaf2ff;border:1px solid #2f3a63}
    .btn.danger{background:var(--danger);color:white}
    .btn.ghost{background:#0d132b;color:#cbd5ff;border:1px solid #263165}
    .btn:disabled{opacity:.6}

    .tabs{display:flex;gap:8px;padding:8px 12px;background:#0d1020;border-top:1px solid #22263f}
    .tab-btn{flex:1;border:none;padding:10px 0;border-radius:12px;background:#1a2040;color:#b9c3ff;font-weight:700;transition:transform .04s}
    .tab-btn:active{transform:scale(.98)}
    .tab-btn.active{background:var(--accent);color:#001018}

    .screen{flex:1;display:flex;flex-direction:column;padding:10px 12px;gap:10px}
    .timerbar{height:10px;background:var(--bar);border-radius:999px;overflow:hidden;border:1px solid #283058}
    .timerbar > div{height:100%;background:linear-gradient(90deg, #22c55e, #facc15);width:100%}

    .grid-wrap{position:relative}
    .grid{position:relative;display:grid;gap:6px;background:#0e1328;padding:6px;border-radius:16px;border:1px solid #202a51;grid-template-columns:repeat(5,1fr); touch-action: none;}
    .cell{position:relative;background:#121737;border:1px solid #1f2752;border-radius:10px;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;overflow:hidden; touch-action: none;}
    .cell .ore{position:absolute;inset:6px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:900;color:#0a0e1e;text-shadow:0 1px 0 rgba(255,255,255,.2);} 
    .ore .name{display:none}
    .hp{position:absolute;top:6px;left:6px;right:6px;height:8px;background:rgba(0,0,0,.35);border-radius:999px;border:1px solid rgba(255,255,255,.08);overflow:hidden}
    .hp>div{height:100%;background:linear-gradient(90deg,#34d399,#f59e0b);width:100%}
    .dmg{position:absolute;pointer-events:none;font-weight:900;animation:float .6s ease-out forwards;white-space:nowrap}
    @keyframes float{to{transform:translateY(-24px);opacity:0}}

    .pet{position:absolute;width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid #0e7490;box-shadow:0 0 10px rgba(34,211,238,.6)}
    .pet::after{content:'ğŸ¾';position:absolute;font-size:12px;left:50%;top:50%;transform:translate(-50%,-55%)}

    .row{display:flex;gap:8px;align-items:center}
    .panel{background:var(--panel);border:1px solid #232844;border-radius:16px;padding:12px}

    .inventory{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .inv-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .inv-item{background:#0f1430;border:1px solid #1f2853;border-radius:12px;padding:10px}
    .inv-item h4{margin:0 0 6px 0}
    .price{color:#a3e635;font-weight:800}

    /* Skills */
    .skillshop{display:grid;grid-template-columns:1fr;gap:10px}
    .skill-card{background:#0f1430;border:1px solid #273061;border-radius:12px;padding:10px}
    .skillbar{position:sticky;bottom:0;margin-top:8px;background:#0e1328;border:1px solid #1f2853;border-radius:12px;padding:6px;display:grid;grid-template-columns:repeat(5,1fr);gap:6px}
    .skillbtn{height:44px;border-radius:10px;border:1px solid #30407a;background:#18224a;color:#dbe7ff;font-weight:800}
    .skillbtn.cd{position:relative}
    .skillbtn.cd::after{content:'';position:absolute;inset:0;background:rgba(0,0,0,.35);}
    .slotlist{display:grid;grid-template-columns:repeat(5,1fr);gap:6px;margin-top:8px}
    .slot{background:#0c1230;border:1px dashed #27408b;border-radius:10px;min-height:42px;display:flex;align-items:center;justify-content:center;cursor:pointer; font-size:12px; white-space:nowrap}

    /* Aether */
    .aether-grid{display:grid;grid-template-columns:1fr;gap:10px}
    .ae-card{background:#0f1430;border:1px solid #53338f;border-radius:12px;padding:10px}
    .ae-card h4{margin:0 0 6px 0}
    .ae-meta{color:#c4b5fd}

    footer{padding:8px 0}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="topbar">
        <div class="hud mono">
          <div class="hud-line" id="hud1">ğŸ’° 0 Â· âœ¨ 0</div>
          <div class="hud-line" id="hud2">ğŸ—¡ï¸ 1 Â· ğŸ—¼ ì§€í•˜ 1ì¸µ</div>
        </div>
        <div class="row">
          <button id="toggleRunBtn" class="btn">ë˜ì „ ë„ì „</button>
          <button id="exitBtn" class="btn danger" disabled>ë‚˜ê°€ê¸°</button>
        </div>
      </div>
      <div class="timerbar"><div id="timeFill"></div></div>
      <div class="tabs">
        <button class="tab-btn active" data-tab="dungeon">â›ï¸ ë˜ì „</button>
        <button class="tab-btn" data-tab="inventory">ğŸ’ ì¸ë²¤í† ë¦¬</button>
        <button class="tab-btn" data-tab="upgrades">ğŸ“ˆ ì—…ê·¸ë ˆì´ë“œ</button>
        <button class="tab-btn" data-tab="skills">ğŸª„ ìŠ¤í‚¬</button>
        <button class="tab-btn" data-tab="aether">ğŸ”® ì—í…Œë¥´</button>
        <button class="tab-btn" data-tab="settings">âš™ï¸ ì„¤ì •</button>
      </div>
    </header>

    <main class="screen">
      <section id="tab-dungeon" class="panel">
        <div class="row" style="justify-content:space-between;margin-bottom:6px">
          <div class="mono" id="timeMono">â³ <span id="timeLeft">--</span>s</div>
        </div>
        <div class="grid-wrap">
          <div id="grid" class="grid"></div>
          <div id="skillBar" class="skillbar" style="display:none"></div>
        </div>
      </section>

      <section id="tab-inventory" class="panel" style="display:none">
        <div class="inv-actions">
          <div class="row" style="gap:8px">
            <input type="checkbox" id="autoSellChkInv" style="width:18px;height:18px">
            <label for="autoSellChkInv" class="mono">ê´‘ì„ ìë™íŒë§¤</label>
          </div>
          <button id="sellAllGlobal" class="btn secondary">ëª¨ë“  ê´‘ë¬¼ íŒë§¤</button>
        </div>
        <div class="inventory" id="inventoryList"></div>
      </section>

      <section id="tab-upgrades" class="panel" style="display:none">
        <div id="upgrades"></div>
      </section>

      <section id="tab-skills" class="panel" style="display:none">
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div class="row"><span>ì•¡í‹°ë¸Œ ìŠ¬ë¡¯:</span> <b id="slotCount" class="mono">0/5</b></div>
        </div>
        <div class="slotlist" id="slotList"></div>
        <h4 style="margin:10px 0 6px 0">ì•¡í‹°ë¸Œ ìŠ¤í‚¬ ìƒì </h4>
        <div class="skillshop" id="skillShopActive"></div>
        <h4 style="margin:14px 0 6px 0">íŒ¨ì‹œë¸Œ ìŠ¤í‚¬ ìƒì </h4>
        <div class="skillshop" id="skillShopPassive"></div>
      </section>

      <section id="tab-aether" class="panel" style="display:none">
        <div class="row" style="justify-content:space-between">
          <div class="mono">ì—í…Œë¥´: <b id="aeBalance">0</b></div>
          <div class="mono">í™˜ìƒ: <b id="rebirths">0íšŒ</b></div>
        </div>
        <div class="ae-card">
          <h4>í™˜ìƒ ì¤€ë¹„</h4>
          <div class="ae-meta">ì§€í•˜ 20ì¸µ ì´ìƒì—ì„œ í™˜ìƒ ê°€ëŠ¥. ì•„ë˜ ë³´ë„ˆìŠ¤ë¥¼ ì´ë²ˆ í™˜ìƒì— í•¨ê»˜ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
          <div id="rebirthPerks" class="aether-grid" style="margin-top:8px"></div>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="mono">ì´ ë¹„ìš©: <b id="rebirthTotal">0</b> ì—í…Œë¥´</div>
            <button id="rebirthBuyBtn" class="btn danger" disabled>ë³´ë„ˆìŠ¤ êµ¬ë§¤ + í™˜ìƒ</button>
          </div>
        </div>
        <div class="ae-card">
          <h4>ìë™ ì´ë™</h4>
          <div class="row" style="justify-content:space-between;flex-wrap:wrap">
            <div class="ae-meta">ë³´ìŠ¤(ì—í…Œë¥´) ì²˜ì¹˜ ì‹œ ë‹¤ìŒ ì¸µìœ¼ë¡œ ìë™ ì…ì¥</div>
            <div class="row">
              <input type="checkbox" id="autoAdvanceChk" style="width:18px;height:18px" disabled>
              <label for="autoAdvanceChk" class="mono" style="margin-left:6px">í™œì„±í™”</label>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="autoAdvanceBuyBtn" class="btn" disabled>ì—í…Œë¥´ 150 ì†Œëª¨ í›„ í•´ê¸ˆ</button>
          </div>
        </div>
      </section>

      <section id="tab-settings" class="panel" style="display:none">
        <div class="row" style="flex-wrap:wrap;gap:10px">
          <button id="saveBtn" class="btn secondary">ìˆ˜ë™ ì €ì¥</button>
          <button id="exportBtn" class="btn secondary">ë‚´ë³´ë‚´ê¸°</button>
          <button id="importBtn" class="btn secondary">ë¶ˆëŸ¬ì˜¤ê¸°</button>
          <button id="fullscreenBtn" class="btn secondary">ì „ì²´í™”ë©´</button>
          <button id="toggleSoundBtn" class="btn ghost">íš¨ê³¼ìŒ: ì¼œì§</button>
          <button id="resetBtn" class="btn danger">ì´ˆê¸°í™”</button>
        </div>
      </section>
    </main>

    <footer></footer>
  </div>

  <script>
  (()=>{
    const VERSION = 'miner_v2.6.1';
    // ê³ ì • ì„¸ì´ë¸Œí‚¤ + êµ¬ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜
    const SAVE_KEY = 'miner_save_v1';
    const LEGACY_KEYS = Object.keys(localStorage).filter(k=>/^miner_v/.test(k));

    // ---------- Audio ----------
    let audioCtx = null, sfxEnabled = true;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function beep(freq=600, dur=0.06, type='square', gain=0.03){
      if(!sfxEnabled) return;
      ensureAudio();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t);
      o.stop(t+dur);
    }
    const SFX = {
      hit(){ beep(520,0.03,'square',0.035); },
      crit(){ beep(900,0.05,'square',0.045); },
      break(){ beep(240,0.07,'sawtooth',0.05); },
      skill(){ beep(700,0.08,'triangle',0.05); },
      deny(){ beep(180,0.12,'square',0.04); },
      ui(){ beep(430,0.05,'triangle',0.035); }
    };

    // ---------- Game State ----------
    const state = {
      player: { atkBase: 10, atk: 10, critChance: 0.10, critMult: 2.0, gold: 0, ether: 0 },
      upgrades: {
        atk:   { level: 1, baseCost: 30,  scale: 1.35 },
        crit:  { level: 0, baseCost: 50,  scale: 1.7  },
        spawn: { level: 0, baseCost: 80,  scale: 1.8  },
        pet:   { level: 0, baseCost: 150, scale: 2.0  },
        oreMul: {}
      },
      aether: { luck:0, petPlus:0, etherHaste:0, rebirths:0, autoAdvanceOwned:false, autoAdvanceEnabled:false },

      floor: 1,
      highestFloor: 1,
      inventory: {},
      loot: {},
      grid: new Array(25).fill(null),
      inRun:false,
      timeLeft: 0.0,
      timers: { spawn:null, tick:null },
      pets: [],
      pointerState: {},
      lastAnimTs: 0,
      runStartTs: 0,
      etherSpawned: false,

      // Skills
      skillsOwnedActive: {},
      skillsOwnedPassive: {},
      skillSlots: [null,null,null,null,null],
      skillCooldowns: {},
      skillHasteUntil: 0,
      skillAtkBuffUntil: 0,

      // Passive bonuses
      passive: { sellBonus: 0, petPlus: 0 },

      // Settings
      settings: { autoSell:false }
    };

    // ---------- Save/Load (stable key + migration) ----------
    function save(){
      const { atk, ...player } = state.player;
      const payload = {
        __version: VERSION,
        player,
        upgrades:state.upgrades, floor:state.floor, highestFloor:state.highestFloor,
        inventory:state.inventory, skillsOwnedActive:state.skillsOwnedActive, skillsOwnedPassive:state.skillsOwnedPassive,
        skillSlots:state.skillSlots, passive:state.passive, aether:state.aether, settings:state.settings
      };
      try{ localStorage.setItem(SAVE_KEY, JSON.stringify(payload)); }catch(e){ console.warn('save failed', e); }
    }
    function load(){
      let raw = localStorage.getItem(SAVE_KEY);
      if(!raw){
        for(const k of LEGACY_KEYS){
          raw = localStorage.getItem(k);
          if(raw){ try{ localStorage.setItem(SAVE_KEY, raw); }catch(e){} break; }
        }
      }
      if(!raw) return;
      try{
        const s = JSON.parse(raw);
        Object.assign(state.player,s.player||{});
        delete state.player.atk;
        Object.assign(state.upgrades,s.upgrades||{});
        state.floor=s.floor||1; state.highestFloor=s.highestFloor||1;
        state.inventory=s.inventory||state.inventory;
        state.skillsOwnedActive=s.skillsOwnedActive||{};
        state.skillsOwnedPassive=s.skillsOwnedPassive||{};
        state.skillSlots=s.skillSlots||[null,null,null,null,null];
        state.passive=s.passive||state.passive;
        state.aether = s.aether || state.aether;
        state.settings = s.settings || state.settings;
        if(typeof state.player.atkBase === 'undefined'){
          state.player.atkBase = (typeof s.player?.atk === 'number') ? s.player.atk : 10;
        }
      }catch(e){ console.warn('load failed', e); }
    }

    // ---------- Skills ----------
    const ACTIVE_SKILLS = [
      { key:'berserk',  name:'ê´‘í­í™”',   desc:'5ì´ˆê°„ ê³µê²©ë ¥ x2',         ae:150, cd:20 },
      { key:'timewarp', name:'íƒ€ì„ì›Œí”„', desc:'ì‹œê°„ +3ì´ˆ(ìµœëŒ€ 20ì´ˆ)',    ae:120, cd:25 },
      { key:'meteor',   name:'ìš´ì„ ë‚™í•˜', desc:'ëª¨ë“  ê´‘ì„ì— í° í”¼í•´',    ae:200, cd:30 },
      { key:'haste',    name:'ê°€ì†',     desc:'5ì´ˆê°„ ìƒì„± ì†ë„ 2ë°°',     ae:140, cd:25 },
      { key:'sonic',    name:'ì´ˆìŒíŒŒ',   desc:'ê°€ê¹Œìš´ ê´‘ì„ì— ì¦‰ì‹œ í° í”¼í•´', ae:130, cd:18 },
    ];
    const PASSIVE_SKILLS = [
      { key:'power',   name:'ê°•í™” ì±„êµ´',  desc:'ê³µê²©ë ¥ +1(ê¸°ì´ˆ)',            ae:120, once:true,  apply(){ state.player.atkBase = (state.player.atkBase||10) + 1; } },
      { key:'sharp',   name:'ì˜ˆë¦¬í•¨',    desc:'ì¹˜ëª…íƒ€ í™•ë¥  +3% (ìµœëŒ€ 50%)',   ae:150, once:true,  apply(){ state.player.critChance = Math.min(0.5, state.player.critChance + 0.03); } },
      { key:'merchant',name:'ìƒì¸ ê°ê°',  desc:'íŒë§¤ê°€ +10%',                 ae:180, once:false, apply(){ state.passive.sellBonus += 0.10; } },
      { key:'petmaster',name:'í« ì¡°ë ¨',  desc:'í« +1',                      ae:200, once:false, apply(){ state.passive.petPlus += 1; if(state.inRun) spawnPets(); } },
    ];

    // ---------- Rebirth-only Aether ----------
    const REBIRTH_PERKS = [
      { key:'luck',        name:'í–‰ìš´ ì´‰ë§¤',   desc:'í¬ê·€ ê´‘ë¬¼ ê°€ì¤‘ì¹˜ ìƒìŠ¹', base:25, scale:1.6, max:20, get lvl(){ return state.aether.luck||0; },      apply(){ state.aether.luck=(state.aether.luck||0)+1; } },
      { key:'petPlus',     name:'ì°¨ì› í«',     desc:'íŠ¹ë³„ í« +1',            base:40, scale:1.8, max:5,  get lvl(){ return state.aether.petPlus||0; },   apply(){ state.aether.petPlus=(state.aether.petPlus||0)+1; } },
      { key:'etherHaste',  name:'ì—í…Œë¥´ ê³µëª…', desc:'ì—í…Œë¥´ ë“±ì¥ -1ì´ˆ(ìµœì†Œ 5ì´ˆ)', base:30, scale:1.6, max:10, get lvl(){ return state.aether.etherHaste||0; }, apply(){ state.aether.etherHaste=(state.aether.etherHaste||0)+1; } },
    ];
    function perkCost(p){ return Math.floor(p.base * Math.pow(p.scale, p.lvl)); }
    const rebirthPick = {}; // {key:1}

    // ---------- Ores ----------
    const ORES = [
      { key:'Stone',   name:'ì„ì¬',     color:'#a3a3a3', hp:  60,  value: 1,  weight: 40, tier:1, minFloor:1 },
      { key:'Copper',  name:'êµ¬ë¦¬',     color:'#ef9a9a', hp: 120,  value: 2,  weight: 36, tier:1, minFloor:1 },
      { key:'Iron',    name:'ì² ',       color:'#90caf9', hp: 220,  value: 4,  weight: 30, tier:2, minFloor:2 },
        { key:'Silver',  name:'ì€',       color:'#cfd8dc', hp: 380,  value: 9,  weight: 22, tier:3, minFloor:1 },
      { key:'Gold',    name:'ê¸ˆ',       color:'#f6e05e', hp: 650,  value: 20, weight: 16, tier:3, minFloor:5 },
      { key:'Platinum',name:'ë°±ê¸ˆ',     color:'#e5e7eb', hp: 900,  value: 32, weight: 10, tier:4, minFloor:8 },
      { key:'Sapphire',name:'ì‚¬íŒŒì´ì–´', color:'#60a5fa', hp:1200,  value: 48, weight: 7,  tier:4, minFloor:10 },
      { key:'Ruby',    name:'ë£¨ë¹„',     color:'#f43f5e', hp:1400,  value: 60, weight: 6,  tier:5, minFloor:12 },
      { key:'Emerald', name:'ì—ë©”ë„ë“œ', color:'#34d399', hp:1650,  value: 80, weight: 5,  tier:5, minFloor:15 },
      { key:'Mythril', name:'ë¯¸ìŠ¤ë¦´',   color:'#93c5fd', hp:2200,  value:120, weight: 3,  tier:6, minFloor:18 },
      { key:'Diamond', name:'ë‹¤ì´ì•„',   color:'#b9f6ff', hp:3000,  value:180, weight: 2,  tier:6, minFloor:22 },
    ];

    for(const o of ORES){ state.inventory[o.key]=state.inventory[o.key]||0; state.loot[o.key]=0; state.upgrades.oreMul[o.key]=state.upgrades.oreMul[o.key]||0; }

    const PET = { moveSpeed: 220, atkInterval: 0.55, sepRadius: 24, atkRange: 18 };

    const $ = sel => document.querySelector(sel);
    const gridEl = $('#grid');
    const skillBarEl = $('#skillBar');

    function randWeighted(items){ const total = items.reduce((a,b)=>a+b.weight,0); let r = Math.random()*total; for(const it of items){ if((r-=it.weight) <= 0) return it; } return items[0]; }
      function eligibleOresForFloor(f){
        const luck = state.aether?.luck||0;
        return ORES.filter(o=> f >= o.minFloor).map(o=>{
          const bonus = Math.max(0, f - o.minFloor);
          const tierBoost = 1 + (o.tier-1)*0.03*bonus;
          const rareMul = 1 + luck*0.08*(o.tier-1);
          let weight = o.weight * tierBoost * rareMul;
          if(o.key==='Silver' && f<3){ weight *= (f===1 ? 0.1 : 0.3); }
          return { ...o, weight: Math.max(1, Math.round(weight)) };
        });
      }
    function cellIndexFromPoint(x,y){ const el = document.elementFromPoint(x,y); const cell = el && el.closest ? el.closest('.cell') : null; return cell? +cell.dataset.idx : -1; }
    function gridRect(){ return gridEl.getBoundingClientRect(); }
    function cellRect(idx){ return gridEl.children[idx].getBoundingClientRect(); }
    function cellCenter(idx){ const r = cellRect(idx); return { x:r.left + r.width/2, y:r.top + r.height/2 }; }
    function insideHitbox(idx, x, y){ if(idx<0) return false; const r = cellRect(idx); const padX=r.width*0.15, padY=r.height*0.15; return (x>r.left+padX && x<r.right-padX && y>r.top+padY && y<r.bottom-padY); }

    function sellMultiplier(key){
      const lvl = state.upgrades.oreMul[key]||0;
      const upgMul = Math.pow(1.2, lvl);
      const passiveMul = 1 + (state.passive.sellBonus||0);
      return upgMul * passiveMul;
    }

    function calcAtk() {
      const L = state.upgrades.atk?.level || 1;
      const base = state.player.atkBase || 10;
      const ATK_PER_LVL = 0.12;
      const ATK_MILE    = 0.35;
      const per   = Math.pow(1 + ATK_PER_LVL, Math.max(0, L - 1));
      const bonus = Math.pow(1 + ATK_MILE, Math.floor(Math.max(0, L - 1) / 10));
      const atk = Math.max(1, Math.ceil(base * per * bonus));
      state.player.atk = atk;
      return atk;
    }

    function fmtFloor(n){ return `ì§€í•˜ ${n}ì¸µ`; }
    function renderHud(){
      calcAtk();
      $('#hud1').textContent = `ğŸ’° ${state.player.gold} Â· âœ¨ ${state.player.ether}`;
      $('#hud2').textContent = `ğŸ—¡ï¸ ${state.player.atk} Â· ğŸ—¼ ${fmtFloor(state.floor)}`;
    }
    function renderTop(){
      renderHud();
      $('#timeLeft').textContent = state.inRun? state.timeLeft.toFixed(1) : '--';
      $('#exitBtn').disabled = !state.inRun;
      $('#toggleRunBtn').textContent = state.inRun? 'ì§„í–‰ ì¤‘' : 'ë˜ì „ ë„ì „';
      $('#toggleRunBtn').disabled = state.inRun;
      const max = 20;
      const fill = state.inRun? Math.max(0, Math.min(1, state.timeLeft / max)) : 1;
      document.getElementById('timeFill').style.width = (fill*100)+'%';
      const isDungeonVisible = document.querySelector('#tab-dungeon').style.display !== 'none';
      document.body.classList.toggle('lock-v', isDungeonVisible);
    }

    function renderGrid(){ if(!gridEl.childElementCount){ for(let i=0;i<25;i++){ const d=document.createElement('div'); d.className='cell'; d.dataset.idx=i; gridEl.appendChild(d); } }
      state.grid.forEach((ore, i)=>{ const c = gridEl.children[i]; c.innerHTML=''; if(ore){ const el=document.createElement('div'); el.className='ore'; el.style.background=ore.bg; const hp=document.createElement('div'); hp.className='hp'; const f=document.createElement('div'); hp.appendChild(f); const ratio=Math.max(0,Math.min(1,ore.hp/ore.maxHp)); f.style.width=(ratio*100)+'%'; c.appendChild(el); c.appendChild(hp);} });
      renderPets(); }

    function renderInventory(){ const box=$('#inventoryList'); box.innerHTML='';
      const chk = document.getElementById('autoSellChkInv'); if(chk){ chk.checked = !!state.settings.autoSell; chk.onchange = ()=>{ state.settings.autoSell = !!chk.checked; save(); toast(`ìë™íŒë§¤ ${chk.checked?'ON':'OFF'}`); }; }
      for(const t of ORES){ const inv = state.inventory[t.key]||0; const mul=sellMultiplier(t.key); const li=document.createElement('div'); li.className='inv-item'; li.innerHTML = `<h4>${t.name} <span class="small">(${t.key})</span></h4><div>ê°€ì¹˜: <span class="price">${Math.round(t.value*mul)}</span> ê³¨ë“œ</div><div class="row" style="margin-top:6px;gap:6px;flex-wrap:wrap"><button class="btn secondary" data-sellall="${t.key}">ëª¨ë‘ íŒë§¤</button><button class="btn secondary" data-sell="${t.key}">1ê°œ íŒë§¤</button><button class="btn" data-upg-ore="${t.key}">ì—…ê·¸ë ˆì´ë“œ</button></div><div class="row" style="margin-top:6px"><div class="mono">ë³´ìœ : ${inv}</div></div>`; box.appendChild(li);} 
      box.querySelectorAll('[data-sell]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); const k=btn.dataset.sell; const t=ORES.find(o=>o.key===k); if(state.inventory[k]>0){ state.inventory[k]--; state.player.gold+=Math.round(t.value*sellMultiplier(k)); save(); refresh(); }}));
      box.querySelectorAll('[data-sellall]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); sellAllOf(btn.dataset.sellall); }));
      box.querySelectorAll('[data-upg-ore]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); oreUpgrade(btn.dataset.upgOre)}));
      $('#sellAllGlobal').onclick = ()=>{ SFX.ui(); sellAllOres(); };
    }
    function sellAllOf(key){ const t=ORES.find(o=>o.key===key); const n=state.inventory[key]||0; if(n>0){ state.inventory[key]=0; state.player.gold+=Math.round(n*t.value*sellMultiplier(key)); save(); refresh(); } }
    function sellAllOres(){ let total=0; for(const t of ORES){ const n=state.inventory[t.key]||0; if(n>0){ total += n*t.value*sellMultiplier(t.key); state.inventory[t.key]=0; } } if(total>0){ state.player.gold += Math.round(total); save(); refresh(); } }

    function oreUpgrade(key){ const lvl = state.upgrades.oreMul[key]||0; const cost = Math.floor(10 * Math.pow(1.6, lvl)); if((state.inventory[key]||0) < cost) { toast(`${key} x${cost} í•„ìš”`); SFX.deny(); return; } state.inventory[key]-=cost; state.upgrades.oreMul[key]=lvl+1; toast(`${key} ë°°ìœ¨ ì—…`); SFX.ui(); save(); refresh(); }

    function renderUpgrades(){
      const cont=$('#upgrades'); cont.innerHTML='';
      calcAtk();
      const atkCost=Math.floor(state.upgrades.atk.baseCost*Math.pow(state.upgrades.atk.scale,state.upgrades.atk.level-1));
      cont.appendChild(upgradeCard('ğŸ—¡ï¸ ê³µê²©ë ¥', `í˜„ì¬: ${state.player.atk} (ë ˆë²¨ ${state.upgrades.atk.level})`, atkCost, ()=>{ if(spend(atkCost)){ state.upgrades.atk.level++; SFX.ui(); save(); refresh(); } else SFX.deny(); }));
      const critCost=Math.floor(state.upgrades.crit.baseCost*Math.pow(state.upgrades.crit.scale,state.upgrades.crit.level));
      cont.appendChild(upgradeCard('ğŸ¯ ì¹˜ëª…íƒ€ í™•ë¥ ', `í˜„ì¬: ${(state.player.critChance*100).toFixed(1)}%`, critCost, ()=>{ if(state.player.critChance>=0.5) return toast('ìµœëŒ€ 50%'), SFX.deny(); if(spend(critCost)){ state.upgrades.crit.level++; state.player.critChance+=0.02; SFX.ui(); save(); refresh(); } else SFX.deny(); }));
      const spawnCost=Math.floor(state.upgrades.spawn.baseCost*Math.pow(state.upgrades.spawn.scale,state.upgrades.spawn.level));
      cont.appendChild(upgradeCard('âš™ï¸ ìƒì„± ì†ë„', `ë ˆë²¨: ${state.upgrades.spawn.level}`, spawnCost, ()=>{ if(spend(spawnCost)){ state.upgrades.spawn.level++; if(state.inRun) restartSpawnTimer(); SFX.ui(); save(); refresh(); } else SFX.deny(); }));
      const petCost=Math.floor(state.upgrades.pet.baseCost*Math.pow(state.upgrades.pet.scale,state.upgrades.pet.level));
      cont.appendChild(upgradeCard('ğŸ¤– ìë™ì±„êµ´ í«', `ë³´ìœ : ${(state.upgrades.pet.level + (state.passive.petPlus||0) + (state.aether?.petPlus||0))}ë§ˆë¦¬`, petCost, ()=>{ if(spend(petCost)){ state.upgrades.pet.level++; if(state.inRun) spawnPets(); SFX.ui(); save(); refresh(); } else SFX.deny(); }));
    }
    function upgradeCard(title, desc, cost, onBuy){ const wrap=document.createElement('div'); wrap.className='inv-item'; wrap.innerHTML = `<h4 style="margin:0 0 4px 0">${title}</h4><div class="mono">${desc}</div><div class="row" style="margin-top:8px;justify-content:space-between"><div class="row"><span>ê°€ê²©:</span> <b class="price">${cost}</b></div><button class="btn">êµ¬ë§¤</button></div>`; wrap.querySelector('.btn').addEventListener('click', onBuy); return wrap; }
    function spend(amount){ if(state.player.gold < amount){ toast('ê³¨ë“œ ë¶€ì¡±'); return false; } state.player.gold -= amount; return true; }
    function spendAe(amount){ if(state.player.ether < amount){ toast('ì—í…Œë¥´ ë¶€ì¡±'); return false; } state.player.ether -= amount; return true; }

    function renderAether(){
      $('#aeBalance').textContent = state.player.ether;
      $('#rebirths').textContent = (state.aether?.rebirths||0)+'íšŒ';
      const canRebirth = state.highestFloor >= 20;
      const ownAA = !!state.aether.autoAdvanceOwned;
      $('#autoAdvanceBuyBtn').disabled = ownAA || !canRebirth || state.player.ether < 150;
      $('#autoAdvanceBuyBtn').textContent = ownAA ? 'í•´ê¸ˆë¨' : 'ì—í…Œë¥´ 150 ì†Œëª¨ í›„ í•´ê¸ˆ';
      $('#autoAdvanceChk').disabled = !ownAA;
      $('#autoAdvanceChk').checked = !!state.aether.autoAdvanceEnabled;

      const list = $('#rebirthPerks'); list.innerHTML='';
      let total = 0;
      for(const p of REBIRTH_PERKS){
        const maxed = p.lvl >= p.max;
        const cost = perkCost(p);
        const checked = !!rebirthPick[p.key];
        const row = document.createElement('div'); row.className='skill-card';
        row.innerHTML = `<div class="row" style="justify-content:space-between"><b>${p.name}</b><span class="mono">${p.desc}</span></div>
                         <div class="row" style="justify-content:space-between;margin-top:6px">
                           <div class="mono">ë ˆë²¨ ${p.lvl}/${p.max} Â· ë¹„ìš© ${cost} ì—í…Œë¥´</div>
                           <label class="row" style="gap:6px;align-items:center">
                             <input type="checkbox" ${checked?'checked':''} ${maxed?'disabled':''} data-perk="${p.key}">
                             <span>${maxed?'ìµœëŒ€':''}ì„ íƒ</span>
                           </label>
                         </div>`;
        list.appendChild(row);
        if(checked && !maxed){ total += cost; }
      }
      $('#rebirthTotal').textContent = total;
      const afford = state.player.ether >= total;
      $('#rebirthBuyBtn').disabled = !(canRebirth && afford && total>0);
    }

    function renderSkills(){
      const slotList = $('#slotList'); slotList.innerHTML='';
      for(let i=0;i<5;i++){
        const el=document.createElement('div'); el.className='slot'; const sk = state.skillSlots[i];
        el.textContent = sk ? ACTIVE_SKILLS.find(s=>s.key===sk).name : '+ ë¹ˆ ìŠ¬ë¡¯';
        el.addEventListener('click', ()=>{
          SFX.ui();
          if(state.skillSlots[i]){ state.skillSlots[i]=null; }
          else {
            const owned = Object.keys(state.skillsOwnedActive).filter(k=> state.skillsOwnedActive[k] && !state.skillSlots.includes(k));
            if(owned.length===0) return toast('ë³´ìœ  ì•¡í‹°ë¸Œ ìŠ¤í‚¬ ì—†ìŒ');
            state.skillSlots[i] = owned[0];
          }
          save(); renderSkills(); renderSkillBar();
        });
        slotList.appendChild(el);
      }
      $('#slotCount').textContent = state.skillSlots.filter(Boolean).length + '/5';

      const shopA = $('#skillShopActive'); shopA.innerHTML='';
      for(const sk of ACTIVE_SKILLS){
        const owned = !!state.skillsOwnedActive[sk.key];
        const card = document.createElement('div'); card.className = 'skill-card';
        card.innerHTML = `<div class="row" style="justify-content:space-between"><b>${sk.name}</b><span class="mono">ì¿¨íƒ€ì„ ${sk.cd}s</span></div><div class="mono" style="opacity:.8;margin:4px 0 8px 0">${sk.desc}</div><div class="row" style="justify-content:space-between"><div>ê°€ê²©: <b class="price">${sk.ae}</b> ì—í…Œë¥´</div><button class="btn" ${owned?'disabled':''}>${owned?'ë³´ìœ ì¤‘':'êµ¬ë§¤'}</button></div>`;
        if(!owned){
          card.querySelector('.btn').addEventListener('click', ()=>{
            if(!spendAe(sk.ae)) { SFX.deny(); return; }
            state.skillsOwnedActive[sk.key]=true; toast(`${sk.name} íšë“!`); SFX.ui(); save(); renderSkills(); renderTop();
          });
        }
        shopA.appendChild(card);
      }
      const shopP = $('#skillShopPassive'); shopP.innerHTML='';
      for(const sk of PASSIVE_SKILLS){
        const owned = !!state.skillsOwnedPassive[sk.key];
        const card = document.createElement('div'); card.className = 'skill-card';
        card.innerHTML = `<div class="row" style="justify-content:space-between"><b>${sk.name}</b><span class="mono">íŒ¨ì‹œë¸Œ</span></div><div class="mono" style="opacity:.8;margin:4px 0 8px 0">${sk.desc}</div><div class="row" style="justify-content:space-between"><div>ê°€ê²©: <b class="price">${sk.ae}</b> ì—í…Œë¥´</div><button class="btn" ${owned && sk.once?'disabled':''}>${owned?(sk.once?'ë³´ìœ ì¤‘':'ì¶”ê°€ êµ¬ë§¤'):'êµ¬ë§¤'}</button></div>`;
        card.querySelector('.btn').addEventListener('click', ()=>{
          if(!spendAe(sk.ae)) { SFX.deny(); return; }
          if(sk.once && owned){ toast('ì´ë¯¸ ë³´ìœ '); SFX.deny(); return; }
          if(!state.skillsOwnedPassive[sk.key]) state.skillsOwnedPassive[sk.key]=0;
          state.skillsOwnedPassive[sk.key] += 1;
          sk.apply();
          toast(`${sk.name} ì ìš©!`); SFX.ui(); save(); renderSkills(); renderUpgrades(); renderTop();
        });
        shopP.appendChild(card);
      }
    }

    function renderSkillBar(){
      if(!state.inRun){ skillBarEl.style.display='none'; return; }
      skillBarEl.style.display='grid'; skillBarEl.innerHTML='';
      for(let i=0;i<5;i++){
        const k = state.skillSlots[i];
        const b=document.createElement('button'); b.className='skillbtn'; b.textContent = k? ACTIVE_SKILLS.find(s=>s.key===k).name : '-';
        if(!k){ b.disabled=true; }
        else {
          const cd = Math.max(0, state.skillCooldowns[k]||0);
          if(cd>0){ b.classList.add('cd'); b.textContent = `${ACTIVE_SKILLS.find(s=>s.key===k).name} (${cd.toFixed(0)}s)`; b.disabled=true; }
          b.addEventListener('click', ()=>{ SFX.ui(); useSkill(k); });
        }
        skillBarEl.appendChild(b);
      }
    }

    function setCd(key, sec){ state.skillCooldowns[key] = sec; }

    function useSkill(key){
      if(!state.inRun) return;
      const sk = ACTIVE_SKILLS.find(s=>s.key===key); if(!sk) return;
      const cd = state.skillCooldowns[key]||0; if(cd>0){ SFX.deny(); return; }
      switch(key){
        case 'berserk': state.skillAtkBuffUntil = performance.now()+5000; SFX.skill(); break;
        case 'timewarp': state.timeLeft = Math.min(20, +(state.timeLeft + 3).toFixed(1)); SFX.skill(); break;
        case 'meteor':
          for(let i=0;i<25;i++){ const o=state.grid[i]; if(!o) continue; const dmg = Math.max(10, Math.floor(o.maxHp*0.35)); o.hp -= dmg; if(o.hp<=0){ onOreBroken(i, o); } }
          SFX.skill(); break;
        case 'haste': state.skillHasteUntil = performance.now()+5000; restartSpawnTimer(); SFX.skill(); break;
        case 'sonic':
          const gr = gridRect(); const cx = (gr.left+gr.right)/2, cy=(gr.top+gr.bottom)/2;
          const idx = findNearestOreIdx(cx,cy);
          if(idx>=0){
            const o=state.grid[idx];
            const atk = calcAtk();
            const dmg = Math.max(20, Math.round(atk*10));
            o.hp-=dmg;
            if(o.hp<=0){ onOreBroken(idx, o); }
          }
          SFX.skill(); break;
      }
      setCd(key, sk.cd);
      renderSkillBar(); renderGrid(); renderTop();
    }

    function floorHpMul(){ return 1 + 0.18*(state.floor-1); }
    function floorValMul(){ return 1 + 0.12*(state.floor-1); }

    function startRun(){ if(state.inRun) return; state.inRun = true; state.etherSpawned=false; state.timeLeft = 20; state.grid = new Array(25).fill(null); for(const o of ORES){ state.loot[o.key]=0; } Object.keys(state.skillCooldowns).forEach(k=> delete state.skillCooldowns[k]); restartSpawnTimer(); state.runStartTs = performance.now(); startTick(); spawnPets(); renderSkillBar(); refresh(); }

    function startTick(){
      clearInterval(state.timers.tick);
      state.timers.tick = setInterval(()=>{
        if(!state.inRun) return;
        const now = performance.now();
        const elapsed = (now - state.runStartTs)/1000;
        let etherDelay = 10 + Math.min(state.floor*0.5, 20) - (state.aether?.etherHaste||0);
        etherDelay = Math.max(5, etherDelay);
        if(!state.etherSpawned && elapsed >= etherDelay){ spawnEther(); }
        state.timeLeft = Math.max(0, +(state.timeLeft - 0.1).toFixed(1));
        for(const k of Object.keys(state.skillCooldowns)){ state.skillCooldowns[k] = Math.max(0, state.skillCooldowns[k]-0.1); }
        if(state.timeLeft<=0){ bankAndExit(false); }
        renderTop(); renderSkillBar();
      },100);
      state.lastAnimTs = performance.now(); requestAnimationFrame(petsFrame);
    }

    function restartSpawnTimer(){
      const baseMs=2200; const level=state.upgrades.spawn.level;
      let interval= baseMs*Math.pow(0.94, level);
      if(state.skillHasteUntil > performance.now()) interval *= 0.5;
      if(interval<600) interval=600;
      clearInterval(state.timers.spawn); state.timers.spawn = setInterval(spawnOre, interval);
    }
    function exitRun(){ if(!state.inRun) return; bankAndExit(false); }

    function bankAndExit(cleared){
      if(state.settings?.autoSell){
        let totalGold = 0;
        for(const k in state.loot){
          const oreDef = ORES.find(o=>o.key===k);
          const n = state.loot[k]||0;
          if(!oreDef || n<=0) continue;
          totalGold += Math.round(n * oreDef.value * sellMultiplier(k));
        }
        if(totalGold>0) state.player.gold += totalGold;
      } else {
        for(const k in state.loot){ state.inventory[k] = (state.inventory[k]||0) + state.loot[k]; }
      }
      for(const k in state.loot){ state.loot[k]=0; }
      state.inRun=false; clearInterval(state.timers.spawn); clearInterval(state.timers.tick);
      state.pets=[]; state.lastAnimTs=0; state.grid = new Array(25).fill(null);
      if(cleared){ state.floor++; if(state.floor>state.highestFloor) state.highestFloor=state.floor; }
      save(); refresh(); renderSkillBar();
      if(cleared && state.aether?.autoAdvanceOwned && state.aether.autoAdvanceEnabled){
        setTimeout(()=>{ startRun(); }, 250);
      }
    }

    function spawnOre(){
      const empties = state.grid.map((v,i)=> v? null : i).filter(v=>v!==null); if(empties.length===0) return;
      const idx = empties[Math.floor(Math.random()*empties.length)];
      const pool = eligibleOresForFloor(state.floor);
      const base = randWeighted(pool);
      const elapsed = (performance.now() - state.runStartTs)/1000;
      const growth = 1 + 0.02 * Math.max(0, Math.floor(elapsed));
      const hp = Math.round(base.hp*floorHpMul()*growth*(state.skillAtkBuffUntil>performance.now()?0.9:1));
      const value = Math.round(base.value*floorValMul());
      state.grid[idx] = { type: base.key, label: base.name, hp, maxHp: hp, value, bg: base.color };
      renderGrid();
    }

      function spawnEther(){ const idx = 12; state.etherSpawned = true;
        const baseE = 1250; const r = 0.06; const exp = Math.max(0, (state.floor-1)*(state.floor-1));
        const hp = Math.round(baseE * Math.pow(1+r, exp));
        state.grid[idx] = { type:'EtherOre', label:'ì—í…Œë¥´ ê´‘ì„', hp, maxHp: hp, value: 0, bg:'#a855f7' }; renderGrid(); }

    function onOreBroken(idx, ore){
      if(ore.type==='EtherOre'){ state.player.ether += 10; toast('âœ¨ ì—í…Œë¥´ +10'); state.grid[idx] = null; SFX.break(); bankAndExit(true); return; }
      state.loot[ore.type] = (state.loot[ore.type]||0)+1;
      state.grid[idx] = null;
      state.timeLeft = Math.min(20, +(state.timeLeft + 0.1).toFixed(1));
      SFX.break();
      renderTop();
    }

    function hit(idx, source='tap'){
      if(!state.inRun) return; const ore = state.grid[idx]; if(!ore) return;
      const atk = calcAtk();
      let dmg = Math.round(atk * (state.skillAtkBuffUntil>performance.now()?2:1));
      const crit = (Math.random() < state.player.critChance && source==='tap');
      if(crit) dmg = Math.floor(dmg * state.player.critMult);
      ore.hp -= dmg;
      const cell = gridEl.children[idx];
      const dm = document.createElement('div'); dm.className='dmg'; dm.textContent = (crit?'CRIT ':'') + '-' + dmg; dm.style.left='50%'; dm.style.top='38%'; dm.style.transform='translateX(-50%)'; cell.appendChild(dm); setTimeout(()=>dm.remove(), 520);
      (crit?SFX.crit:SFX.hit)();
      if(ore.hp <= 0){ onOreBroken(idx, ore); renderTop(); }
      renderGrid();
    }

    function onPointerDown(e){ e.preventDefault(); trackPointer(e, true); }
    function onPointerMove(e){ e.preventDefault(); trackPointer(e, false); }
    function onPointerUp(e){ const ps = state.pointerState[e.pointerId]; if(ps) delete state.pointerState[e.pointerId]; }
    function trackPointer(e, isDown){ const id=e.pointerId||0; const idx = cellIndexFromPoint(e.clientX, e.clientY); const inside = insideHitbox(idx, e.clientX, e.clientY) && state.grid[idx]; const prev = state.pointerState[id] || { idx:-1, inside:false }; if(isDown){ if(inside && idx>=0) { hit(idx,'tap'); state.pointerState[id] = { idx, inside:true }; } else { state.pointerState[id] = { idx, inside:false }; } } else { if(prev.idx !== idx){ prev.inside = false; prev.idx = idx; } if(!prev.inside && inside){ if(idx>=0) hit(idx,'tap'); prev.inside = true; prev.idx = idx; } if(prev.inside && !inside){ prev.inside = false; } state.pointerState[id] = prev; } }

    gridEl.addEventListener('pointerdown', onPointerDown, {passive:false});
    gridEl.addEventListener('pointermove', onPointerMove, {passive:false});
    gridEl.addEventListener('pointerup', onPointerUp, {passive:false});
    gridEl.addEventListener('pointercancel', onPointerUp, {passive:false});

    // Pull-to-refresh guard
    let startY = 0, atTop = false;
    document.addEventListener('touchstart', (e)=>{ startY = e.touches[0].clientY; atTop = (document.scrollingElement?.scrollTop || 0) <= 0; }, {passive:true});
    document.addEventListener('touchmove', (e)=>{ if(atTop){ const dy = e.touches[0].clientY - startY; if(dy > 5) e.preventDefault(); } }, {passive:false});

    function spawnPets(){
      state.pets = [];
      const count = (state.upgrades.pet.level || 0) + (state.passive.petPlus || 0) + (state.aether?.petPlus||0);
      const gr = gridRect();
      for(let i=0;i<count;i++){ state.pets.push({ x: gr.left + Math.random()*gr.width, y: gr.top + Math.random()*gr.height, vx:0, vy:0, targetIdx:-1, cd:0 }); }
      renderPets();
    }
    function renderPets(){ gridEl.querySelectorAll('.pet').forEach(p=>p.remove()); const gr = gridRect(); for(const p of state.pets){ const el=document.createElement('div'); el.className='pet'; const localX = p.x - gr.left - 8; const localY = p.y - gr.top - 8; el.style.transform = `translate(${localX}px, ${localY}px)`; gridEl.appendChild(el); } }
    function findNearestOreIdx(x,y){ let best=-1, bestD=1e9; for(let i=0;i<25;i++){ const ore=state.grid[i]; if(!ore) continue; const c=cellCenter(i); const d=Math.hypot(c.x-x, c.y-y); if(d<bestD){ bestD=d; best=i; } } return best; }
    function petsFrame(ts){ if(!state.inRun) return; const gr=gridRect(); const dt=Math.min(0.05,(ts-state.lastAnimTs)/1000 || 0.016); state.lastAnimTs=ts; for(const p of state.pets){ if(p.targetIdx<0 || !state.grid[p.targetIdx]) p.targetIdx = findNearestOreIdx(p.x,p.y); if(p.targetIdx>=0){ const c=cellCenter(p.targetIdx); const dx=c.x-p.x, dy=c.y-p.y; const dist=Math.hypot(dx,dy)||1; const speed = dist<28 ? PET.moveSpeed*(dist/28) : PET.moveSpeed; const steerX = (dx/dist)*speed - p.vx; const steerY = (dy/dist)*speed - p.vy; p.vx += steerX*0.12; p.vy += steerY*0.12; } else { p.vx += (Math.random()-0.5)*10*dt; p.vy += (Math.random()-0.5)*10*dt; } }
      for(let i=0;i<state.pets.length;i++){ for(let j=i+1;j<state.pets.length;j++){ const a=state.pets[i], b=state.pets[j]; const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy); const r=PET.sepRadius; if(d>0 && d<r){ const push=(r-d)/r*60; const nx=dx/d, ny=dy/d; a.vx -= nx*push; a.vy -= ny*push; b.vx += nx*push; b.vy += ny*push; } } }
      for(const p of state.pets){ p.x += p.vx*dt; p.y += p.vy*dt; p.x = Math.max(gr.left+8, Math.min(gr.right-8, p.x)); p.y = Math.max(gr.top+8, Math.min(gr.bottom-8, p.y)); if(p.targetIdx>=0){ const c=cellCenter(p.targetIdx); const dist=Math.hypot(c.x-p.x, c.y-p.y); p.cd -= dt; if(dist<=PET.atkRange && p.cd<=0){ p.cd = PET.atkInterval; hit(p.targetIdx,'pet'); } } }
      renderPets(); requestAnimationFrame(petsFrame); }

    document.querySelectorAll('.tab-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        SFX.ui();
        document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
        const t=btn.dataset.tab;
        ['dungeon','inventory','upgrades','skills','aether','settings'].forEach(id=>{
          document.querySelector('#tab-'+id).style.display = (id===t? 'block':'none');
        });
        renderTop();
        if(t==='skills') renderSkills();
        if(t==='aether') renderAether();
        if(t==='inventory') renderInventory();
      })
    });
    $('#toggleRunBtn').addEventListener('click', ()=>{ ensureAudio(); SFX.ui(); startRun(); });
    $('#exitBtn').addEventListener('click', ()=>{ SFX.ui(); bankAndExit(false); });
    $('#saveBtn').addEventListener('click', ()=>{ SFX.ui(); save(); });
    $('#resetBtn').addEventListener('click', ()=>{ SFX.ui(); if(confirm('ì •ë§ ì „ì²´ ì´ˆê¸°í™”í• ê¹Œìš”? (ì„¸ì´ë¸Œ ì „ë¶€ ì‚­ì œ)')){ try{ localStorage.removeItem(SAVE_KEY); }catch(e){} try{ LEGACY_KEYS.forEach(k=>localStorage.removeItem(k)); }catch(e){} location.reload(); } });
    $('#fullscreenBtn').addEventListener('click', ()=>{ SFX.ui(); if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } });
    $('#toggleSoundBtn').addEventListener('click', ()=>{ SFX.ui(); sfxEnabled=!sfxEnabled; $('#toggleSoundBtn').textContent = `íš¨ê³¼ìŒ: ${sfxEnabled?'ì¼œì§':'êº¼ì§'}`; });

    // Export / Import for backup/move domains
    document.getElementById('exportBtn').addEventListener('click', ()=>{
      SFX.ui();
      const blob = new Blob([localStorage.getItem(SAVE_KEY)||'{}'], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'miner_save.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('importBtn').addEventListener('click', ()=>{
      SFX.ui();
      const i = document.createElement('input'); i.type='file'; i.accept='application/json';
      i.onchange = async ()=>{ const f=i.files?.[0]; if(!f) return; const text = await f.text();
        try{ JSON.parse(text); localStorage.setItem(SAVE_KEY, text); location.reload(); }
        catch(e){ alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ì˜ëª»ëœ íŒŒì¼'); }
      };
      i.click();
    });

    document.getElementById('autoAdvanceBuyBtn').addEventListener('click', ()=>{
      if(state.aether.autoAdvanceOwned) return;
      if(state.highestFloor < 20) return toast('ì§€í•˜ 20ì¸µ ì´ìƒì—ì„œ í•´ê¸ˆ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
      if(state.player.ether < 150) return toast('ì—í…Œë¥´ ë¶€ì¡±');
      state.player.ether -= 150;
      state.aether.autoAdvanceOwned = true;
      state.aether.autoAdvanceEnabled = true;
      save(); renderAether(); renderTop(); toast('ìë™ ì´ë™ í•´ê¸ˆ!');
    });
    document.getElementById('autoAdvanceChk').addEventListener('change', (e)=>{
      if(!state.aether.autoAdvanceOwned){ e.target.checked=false; return; }
      state.aether.autoAdvanceEnabled = e.target.checked; save();
    });
    document.getElementById('rebirthBuyBtn').addEventListener('click', ()=>{
      if(state.highestFloor < 20) return;
      let total = 0;
      const chosen = [];
      for(const p of REBIRTH_PERKS){
        if(rebirthPick[p.key]){
          const cost = perkCost(p);
          if(p.lvl >= p.max) continue;
          total += cost; chosen.push(p);
        }
      }
      if(total<=0) return;
      if(state.player.ether < total) return toast('ì—í…Œë¥´ ë¶€ì¡±');
      if(!confirm('ì„ íƒí•œ ë³´ë„ˆìŠ¤ë¥¼ êµ¬ë§¤í•˜ê³  í™˜ìƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
      state.player.ether -= total;
      for(const p of chosen){ p.apply(); }
      if(state.inRun) bankAndExit(false);
      state.floor = 1; state.aether.rebirths = (state.aether.rebirths||0)+1;
      for(const k in rebirthPick){ delete rebirthPick[k]; }
      save(); renderAether(); renderTop(); toast('ë³´ë„ˆìŠ¤ êµ¬ë§¤ ë° í™˜ìƒ ì™„ë£Œ!');
    });
    document.addEventListener('change', (e)=>{
      const t = e.target;
      if(t && t.matches('input[data-perk]')){
        rebirthPick[t.dataset.perk] = t.checked ? 1 : 0;
        renderAether();
      }
    });

    function boot(){ load(); renderGrid(); renderInventory(); renderUpgrades(); renderSkills(); renderAether(); renderTop(); renderSkillBar(); }
    boot();

    function toast(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',left:'50%',top:'14%',transform:'translateX(-50%)',background:'#11193a',border:'1px solid #263165',padding:'10px 14px',borderRadius:'12px',color:'#eaf2ff',zIndex:9999}); document.body.appendChild(t); setTimeout(()=>t.remove(),1100); }
    function refresh(){ renderTop(); renderGrid(); renderInventory(); renderUpgrades(); }

  })();
  </script>
</body>
</html>
