<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>드래그 광산</title>
  <style>
    :root{ --bg:#0f1220;--panel:#161a2e;--accent:#6ee7ff;--accent2:#a78bfa;--text:#eaf2ff;--muted:#9aa3b2;--danger:#ff6b6b;--ok:#22c55e; --bar:#1b2342; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0; overscroll-behavior-y: none; overscroll-behavior-x: none;}
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif; background:linear-gradient(180deg, #0b0e1a 0%, #0f1220 100%); color:var(--text);}
    body.lock-v{ overflow:hidden; }
    .app{max-width:520px;margin:0 auto;display:flex;flex-direction:column;min-height:100vh;}
    header{position:sticky;top:0;z-index:10;background:rgba(15,18,32,0.9);backdrop-filter: blur(6px);border-bottom:1px solid #22263f}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;gap:8px}
    .hud{display:flex;flex-direction:column;gap:2px;min-width:0}
    .hud-line{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
    .btn{appearance:none;border:none;background:var(--accent2);color:#0b0e1a;border-radius:12px;padding:10px 14px;font-weight:700;transition:transform .04s}
    .btn:active{transform:scale(.98)}
    .btn.secondary{background:#243b55;color:#eaf2ff;border:1px solid #2f3a63}
    .btn.danger{background:var(--danger);color:white}
    .btn.ghost{background:#0d132b;color:#cbd5ff;border:1px solid #263165}
    .btn:disabled{opacity:.6}

    .tabs{display:flex;gap:8px;padding:8px 12px;background:#0d1020;border-top:1px solid #22263f}
    .tab-btn{flex:1;border:none;padding:10px 0;border-radius:12px;background:#1a2040;color:#b9c3ff;font-weight:700;transition:transform .04s}
    .tab-btn:active{transform:scale(.98)}
    .tab-btn.active{background:var(--accent);color:#001018}

    .screen{flex:1;display:flex;flex-direction:column;padding:10px 12px;gap:10px;overflow-y:auto}
    .timerbar{height:10px;background:var(--bar);border-radius:999px;overflow:hidden;border:1px solid #283058}
    .timerbar > div{height:100%;background:linear-gradient(90deg, #22c55e, #facc15);width:100%}

    #tab-dungeon{flex:1;display:flex;flex-direction:column;overflow:hidden}
    .grid-wrap{position:relative;flex:1;display:flex;flex-direction:column;min-height:0}
    .grid{position:relative;background:#0e1328;padding:6px;border-radius:16px;border:1px solid #202a51;touch-action: none;flex:1}
    .ore{position:absolute;width:52px;height:52px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:900;color:#0a0e1e;text-shadow:0 1px 0 rgba(255,255,255,.2);}
    .ore .name{display:none}
    .hp{position:absolute;top:6px;left:6px;right:6px;height:8px;background:rgba(0,0,0,.35);border-radius:999px;border:1px solid rgba(255,255,255,.08);overflow:hidden}
    .hp>div{height:100%;background:linear-gradient(90deg,#34d399,#f59e0b);width:100%}
    .dmg{position:absolute;pointer-events:none;font-weight:900;animation:float .6s ease-out forwards;white-space:nowrap;color:#fdf7d8;-webkit-text-stroke:1.2px rgba(10,14,30,0.85);text-shadow:0 0 6px rgba(10,14,30,0.9),0 0 18px rgba(10,14,30,0.75);letter-spacing:0.5px}
    .dmg.crit{color:#ffd1dc;-webkit-text-stroke:1.2px rgba(64,0,32,0.9);text-shadow:0 0 10px rgba(255,82,115,0.75),0 0 20px rgba(10,14,30,0.8)}
    @keyframes float{to{transform:translateY(-24px);opacity:0}}

    .pet{position:absolute;width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid #0e7490;box-shadow:0 0 10px rgba(34,211,238,.6)}
    .pet::after{content:'🐾';position:absolute;font-size:12px;left:50%;top:50%;transform:translate(-50%,-55%)}

    .row{display:flex;gap:8px;align-items:center}
    .panel{background:var(--panel);border:1px solid #232844;border-radius:16px;padding:12px}

    .settings-card{background:#0f1430;border:1px solid #273061;border-radius:12px;padding:12px;margin-top:12px}
    .settings-card h4{margin:0 0 4px 0}

    .inventory{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .inv-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .inv-item{background:#0f1430;border:1px solid #1f2853;border-radius:12px;padding:10px}
    .inv-item h4{margin:0 0 6px 0}
    .price{color:#a3e635;font-weight:800}

    /* Skills */
    .skillshop{display:grid;grid-template-columns:1fr;gap:10px}
    .skill-card{background:#0f1430;border:1px solid #273061;border-radius:12px;padding:10px}
    .skill-card.owned-active{opacity:0.45}
    .skillbar{position:sticky;bottom:0;margin-top:8px;background:#0e1328;border:1px solid #1f2853;border-radius:12px;padding:6px;display:grid;grid-template-columns:repeat(5,1fr);gap:6px}
    .skillbtn{height:44px;border-radius:10px;border:1px solid #30407a;background:#18224a;color:#dbe7ff;font-weight:800}
    .skillbtn.cd{position:relative}
    .skillbtn.cd::after{content:'';position:absolute;inset:0;background:rgba(0,0,0,.35);}
    .slotlist{display:grid;grid-template-columns:repeat(5,1fr);gap:6px;margin-top:8px}
    .slot{background:#0c1230;border:1px dashed #27408b;border-radius:10px;min-height:42px;display:flex;align-items:center;justify-content:center;cursor:pointer; font-size:12px; white-space:nowrap}

    /* Aether */
    .aether-grid{display:grid;grid-template-columns:1fr;gap:10px}
    .ae-card{background:#0f1430;border:1px solid #53338f;border-radius:12px;padding:10px}
    .ae-card h4{margin:0 0 6px 0}
    .ae-meta{color:#c4b5fd}

    footer{padding:8px 0}
    #ad-container{min-height:90px;display:flex;justify-content:center;align-items:center;width:100%}
  
/* --- Sticky header, stable UI, centered grid --- */
header{ position: sticky; top:0; z-index:3000; }
#ad-container{ width:100%; min-height:90px; display:flex; align-items:center; justify-content:center; }

/* Never allow accidental blur/fade of UI in any viewer */
body, .app, .screen, header, .tabs, .grid-wrap, .grid, button, .btn, .tab-btn{ filter:none !important; opacity:1 !important; }

/* Make grid container center its content; grid itself will be pixel-locked by JS */
.grid-wrap{ position:relative; flex:1; display:flex; flex-direction:column; min-height:0; }
.grid{ margin:0 auto; flex:none; }


/* --- Stable tabs: no display:none to prevent dungeon shrink --- */



/* --- Safer tab visibility (prevent overlap) --- */

/* Keep dungeon laid out even when hidden to avoid shrink on re-show */



/* --- FIX: real tab sections visibility --- */
section[id^="tab-"]{ display:none; }
section[id^="tab-"].active{ display:block; }
#tab-dungeon.active{ display:flex; } /* dungeon keeps flex */

</style>
</head>
<body>
  <div class="app">
    <header>
      <div id="ad-container"><!-- Google AdSense --></div>

      <div class="topbar">
        <div class="hud mono">
          <div class="hud-line" id="hud1">💰 0 · ✨ 0</div>
          <div class="hud-line" id="hud2">🗡️ 1 · 🗼 지하 1층</div>
        </div>
        <div class="row">
          <button id="toggleRunBtn" class="btn">던전 도전</button>
          <button id="exitBtn" class="btn danger" disabled>나가기</button>
        </div>
      </div>
      <div class="timerbar"><div id="timeFill"></div></div>
      <div class="tabs">
        <button class="tab-btn" data-tab="dungeon">⛏️ 던전</button>
        <button class="tab-btn" data-tab="inventory">🎒 인벤토리</button>
        <button class="tab-btn" data-tab="upgrades">📈 업그레이드</button>
        <button class="tab-btn" data-tab="skills">🪄 스킬</button>
        <button class="tab-btn" data-tab="aether">🔮 에테르</button>
        <button class="tab-btn" data-tab="settings">⚙️ 설정</button>
      </div>
    </header>

    <main class="screen">
      <section id="tab-dungeon" class="panel">
        <div class="row" style="justify-content:space-between;margin-bottom:6px">
          <div class="mono" id="timeMono">⏳ <span id="timeLeft">--</span>s</div>
        </div>
        <div class="grid-wrap">
          <div id="grid" class="grid"></div>
          <div id="skillBar" class="skillbar" style="display:none"></div>
        </div>
      </section>

      <section id="tab-inventory" class="panel" >
        <div class="inv-actions">
          <div class="row" style="gap:8px">
            <input type="checkbox" id="autoSellChkInv" style="width:18px;height:18px">
            <label for="autoSellChkInv" class="mono">광석 자동판매</label>
          </div>
          <button id="sellAllGlobal" class="btn secondary">모든 광물 판매</button>
        </div>
        <div class="inventory" id="inventoryList"></div>
      </section>

      <section id="tab-upgrades" class="panel" >
        <div id="upgrades"></div>
      </section>

      <section id="tab-skills" class="panel" >
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div class="row"><span>액티브 슬롯:</span> <b id="slotCount" class="mono">0/5</b></div>
        </div>
        <div class="slotlist" id="slotList"></div>
        <h4 style="margin:10px 0 6px 0">패시브 스킬 상점</h4>
        <div class="skillshop" id="skillShopPassive"></div>
        <h4 style="margin:14px 0 6px 0">액티브 스킬 상점</h4>
        <div class="skillshop" id="skillShopActive"></div>
      </section>

      <section id="tab-aether" class="panel" >
        <div class="row" style="justify-content:space-between">
          <div class="mono">에테르: <b id="aeBalance">0</b></div>
          <div class="mono">환생: <b id="rebirths">0회</b></div>
        </div>
        <div class="ae-card">
          <h4>환생 준비</h4>
          <div class="ae-meta">지하 20층 이상에서 환생 가능. 아래 보너스를 이번 환생에 함께 구매할 수 있습니다.</div>
          <div id="rebirthPerks" class="aether-grid" style="margin-top:8px"></div>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="mono">총 비용: <b id="rebirthTotal">0</b> 에테르</div>
            <button id="rebirthBuyBtn" class="btn danger" disabled>보너스 구매 + 환생</button>
          </div>
        </div>
        <div class="ae-card">
          <h4>자동 이동</h4>
          <div class="row" style="justify-content:space-between;flex-wrap:wrap">
            <div class="ae-meta">보스(에테르) 처치 시 다음 층으로 자동 입장</div>
            <div class="row">
              <input type="checkbox" id="autoAdvanceChk" style="width:18px;height:18px" disabled>
              <label for="autoAdvanceChk" class="mono" style="margin-left:6px">활성화</label>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="autoAdvanceBuyBtn" class="btn" disabled>에테르 150 소모 후 해금</button>
          </div>
        </div>
      </section>

      <section id="tab-settings" class="panel" >
        <div class="row" style="flex-wrap:wrap;gap:10px">
          <button id="saveBtn" class="btn secondary">수동 저장</button>
          <button id="exportBtn" class="btn secondary">내보내기</button>
          <button id="importBtn" class="btn secondary">불러오기</button>
          <button id="fullscreenBtn" class="btn secondary">전체화면</button>
          <button id="toggleSoundBtn" class="btn ghost">효과음: 켜짐</button>
          <button id="resetBtn" class="btn danger">초기화</button>
        </div>
        <div class="settings-card" id="playGamesCard">
          <div class="row" style="justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
            <div>
              <h4>Google Play 게임즈</h4>
              <div class="mono" id="playGamesStatus">로그인 상태 확인 중...</div>
            </div>
            <button id="playGamesLoginBtn" class="btn" style="min-width:120px">로그인</button>
          </div>
          <div class="mono" id="playGamesHelp" style="margin-top:8px;opacity:.72">구글 플레이 게임즈 계정으로 업적과 저장을 연동합니다.</div>
        </div>
      </section>
    </main>

    
  </div>
  <script src="data/upgrades.js"></script>
  <script src="data/skills.js"></script>
  <script src="data/aether.js"></script>
  <script>
  (()=>{

    const ORES = [
      { key:'Stone',    name:'석재',     color:'#a3a3a3', hp:  60, value: 10,   tier:1 },
      { key:'Copper',   name:'구리',     color:'#ef9a9a', hp: 120, value: 20,   tier:1 },
      { key:'Iron',     name:'철',       color:'#90caf9', hp: 220, value: 40,   tier:2 },
      { key:'Silver',   name:'은',       color:'#cfd8dc', hp: 380, value: 90,   tier:3 },
      { key:'Gold',     name:'금',       color:'#f6e05e', hp: 650, value: 200,  tier:3 },
      { key:'Platinum', name:'백금',     color:'#e5e7eb', hp: 900, value: 320,  tier:4 },
      { key:'Sapphire', name:'사파이어', color:'#60a5fa', hp:1200, value: 480,  tier:4 },
      { key:'Ruby',     name:'루비',     color:'#f43f5e', hp:1400, value: 600,  tier:5 },
      { key:'Emerald',  name:'에메랄드', color:'#34d399', hp:1650, value: 800,  tier:5 },
      { key:'Mythril',  name:'미스릴',   color:'#93c5fd', hp:2200, value:1200, tier:6 },
      { key:'Diamond',  name:'다이아몬드', color:'#b9f6ff', hp:3000, value:1800, tier:6 }
    ];
    window.ORE_DATA = ORES;
    const ORE_BY_KEY = new Map(ORES.map(ore=>[ore.key, ore]));
    const SPAWN_COLUMN_MAP = {
      '석재':'Stone',
      '구리':'Copper',
      '철':'Iron',
      '은':'Silver',
      '금':'Gold',
      '백금':'Platinum',
      '사파이어':'Sapphire',
      '루비':'Ruby',
      '에메랄드':'Emerald',
      '미스릴':'Mythril',
      '다이아몬드':'Diamond'
    };
    function parseSpawnTable(raw){
      const table = new Map();
      if(typeof raw !== 'string') return { table, floors: [], maxFloor: 0 };
      const lines = raw.split(/\r?\n/).map(line=>line.trim()).filter(line=>line.length>0);
      if(lines.length<=1) return { table, floors: [], maxFloor: 0 };
      const headers = lines[0].split(/\s+/);
      const columns = headers.slice(1).map(label=> SPAWN_COLUMN_MAP[label] || null);
      for(let i=1;i<lines.length;i++){
        const parts = lines[i].split(/\s+/).filter(Boolean);
        if(!parts.length) continue;
        const floor = parseInt(parts[0], 10);
        if(!Number.isFinite(floor)) continue;
        const row = [];
        for(let j=1;j<=columns.length;j++){
          const key = columns[j-1];
          if(!key) continue;
          const token = parts[j] ?? '0';
          const value = parseFloat(token.replace(/,/g,''));
          if(!Number.isFinite(value) || value<=0) continue;
          row.push({ key, chance: value });
        }
        if(row.length) table.set(floor, row);
      }
      const floors = Array.from(table.keys()).sort((a,b)=>a-b);
      const maxFloor = floors.length? floors[floors.length-1] : 0;
      return { table, floors, maxFloor };
    }
    let SPAWN_TABLE = new Map();
    let SPAWN_FLOORS = [];
    let SPAWN_MAX_FLOOR = 0;

    async function loadSpawnTable(){
      try{
        const resp = await fetch('data/spawnore');
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const text = await resp.text();
        const info = parseSpawnTable(text || '');
        SPAWN_TABLE = info.table || new Map();
        SPAWN_FLOORS = info.floors || [];
        SPAWN_MAX_FLOOR = info.maxFloor || 0;
      }catch(err){
        console.warn('Failed to load spawn table, using defaults', err);
        const fallback = parseSpawnTable('');
        SPAWN_TABLE = fallback.table;
        SPAWN_FLOORS = fallback.floors;
        SPAWN_MAX_FLOOR = fallback.maxFloor;
      }
    }
    const ACTIVE_SKILLS = window.ACTIVE_SKILL_DATA;
    const PASSIVE_SKILLS = window.PASSIVE_SKILL_DATA;
    const REBIRTH_PERKS = window.REBIRTH_PERK_DATA;
    const UPGRADE_INFO = window.UPGRADE_INFO;
    const UPGRADE_DEFAULTS = window.UPGRADE_DEFAULTS;
    const UPGRADE_CONFIG = window.UPGRADE_CONFIG;
    const VERSION = 'miner_v2.6.1';
    // 고정 세이브키 + 구버전 마이그레이션
    const SAVE_KEY = 'miner_save_v1';
    const LEGACY_KEYS = Object.keys(localStorage).filter(k=>/^miner_v/.test(k));

    // ---------- Audio ----------
    let audioCtx = null, sfxEnabled = true;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function beep(freq=600, dur=0.06, type='square', gain=0.03){
      if(!sfxEnabled) return;
      ensureAudio();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t);
      o.stop(t+dur);
    }
    const HIT_SOUNDS = [
      'sounds/impactMetal_heavy_000.ogg',
      'sounds/impactMetal_heavy_001.ogg',
      'sounds/impactMetal_heavy_002.ogg',
      'sounds/impactMetal_heavy_003.ogg',
      'sounds/impactMetal_heavy_004.ogg'
    ];
    let hitSoundBuffers = [];
    let hitSoundPromise = null;
    function decodeAudio(arrayBuffer){
      if(!audioCtx) return Promise.resolve(null);
      if(typeof audioCtx.decodeAudioData !== 'function') return Promise.resolve(null);
      if(audioCtx.decodeAudioData.length === 1){
        try{
          return audioCtx.decodeAudioData(arrayBuffer);
        }catch(err){
          return Promise.reject(err);
        }
      }
      return new Promise((resolve, reject)=>{
        try{
          audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
        }catch(err){ reject(err); }
      });
    }
    function loadHitSounds(){
      if(hitSoundBuffers.length) return Promise.resolve(hitSoundBuffers);
      if(hitSoundPromise) return hitSoundPromise;
      ensureAudio();
      hitSoundPromise = Promise.all(HIT_SOUNDS.map(async (url)=>{
        try{
          const resp = await fetch(url);
          if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
          const buf = await resp.arrayBuffer();
          return await decodeAudio(buf);
        }catch(err){
          console.warn('Failed to load ore hit sound', url, err);
          return null;
        }
      })).then(results=>{
        hitSoundBuffers = results.filter(Boolean);
        return hitSoundBuffers;
      }).catch(err=>{
        console.warn('Ore hit sound load failed', err);
        return [];
      });
      return hitSoundPromise;
    }
    function playBuffer(buffer, gainValue=0.6){
      if(!buffer || !audioCtx) return;
      const source = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      gain.gain.value = gainValue;
      source.buffer = buffer;
      source.connect(gain);
      gain.connect(audioCtx.destination);
      try{ source.start(); }
      catch(err){ console.warn('Failed to start buffer', err); }
    }
    async function playOreHit(volume=0.65){
      if(!sfxEnabled) return false;
      ensureAudio();
      try{
        const buffers = await loadHitSounds();
        if(buffers && buffers.length){
          const buffer = buffers[Math.floor(Math.random()*buffers.length)];
          playBuffer(buffer, volume);
          return true;
        }
      }catch(err){
        console.warn('Ore hit playback failed', err);
      }
      return false;
    }
    const SFX = {
      async hit(){
        const played = await playOreHit(0.7);
        if(!played) beep(520,0.03,'square',0.035);
      },
      async crit(){
        const played = await playOreHit(0.75);
        if(!played) beep(900,0.05,'square',0.045);
      },
      break(){ beep(240,0.07,'sawtooth',0.05); },
      skill(){ beep(700,0.08,'triangle',0.05); },
      deny(){ beep(180,0.12,'square',0.04); },
      ui(){ beep(430,0.05,'triangle',0.035); }
    };

    // ---------- Game State ----------
    const state = {
      player: { atkBase: 10, atk: 10, critChanceBase: 0.10, critChance: 0.10, critMult: 2.0, gold: 0, ether: 0 },
      upgrades: (()=>{
        const defaults = {};
        for(const [key, def] of Object.entries(UPGRADE_DEFAULTS||{})){
          if(def && typeof def === 'object' && !Array.isArray(def)) defaults[key] = { ...def };
        }
        defaults.oreMul = {};
        return defaults;
      })(),
      aether: { luck:0, petPlus:0, etherHaste:0, rebirths:0, autoAdvanceOwned:false, autoAdvanceEnabled:false },

      floor: 1,
      highestFloor: 1,
      inventory: {},
      loot: {},
      grid: new Array(25).fill(null),
      inRun:false,
      timeLeft: 0.0,
      timers: { spawn:null, tick:null },
      pets: [],
      pointerState: {},
      lastAnimTs: 0,
      runStartTs: 0,
      etherSpawned: false,

      // Skills
      skillsOwnedActive: {},
      skillsOwnedPassive: {},
      skillSlots: [null,null,null,null,null],
      skillCooldowns: {},
      skillHasteUntil: 0,
      skillAtkBuffUntil: 0,

      // Passive bonuses
      passive: { sellBonus: 0, petPlus: 0 },

      // Settings
      settings: { autoSell:false }
    };

    // ---------- Save/Load (stable key + migration) ----------
    function save(){
      const { atk, ...player } = state.player;
      const { critChance, ...restPlayer } = player;
      const payload = {
        __version: VERSION,
        player: restPlayer,
        upgrades:state.upgrades, floor:state.floor, highestFloor:state.highestFloor,
        inventory:state.inventory, skillsOwnedActive:state.skillsOwnedActive, skillsOwnedPassive:state.skillsOwnedPassive,
        skillSlots:state.skillSlots, passive:state.passive, aether:state.aether, settings:state.settings
      };
      try{ localStorage.setItem(SAVE_KEY, JSON.stringify(payload)); }catch(e){ console.warn('save failed', e); }
    }
    function load(){
      let raw = localStorage.getItem(SAVE_KEY);
      if(!raw){
        for(const k of LEGACY_KEYS){
          raw = localStorage.getItem(k);
          if(raw){ try{ localStorage.setItem(SAVE_KEY, raw); }catch(e){} break; }
        }
      }
      if(!raw) return;
      try{
        const s = JSON.parse(raw);
        Object.assign(state.player,s.player||{});
        delete state.player.atk;
        const savedUpgrades = s.upgrades || {};
        if(savedUpgrades.oreMul && typeof savedUpgrades.oreMul === 'object'){
          state.upgrades.oreMul = { ...state.upgrades.oreMul, ...savedUpgrades.oreMul };
        }
        for(const [key, def] of Object.entries(UPGRADE_DEFAULTS || {})){
          const saved = savedUpgrades[key];
          const lvl = typeof saved === 'number' ? saved
            : (saved && typeof saved.level === 'number' ? saved.level : def.level || 0);
          state.upgrades[key] = { level: Math.max(0, lvl) };
        }
        state.floor=s.floor||1; state.highestFloor=s.highestFloor||1;
        state.inventory=s.inventory||state.inventory;
        state.skillsOwnedActive=s.skillsOwnedActive||{};
        state.skillsOwnedPassive=s.skillsOwnedPassive||{};
        state.skillSlots=s.skillSlots||[null,null,null,null,null];
        state.passive=s.passive||state.passive;
        state.aether = s.aether || state.aether;
        state.settings = s.settings || state.settings;
        if(typeof state.player.atkBase === 'undefined'){
          state.player.atkBase = (typeof s.player?.atk === 'number') ? s.player.atk : 10;
        }
        if(typeof state.player.critChanceBase !== 'number'){
          const savedCrit = typeof s.player?.critChance === 'number' ? s.player.critChance : state.player.critChance;
          const critCfg = UPGRADE_CONFIG?.crit;
          const perLevel = critCfg?.effectPerLevel || 0;
          const critLvl = state.upgrades?.crit?.level || 0;
          const estimatedBase = typeof savedCrit === 'number' ? savedCrit - (perLevel * critLvl) : undefined;
          const base = (typeof estimatedBase === 'number' && !Number.isNaN(estimatedBase)) ? estimatedBase : 0.10;
          state.player.critChanceBase = Math.min(0.5, Math.max(0.01, +base.toFixed(4)));
        }
      }catch(e){ console.warn('load failed', e); }
    }

    // ---------- Skills ----------
    // 데이터는 data/skills.js에서 로드됩니다.

    // ---------- Rebirth-only Aether ----------
    // 데이터는 data/aether.js에서 로드됩니다.
    function perkCost(p){ return Math.floor(p.base * Math.pow(p.scale, p.getLevel(state))); }
    const rebirthPick = {}; // {key:1}

    // ---------- Ores ----------
    // 데이터는 data/probabilities.js에서 로드됩니다.

    for(const o of ORES){ state.inventory[o.key]=state.inventory[o.key]||0; state.loot[o.key]=0; state.upgrades.oreMul[o.key]=state.upgrades.oreMul[o.key]||0; }

    const PET = { moveSpeed: 220, atkInterval: 0.55, sepRadius: 24, atkRange: 18 };

    const $ = sel => document.querySelector(sel);
    const gridEl = $('#grid');
    const skillBarEl = $('#skillBar');
    const screenEl = $('.screen');
    let gridRectCache = null;
    let lastGridRectValid = null;

    const ORE_SIZE = 52;
    const ORE_RADIUS = ORE_SIZE / 2;
    const GRID_SAFE_MARGIN = 6;

    function spawnAxisInfo(size){
      const safeSize = Math.max(ORE_SIZE, size || 0);
      const extra = Math.max(0, safeSize - ORE_SIZE);
      const margin = Math.min(GRID_SAFE_MARGIN, extra / 2);
      const span = Math.max(0, safeSize - 2 * (ORE_RADIUS + margin));
      const start = ORE_RADIUS + margin;
      return { start, span };
    }

    const playGamesCardEl = document.getElementById('playGamesCard');
    const playGamesStatusEl = document.getElementById('playGamesStatus');
    const playGamesLoginBtn = document.getElementById('playGamesLoginBtn');
    const playGamesHelpEl = document.getElementById('playGamesHelp');

    const playGamesState = {
      available:false,
      signedIn:false,
      busy:false,
      canLogin:false,
      initialized:false,
      playerName:'',
      check:null,
      login:null,
      bridge:null
    };

    function parsePlayGamesBool(v){
      if(typeof v === 'boolean') return v;
      if(typeof v === 'number') return v !== 0;
      if(typeof v === 'string'){
        const norm = v.trim().toLowerCase();
        if(!norm) return false;
        if(['true','1','yes','y','signed_in','connected','ok','success','logged_in','login','signedin'].includes(norm)) return true;
        if(['false','0','no','n','signed_out','disconnected','fail','failed','error','logged_out','logout','signedout','not_signed_in','not signed in','not_signedin'].includes(norm)) return false;
        if(norm.includes('required') || norm.includes('sign_out') || norm.includes('signed_out') || norm.includes('logout')) return false;
        if((norm.includes('signed_in') || norm.includes('sign_in')) && !norm.includes('required')) return true;
      }
      return !!v;
    }

    function parsePlayGamesPayload(payload){
      if(typeof payload === 'string'){
        const parts = payload.split(/[|,:]/).map(s=>s.trim()).filter(Boolean);
        if(parts.length>1){
          return { signedIn: parsePlayGamesBool(parts[0]), name: parts.slice(1).join(' ') };
        }
        return { signedIn: parsePlayGamesBool(payload) };
      }
      if(typeof payload === 'object' && payload){
        const keys = ['signedIn','isSignedIn','loggedIn','isLoggedIn','success','status','state'];
        let signed;
        for(const k of keys){
          if(Object.prototype.hasOwnProperty.call(payload,k)){
            signed = payload[k];
            break;
          }
        }
        if(typeof signed === 'string'){
          const lower = signed.trim().toLowerCase();
          if(lower){
            if(lower.includes('required') || lower.includes('fail') || lower.includes('error') || lower.includes('denied') || lower.includes('sign_out') || lower.includes('signed_out') || lower.includes('logout')) signed = false;
            else if(lower.includes('signed_in') || lower.includes('sign_in') || lower.includes('connected') || lower.includes('success') || lower.includes('authorized') || lower.includes('granted') || lower === 'ok') signed = true;
          }
        }
        const name = payload.displayName || payload.playerName || payload.name || payload.nickname;
        return { signedIn: typeof signed === 'undefined' ? undefined : parsePlayGamesBool(signed), name: name? String(name) : undefined };
      }
      if(typeof payload === 'undefined') return { signedIn: undefined };
      return { signedIn: parsePlayGamesBool(payload) };
    }

    function updatePlayGamesUI(){
      if(!playGamesCardEl) return;
      if(playGamesStatusEl){
        if(!playGamesState.available){
          playGamesStatusEl.textContent = 'Android 앱에서만 지원됩니다.';
        } else if(!playGamesState.initialized){
          playGamesStatusEl.textContent = '로그인 상태 확인 중...';
        } else if(playGamesState.signedIn){
          playGamesStatusEl.textContent = playGamesState.playerName ? `로그인됨 (${playGamesState.playerName})` : '로그인됨';
        } else {
          playGamesStatusEl.textContent = playGamesState.busy ? '로그인 중...' : '로그인 필요';
        }
      }
      if(playGamesHelpEl){
        if(!playGamesState.available){
          playGamesHelpEl.textContent = 'Android WebView 앱에서 플레이 게임즈 연동 시 표시됩니다.';
        } else if(playGamesState.signedIn){
          playGamesHelpEl.textContent = '플레이 게임즈에 연결되었습니다.';
        } else if(playGamesState.canLogin){
          playGamesHelpEl.textContent = '구글 플레이 게임즈 계정으로 업적과 저장을 연동합니다.';
        } else {
          playGamesHelpEl.textContent = '로그인은 앱에서만 지원됩니다.';
        }
      }
      if(playGamesLoginBtn){
        const showBtn = playGamesState.available && playGamesState.canLogin && playGamesState.initialized && !playGamesState.signedIn;
        playGamesLoginBtn.style.display = showBtn ? 'inline-flex' : 'none';
        playGamesLoginBtn.disabled = playGamesState.busy;
        playGamesLoginBtn.textContent = playGamesState.busy ? '로그인 중...' : '로그인';
      }
    }

    function setPlayGamesState(payload){
      const parsed = parsePlayGamesPayload(payload);
      playGamesState.available = true;
      playGamesState.initialized = true;
      if(typeof parsed.signedIn !== 'undefined'){
        playGamesState.signedIn = !!parsed.signedIn;
        if(!playGamesState.signedIn && !parsed.name) playGamesState.playerName = '';
      }
      if(parsed.name){
        playGamesState.playerName = parsed.name;
      } else if(!playGamesState.signedIn){
        playGamesState.playerName = '';
      }
      playGamesState.busy = false;
      updatePlayGamesUI();
    }

    function detectPlayGamesBridge(){
      const candidates = [
        window.PlayGames,
        window.playGames,
        window.Android && window.Android.PlayGames,
        window.Android
      ].filter(Boolean);
      for(const cand of candidates){
        if(!cand) continue;
        const checkNames = ['isPlayGamesSignedIn','isPlayGamesLoggedIn','playGamesIsSignedIn','getPlayGamesLoginState','getPlayGamesSignedIn','fetchPlayGamesLoginState','isSignedIn','isSignedInPlayGames'];
        let check = null;
        for(const name of checkNames){
          if(typeof cand[name] === 'function'){ check = cand[name].bind(cand); break; }
          if(typeof cand[name] !== 'undefined'){ check = ()=> cand[name]; break; }
        }
        const loginNames = ['signInPlayGames','signInToPlayGames','playGamesSignIn','startPlayGamesLogin','loginPlayGames','loginToPlayGames','playGamesLogin','requestPlayGamesSignIn','triggerPlayGamesLogin'];
        let login = null;
        for(const name of loginNames){
          if(typeof cand[name] === 'function'){ login = cand[name].bind(cand); break; }
        }
        if(check || login){
          playGamesState.bridge = cand;
          playGamesState.check = check;
          playGamesState.login = login;
          playGamesState.canLogin = !!login;
          if(!check && login && !playGamesState.initialized){
            playGamesState.initialized = true;
            playGamesState.signedIn = false;
          }
          playGamesState.available = true;
          updatePlayGamesUI();
          return true;
        }
      }
      if(!playGamesState.available){
        playGamesState.check = null;
        playGamesState.login = null;
        playGamesState.canLogin = false;
      }
      updatePlayGamesUI();
      return false;
    }

    function refreshPlayGamesStatus(){
      if(!playGamesState.check){ updatePlayGamesUI(); return; }
      try{
        const res = playGamesState.check();
        if(res && typeof res.then === 'function'){
          res.then(val=>{ setPlayGamesState(val); }).catch(err=>{ console.warn('Play Games 상태 확인 실패', err); });
        } else if(typeof res !== 'undefined'){
          setPlayGamesState(res);
        }
      }catch(err){ console.warn('Play Games 상태 확인 중 오류', err); }
    }

    window.__setPlayGamesLoginState = setPlayGamesState;
    window.__playGamesLoginState = setPlayGamesState;
    window.onPlayGamesLoginState = setPlayGamesState;
    window.PlayGamesLoginState = setPlayGamesState;
    window.updatePlayGamesLoginState = setPlayGamesState;
    window.requestPlayGamesStatus = refreshPlayGamesStatus;

    function randWeighted(items){ const total = items.reduce((a,b)=>a+b.weight,0); let r = Math.random()*total; for(const it of items){ if((r-=it.weight) <= 0) return it; } return items[0]; }
    function defaultOrePool(){ return ORES.map(o=>({ ...o, weight: 1 })); }
    function spawnRowForFloor(f){
      if(!SPAWN_FLOORS.length) return null;
      const floor = Math.max(1, Math.floor(f));
      if(SPAWN_TABLE.has(floor)) return SPAWN_TABLE.get(floor);
      if(floor > SPAWN_MAX_FLOOR) return SPAWN_TABLE.get(SPAWN_MAX_FLOOR) || null;
      for(let i=SPAWN_FLOORS.length-1;i>=0;i--){
        const candidate = SPAWN_FLOORS[i];
        if(candidate <= floor) return SPAWN_TABLE.get(candidate);
      }
      return SPAWN_TABLE.get(SPAWN_FLOORS[0]) || null;
    }
    function eligibleOresForFloor(f){
      const row = spawnRowForFloor(f);
      if(!row || !row.length) return defaultOrePool();
      const pool = [];
      const luckLevel = state.aether?.luck || 0;
      const hasLuck = luckLevel > 0;
      for(const entry of row){
        const info = ORE_BY_KEY.get(entry.key);
        if(!info) continue;
        const weight = Math.max(0, entry.chance);
        if(!(weight>0)) continue;
        let scaled = Math.max(1, Math.round(weight*100));
        if(hasLuck){
          const tierBonus = Math.max(0, (info.tier||1) - 1);
          if(tierBonus>0){
            const mul = 1 + luckLevel * 0.08 * tierBonus;
            scaled = Math.max(1, Math.round(scaled * mul));
          }
        }
        pool.push({ ...info, weight: scaled });
      }
      return pool.length ? pool : defaultOrePool();
    }
    function gridRect(){
      const r = gridEl.getBoundingClientRect();
      const hasSize = (r.width || 0) > 0 && (r.height || 0) > 0;
      if(hasSize){
        if(gridRectCache){
          const widthChanged = Math.abs(gridRectCache.width - r.width) > 0.5;
          const heightChanged = Math.abs(gridRectCache.height - r.height) > 0.5;
          if(widthChanged || heightChanged){
            const prev = gridRectCache;
            const oldAxisX = spawnAxisInfo(prev.width);
            const oldAxisY = spawnAxisInfo(prev.height);
            const newAxisX = spawnAxisInfo(r.width);
            const newAxisY = spawnAxisInfo(r.height);
            const oldInnerW = Math.max(1, oldAxisX.span || 0);
            const oldInnerH = Math.max(1, oldAxisY.span || 0);
            for(let i=0;i<state.grid.length;i++){
              const ore = state.grid[i];
              if(!ore) continue;
              const nx = Math.max(0, Math.min(1, (ore.x - oldAxisX.start) / oldInnerW));
              const ny = Math.max(0, Math.min(1, (ore.y - oldAxisY.start) / oldInnerH));
              ore.x = newAxisX.start + nx * (newAxisX.span || 0);
              ore.y = newAxisY.start + ny * (newAxisY.span || 0);
            }
            const oldPetW = Math.max(1, prev.width - 16);
            const oldPetH = Math.max(1, prev.height - 16);
            const newPetW = Math.max(1, r.width - 16);
            const newPetH = Math.max(1, r.height - 16);
            for(const pet of state.pets){
              const nx = Math.max(0, Math.min(1, (pet.x - 8) / oldPetW));
              const ny = Math.max(0, Math.min(1, (pet.y - 8) / oldPetH));
              pet.x = 8 + nx * newPetW;
              pet.y = 8 + ny * newPetH;
            }
          }
        }
        gridRectCache = {left:r.left, top:r.top, width:r.width, height:r.height, right:r.right, bottom:r.bottom};
        lastGridRectValid = gridRectCache;
        return gridRectCache;
      }
      if(lastGridRectValid){
        gridRectCache = lastGridRectValid;
        return gridRectCache;
      }
      if(gridRectCache){
        return gridRectCache;
      }
      gridRectCache = {left:r.left, top:r.top, width:ORE_SIZE, height:ORE_SIZE, right:r.left + ORE_SIZE, bottom:r.top + ORE_SIZE};
      return gridRectCache;
    }
    function cellCenter(idx){ const o = state.grid[idx]; return { x:o.x, y:o.y }; }
    function oreIndexFromPoint(x,y){ const gr = gridRect(); const localX = x - gr.left; const localY = y - gr.top; if(localX<0 || localY<0 || localX>gr.width || localY>gr.height) return -1; for(let i=0;i<25;i++){ const o=state.grid[i]; if(!o) continue; const h=ORE_RADIUS; if(localX>=o.x-h && localX<=o.x+h && localY>=o.y-h && localY<=o.y+h) return i; } return -1; }

    function sellMultiplier(key){
      const lvl = state.upgrades.oreMul[key]||0;
      const upgMul = Math.pow(1.2, lvl);
      const passiveMul = 1 + (state.passive.sellBonus||0);
      return upgMul * passiveMul;
    }

    function calcCritChance(){
      const cfg = UPGRADE_CONFIG?.crit;
      const base = (typeof state.player.critChanceBase === 'number') ? state.player.critChanceBase : 0.10;
      const lvl = state.upgrades.crit?.level || 0;
      const perLevel = cfg?.effectPerLevel || 0.02;
      const total = Math.min(0.5, Math.max(0, +(base + (perLevel * lvl)).toFixed(4)));
      state.player.critChance = total;
      return total;
    }

    function calcAtk() {
      const L = state.upgrades.atk?.level || 1;
      const base = state.player.atkBase || 10;
      const ATK_PER_LVL = 0.12;
      const ATK_MILE    = 0.35;
      const per   = Math.pow(1 + ATK_PER_LVL, Math.max(0, L - 1));
      const bonus = Math.pow(1 + ATK_MILE, Math.floor(Math.max(0, L - 1) / 10));
      const atk = Math.max(1, Math.ceil(base * per * bonus));
      state.player.atk = atk;
      calcCritChance();
      return atk;
    }

    function fmtFloor(n){ return `지하 ${n}층`; }
    function renderHud(){
      calcAtk();
      $('#hud1').textContent = `💰 ${state.player.gold} · ✨ ${state.player.ether}`;
      $('#hud2').textContent = `🗡️ ${state.player.atk} · 🗼 ${fmtFloor(state.floor)}`;
    }
    function renderTop(){
      renderHud();
      $('#timeLeft').textContent = state.inRun? state.timeLeft.toFixed(1) : '--';
      $('#exitBtn').disabled = !state.inRun;
      $('#toggleRunBtn').textContent = state.inRun? '진행 중' : '던전 도전';
      $('#toggleRunBtn').disabled = state.inRun;
      const max = 20;
      const fill = state.inRun? Math.max(0, Math.min(1, state.timeLeft / max)) : 1;
      document.getElementById('timeFill').style.width = (fill*100)+'%';
      const isDungeonVisible = document.querySelector('#tab-dungeon').style.display !== 'none';
      document.body.classList.toggle('lock-v', isDungeonVisible);
    }

    function renderGrid(){ gridEl.innerHTML=''; gridRect();
      for(let i=0;i<25;i++){ const ore=state.grid[i]; if(!ore) continue; const el=document.createElement('div'); el.className='ore'; el.style.background=ore.bg; const localX=ore.x-ORE_RADIUS; const localY=ore.y-ORE_RADIUS; el.style.transform=`translate(${localX}px, ${localY}px)`; el.dataset.idx=i; const hp=document.createElement('div'); hp.className='hp'; const f=document.createElement('div'); hp.appendChild(f); const ratio=Math.max(0,Math.min(1,ore.hp/ore.maxHp)); f.style.width=(ratio*100)+'%'; el.appendChild(hp); gridEl.appendChild(el); ore.el = el; }
      renderPets(); }

    function renderInventory(){ const box=$('#inventoryList'); box.innerHTML='';
      const chk = document.getElementById('autoSellChkInv'); if(chk){ chk.checked = !!state.settings.autoSell; chk.onchange = ()=>{ state.settings.autoSell = !!chk.checked; save(); toast(`자동판매 ${chk.checked?'ON':'OFF'}`); }; }
      for(const t of ORES){ const inv = state.inventory[t.key]||0; const mul=sellMultiplier(t.key); const li=document.createElement('div'); li.className='inv-item'; li.innerHTML = `<h4>${t.name} <span class="small">(${t.key})</span></h4><div>가치: <span class="price">${Math.round(t.value*mul)}</span> 골드</div><div class="row" style="margin-top:6px;gap:6px;flex-wrap:wrap"><button class="btn secondary" data-sellall="${t.key}">모두 판매</button><button class="btn secondary" data-sell="${t.key}">1개 판매</button><button class="btn" data-upg-ore="${t.key}">업그레이드</button></div><div class="row" style="margin-top:6px"><div class="mono">보유: ${inv}</div></div>`; box.appendChild(li);} 
      box.querySelectorAll('[data-sell]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); const k=btn.dataset.sell; const t=ORES.find(o=>o.key===k); if(state.inventory[k]>0){ state.inventory[k]--; state.player.gold+=Math.round(t.value*sellMultiplier(k)); save(); refresh(); }}));
      box.querySelectorAll('[data-sellall]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); sellAllOf(btn.dataset.sellall); }));
      box.querySelectorAll('[data-upg-ore]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); oreUpgrade(btn.dataset.upgOre)}));
      $('#sellAllGlobal').onclick = ()=>{ SFX.ui(); sellAllOres(); };
    }
    function sellAllOf(key){ const t=ORES.find(o=>o.key===key); const n=state.inventory[key]||0; if(n>0){ state.inventory[key]=0; state.player.gold+=Math.round(n*t.value*sellMultiplier(key)); save(); refresh(); } }
    function sellAllOres(){ let total=0; for(const t of ORES){ const n=state.inventory[t.key]||0; if(n>0){ total += n*t.value*sellMultiplier(t.key); state.inventory[t.key]=0; } } if(total>0){ state.player.gold += Math.round(total); save(); refresh(); } }

    function oreUpgrade(key){ const lvl = state.upgrades.oreMul[key]||0; const cost = Math.floor(10 * Math.pow(1.6, lvl)); if((state.inventory[key]||0) < cost) { toast(`${key} x${cost} 필요`); SFX.deny(); return; } state.inventory[key]-=cost; state.upgrades.oreMul[key]=lvl+1; toast(`${key} 배율 업`); SFX.ui(); save(); refresh(); }

    function renderUpgrades(){
      const cont=$('#upgrades'); cont.innerHTML='';
      calcAtk();
      for(const info of UPGRADE_INFO || []){
        const desc = typeof info.getDescription === 'function' ? info.getDescription(state) : '';
        const cost = typeof info.getCost === 'function' ? info.getCost(state) : 0;
        cont.appendChild(upgradeCard(info.title, desc, cost, ()=>{
          const check = typeof info.canBuy === 'function' ? info.canBuy(state) : true;
          if(check !== true){
            if(typeof check === 'string' && check){ toast(check); }
            SFX.deny();
            return;
          }
          const price = typeof info.getCost === 'function' ? info.getCost(state) : cost;
          if(!spend(price)){ SFX.deny(); return; }
          if(typeof info.onBuy === 'function'){
            info.onBuy({ state, restartSpawnTimer, spawnPets });
          }
          SFX.ui();
          save();
          refresh();
        }));
      }
    }
    function upgradeCard(title, desc, cost, onBuy){ const wrap=document.createElement('div'); wrap.className='inv-item'; wrap.innerHTML = `<h4 style="margin:0 0 4px 0">${title}</h4><div class="mono">${desc}</div><div class="row" style="margin-top:8px;justify-content:space-between"><div class="row"><span>가격:</span> <b class="price">${cost}</b></div><button class="btn">구매</button></div>`; wrap.querySelector('.btn').addEventListener('click', onBuy); return wrap; }
    function spend(amount){ if(state.player.gold < amount){ toast('골드 부족'); return false; } state.player.gold -= amount; return true; }
    function spendAe(amount){ if(state.player.ether < amount){ toast('에테르 부족'); return false; } state.player.ether -= amount; return true; }

    function renderAether(){
      $('#aeBalance').textContent = state.player.ether;
      $('#rebirths').textContent = (state.aether?.rebirths||0)+'회';
      const canRebirth = state.highestFloor >= 20;
      const ownAA = !!state.aether.autoAdvanceOwned;
      $('#autoAdvanceBuyBtn').disabled = ownAA || !canRebirth || state.player.ether < 150;
      $('#autoAdvanceBuyBtn').textContent = ownAA ? '해금됨' : '에테르 150 소모 후 해금';
      $('#autoAdvanceChk').disabled = !ownAA;
      $('#autoAdvanceChk').checked = !!state.aether.autoAdvanceEnabled;

      const list = $('#rebirthPerks'); list.innerHTML='';
      let total = 0;
      for(const p of REBIRTH_PERKS){
        const lvl = p.getLevel(state);
        const maxed = lvl >= p.max;
        const cost = perkCost(p);
        const checked = !!rebirthPick[p.key];
        const row = document.createElement('div'); row.className='skill-card';
        row.innerHTML = `<div class="row" style="justify-content:space-between"><b>${p.name}</b><span class="mono">${p.desc}</span></div>
                         <div class="row" style="justify-content:space-between;margin-top:6px">
                           <div class="mono">레벨 ${lvl}/${p.max} · 비용 ${cost} 에테르</div>
                           <label class="row" style="gap:6px;align-items:center">
                             <input type="checkbox" ${checked?'checked':''} ${maxed?'disabled':''} data-perk="${p.key}">
                             <span>${maxed?'최대':''}선택</span>
                           </label>
                         </div>`;
        list.appendChild(row);
        if(checked && !maxed){ total += cost; }
      }
      $('#rebirthTotal').textContent = total;
      const afford = state.player.ether >= total;
      $('#rebirthBuyBtn').disabled = !(canRebirth && afford && total>0);
    }

    function syncSkillSlotsWithOwned(){
      if(!Array.isArray(state.skillSlots)){
        state.skillSlots = [null,null,null,null,null];
      }
      const desiredLength = Math.max(5, state.skillSlots.length);
      if(state.skillSlots.length < desiredLength){
        state.skillSlots = [...state.skillSlots, ...Array(desiredLength - state.skillSlots.length).fill(null)];
      }
      let changed = false;
      for(let i=0;i<state.skillSlots.length;i++){
        const def = ACTIVE_SKILLS[i];
        const should = def && state.skillsOwnedActive[def.key] ? def.key : null;
        if(state.skillSlots[i] !== should){
          state.skillSlots[i] = should;
          changed = true;
        }
      }
      return changed;
    }

    function renderSkills(){
      const slotsUpdated = syncSkillSlotsWithOwned();
      if(slotsUpdated){ save(); }
      const slotList = $('#slotList'); slotList.innerHTML='';
      for(let i=0;i<5;i++){
        const el=document.createElement('div'); el.className='slot'; const sk = state.skillSlots[i];
        el.textContent = sk ? ACTIVE_SKILLS.find(s=>s.key===sk).name : '+ 빈 슬롯';
        el.addEventListener('click', ()=>{
          SFX.ui();
          toast('액티브 스킬은 자동으로 슬롯에 배치됩니다.');
        });
        slotList.appendChild(el);
      }
      $('#slotCount').textContent = state.skillSlots.filter(Boolean).length + '/5';

      const shopP = $('#skillShopPassive'); shopP.innerHTML='';
      for(const sk of PASSIVE_SKILLS){
        const owned = !!state.skillsOwnedPassive[sk.key];
        const card = document.createElement('div'); card.className = 'skill-card';
        card.innerHTML = `<div class="row" style="justify-content:space-between"><b>${sk.name}</b><span class="mono">패시브</span></div><div class="mono" style="opacity:.8;margin:4px 0 8px 0">${sk.desc}</div><div class="row" style="justify-content:space-between"><div>가격: <b class="price">${sk.ae}</b> 에테르</div><button class="btn" ${owned && sk.once?'disabled':''}>${owned?(sk.once?'보유중':'추가 구매'):'구매'}</button></div>`;
        card.querySelector('.btn').addEventListener('click', ()=>{
          if(!spendAe(sk.ae)) { SFX.deny(); return; }
          if(sk.once && owned){ toast('이미 보유'); SFX.deny(); return; }
          if(!state.skillsOwnedPassive[sk.key]) state.skillsOwnedPassive[sk.key]=0;
          state.skillsOwnedPassive[sk.key] += 1;
          if(typeof sk.apply === 'function'){ sk.apply({ state, spawnPets }); }
          toast(`${sk.name} 적용!`); SFX.ui(); save(); renderSkills(); renderUpgrades(); renderTop();
        });
        shopP.appendChild(card);
      }
      const shopA = $('#skillShopActive'); shopA.innerHTML='';
      for(const sk of ACTIVE_SKILLS){
        const owned = !!state.skillsOwnedActive[sk.key];
        const card = document.createElement('div'); card.className = 'skill-card';
        if(owned){ card.classList.add('owned-active'); }
        card.innerHTML = `<div class="row" style="justify-content:space-between"><b>${sk.name}</b><span class="mono">쿨타임 ${sk.cd}s</span></div><div class="mono" style="opacity:.8;margin:4px 0 8px 0">${sk.desc}</div><div class="row" style="justify-content:space-between"><div>가격: <b class="price">${sk.ae}</b> 에테르</div><button class="btn" ${owned?'disabled':''}>${owned?'보유중':'구매'}</button></div>`;
        if(!owned){
          card.querySelector('.btn').addEventListener('click', ()=>{
            if(!spendAe(sk.ae)) { SFX.deny(); return; }
            state.skillsOwnedActive[sk.key]=true; toast(`${sk.name} 획득!`); SFX.ui(); save(); renderSkills(); renderSkillBar(); renderTop();
          });
        }
        shopA.appendChild(card);
      }
    }

    function renderSkillBar(){
      syncSkillSlotsWithOwned();
      if(!state.inRun){ skillBarEl.style.display='none'; return; }
      skillBarEl.style.display='grid'; skillBarEl.innerHTML='';
      for(let i=0;i<5;i++){
        const k = state.skillSlots[i];
        const b=document.createElement('button'); b.className='skillbtn'; b.textContent = k? ACTIVE_SKILLS.find(s=>s.key===k).name : '-';
        if(!k){ b.disabled=true; }
        else {
          const cd = Math.max(0, state.skillCooldowns[k]||0);
          if(cd>0){ b.classList.add('cd'); b.textContent = `${ACTIVE_SKILLS.find(s=>s.key===k).name} (${cd.toFixed(0)}s)`; b.disabled=true; }
          b.addEventListener('click', ()=>{ SFX.ui(); useSkill(k); });
        }
        skillBarEl.appendChild(b);
      }
    }

    function setCd(key, sec){ state.skillCooldowns[key] = sec; }

    function useSkill(key){
      if(!state.inRun) return;
      const sk = ACTIVE_SKILLS.find(s=>s.key===key); if(!sk) return;
      const cd = state.skillCooldowns[key]||0; if(cd>0){ SFX.deny(); return; }
      switch(key){
        case 'berserk': state.skillAtkBuffUntil = performance.now()+5000; SFX.skill(); break;
        case 'timewarp': state.timeLeft = Math.min(20, +(state.timeLeft + 3).toFixed(1)); SFX.skill(); break;
        case 'meteor':
          for(let i=0;i<25;i++){ const o=state.grid[i]; if(!o) continue; const dmg = Math.max(10, Math.floor(o.maxHp*0.35)); o.hp -= dmg; if(o.hp<=0){ onOreBroken(i, o); } }
          SFX.skill(); break;
        case 'haste': state.skillHasteUntil = performance.now()+5000; restartSpawnTimer(); SFX.skill(); break;
        case 'sonic':
          const gr = gridRect(); const cx = gr.width/2, cy = gr.height/2;
          const idx = findNearestOreIdx(cx,cy);
          if(idx>=0){
            const o=state.grid[idx];
            const atk = calcAtk();
            const dmg = Math.max(20, Math.round(atk*10));
            o.hp-=dmg;
            if(o.hp<=0){ onOreBroken(idx, o); }
          }
          SFX.skill(); break;
      }
      setCd(key, sk.cd);
      renderSkillBar(); renderGrid(); renderTop();
    }

    function floorHpMul(){ return 1 + 0.18*(state.floor-1); }
    function floorValMul(){ return 1 + 0.12*(state.floor-1); }

    function startRun(){
      if(state.inRun) return;
      state.inRun = true;
      state.etherSpawned=false;
      state.timeLeft = 20;
      state.grid = new Array(25).fill(null);
      for(const o of ORES){ state.loot[o.key]=0; }
      Object.keys(state.skillCooldowns).forEach(k=> delete state.skillCooldowns[k]);
      restartSpawnTimer();
      state.runStartTs = performance.now();
      startTick();
      renderSkillBar();
      gridRectCache = null;
      spawnPets();
      refresh();
    }

    function startTick(){
      clearInterval(state.timers.tick);
      state.timers.tick = setInterval(()=>{
        if(!state.inRun) return;
        const now = performance.now();
        const elapsed = (now - state.runStartTs)/1000;
        let etherDelay = 10 + Math.min(state.floor*0.5, 20) - (state.aether?.etherHaste||0);
        etherDelay = Math.max(5, etherDelay);
        if(!state.etherSpawned && elapsed >= etherDelay){ spawnEther(); }
        state.timeLeft = Math.max(0, +(state.timeLeft - 0.1).toFixed(1));
        for(const k of Object.keys(state.skillCooldowns)){ state.skillCooldowns[k] = Math.max(0, state.skillCooldowns[k]-0.1); }
        if(state.timeLeft<=0){ bankAndExit(false); }
        renderTop(); renderSkillBar();
      },100);
      state.lastAnimTs = performance.now(); requestAnimationFrame(petsFrame);
    }

    function restartSpawnTimer(){
      const baseMs=2200; const level=state.upgrades.spawn.level;
      let interval= baseMs*Math.pow(0.94, level);
      if(state.skillHasteUntil > performance.now()) interval *= 0.5;
      if(interval<600) interval=600;
      clearInterval(state.timers.spawn); state.timers.spawn = setInterval(spawnOre, interval);
    }
    function exitRun(){ if(!state.inRun) return; bankAndExit(false); }

    function bankAndExit(cleared){
      if(state.settings?.autoSell){
        let totalGold = 0;
        for(const k in state.loot){
          const oreDef = ORES.find(o=>o.key===k);
          const n = state.loot[k]||0;
          if(!oreDef || n<=0) continue;
          totalGold += Math.round(n * oreDef.value * sellMultiplier(k));
        }
        if(totalGold>0) state.player.gold += totalGold;
      } else {
        for(const k in state.loot){ state.inventory[k] = (state.inventory[k]||0) + state.loot[k]; }
      }
      for(const k in state.loot){ state.loot[k]=0; }
      state.inRun=false; clearInterval(state.timers.spawn); clearInterval(state.timers.tick);
      state.pets=[]; state.lastAnimTs=0; state.grid = new Array(25).fill(null);
      if(cleared){ state.floor++; if(state.floor>state.highestFloor) state.highestFloor=state.floor; }
      save();
      renderSkillBar();
      gridRectCache = null;
      refresh();
      if(cleared && state.aether?.autoAdvanceOwned && state.aether.autoAdvanceEnabled){
        setTimeout(()=>{ startRun(); }, 250);
      }
    }

    function spawnOre(){
      const empties = state.grid.map((v,i)=> v? null : i).filter(v=>v!==null); if(empties.length===0) return;
      const idx = empties[Math.floor(Math.random()*empties.length)];
      const pool = eligibleOresForFloor(state.floor);
      const base = randWeighted(pool);
      const elapsed = (performance.now() - state.runStartTs)/1000;
      const growth = 1 + 0.02 * Math.max(0, Math.floor(elapsed));
      const hp = Math.round(base.hp*floorHpMul()*growth*(state.skillAtkBuffUntil>performance.now()?0.9:1));
      const value = Math.round(base.value*floorValMul());
      const gr = gridRect();
      const axisX = spawnAxisInfo(gr.width);
      const axisY = spawnAxisInfo(gr.height);
      const x = axisX.start + (axisX.span>0 ? Math.random()*axisX.span : 0);
      const y = axisY.start + (axisY.span>0 ? Math.random()*axisY.span : 0);
      state.grid[idx] = { type: base.key, label: base.name, hp, maxHp: hp, value, bg: base.color, x, y };
      renderGrid();
    }

      function spawnEther(){
        const empties = state.grid.map((v,i)=> v? null : i).filter(v=>v!==null); if(empties.length===0) return;
        const idx = empties[Math.floor(Math.random()*empties.length)]; state.etherSpawned = true;
        const baseE = 1250; const r = 0.06; const exp = Math.max(0, (state.floor-1)*(state.floor-1));
        const hp = Math.round(baseE * Math.pow(1+r, exp));
        const gr = gridRect();
        const axisX = spawnAxisInfo(gr.width);
        const axisY = spawnAxisInfo(gr.height);
        const x = axisX.start + (axisX.span>0 ? Math.random()*axisX.span : 0);
        const y = axisY.start + (axisY.span>0 ? Math.random()*axisY.span : 0);
        state.grid[idx] = { type:'EtherOre', label:'에테르 광석', hp, maxHp: hp, value: 0, bg:'#a855f7', x, y }; renderGrid(); }

    function onOreBroken(idx, ore){
      if(ore.type==='EtherOre'){ state.player.ether += 10; toast('✨ 에테르 +10'); state.grid[idx] = null; SFX.break(); bankAndExit(true); return; }
      state.loot[ore.type] = (state.loot[ore.type]||0)+1;
      state.grid[idx] = null;
      state.timeLeft = Math.min(20, +(state.timeLeft + 0.1).toFixed(1));
      SFX.break();
      renderTop();
    }

    function hit(idx, source='tap'){
      if(!state.inRun) return; const ore = state.grid[idx]; if(!ore) return;
      const atk = calcAtk();
      let dmg = Math.round(atk * (state.skillAtkBuffUntil>performance.now()?2:1));
      const canCrit = (source === 'tap' || source === 'pet');
      const crit = canCrit && Math.random() < state.player.critChance;
      if(crit) dmg = Math.floor(dmg * state.player.critMult);
      ore.hp -= dmg;
      const alive = ore.hp > 0;
      if(!alive){ onOreBroken(idx, ore); renderTop(); }
      renderGrid();
      const cell = state.grid[idx]?.el;
      if(alive && cell){ const dm = document.createElement('div'); dm.classList.add('dmg'); if(crit) dm.classList.add('crit'); dm.textContent = (crit?'CRIT ':'') + '-' + dmg; dm.style.left='50%'; dm.style.top='38%'; dm.style.transform='translateX(-50%)'; cell.appendChild(dm); setTimeout(()=>dm.remove(), 520); }
      (crit?SFX.crit:SFX.hit)();
    }

    function onPointerDown(e){ e.preventDefault(); trackPointer(e, true); }
    function onPointerMove(e){ e.preventDefault(); trackPointer(e, false); }
    function onPointerUp(e){ const ps = state.pointerState[e.pointerId]; if(ps) delete state.pointerState[e.pointerId]; }
    function trackPointer(e, isDown){ const id=e.pointerId||0; const idx = oreIndexFromPoint(e.clientX, e.clientY); const inside = idx>=0; const prev = state.pointerState[id] || { idx:-1, inside:false }; if(isDown){ if(inside){ hit(idx,'tap'); state.pointerState[id]={idx,inside:true}; } else { state.pointerState[id]={idx,inside:false}; } } else { if(prev.idx!==idx){ prev.inside=false; prev.idx=idx; } if(!prev.inside && inside){ hit(idx,'tap'); prev.inside=true; prev.idx=idx; } if(prev.inside && !inside){ prev.inside=false; } state.pointerState[id]=prev; } }

    gridEl.addEventListener('pointerdown', onPointerDown, {passive:false});
    gridEl.addEventListener('pointermove', onPointerMove, {passive:false});
    gridEl.addEventListener('pointerup', onPointerUp, {passive:false});
    gridEl.addEventListener('pointercancel', onPointerUp, {passive:false});

    // Pull-to-refresh guard
    let startY = 0, atTop = false;
    document.addEventListener('touchstart', (e)=>{ startY = e.touches[0].clientY; atTop = (document.scrollingElement?.scrollTop || 0) <= 0; }, {passive:true});
    document.addEventListener('touchmove', (e)=>{ if(atTop){ const dy = e.touches[0].clientY - startY; if(dy > 5) e.preventDefault(); } }, {passive:false});

    function spawnPets(){
      state.pets = [];
      const count = (state.upgrades.pet.level || 0) + (state.passive.petPlus || 0) + (state.aether?.petPlus||0);
      const gr = gridRect();
      const width = Math.max(16, gr.width);
      const height = Math.max(16, gr.height);
      for(let i=0;i<count;i++){ state.pets.push({ x: 8 + Math.random()*(width-16), y: 8 + Math.random()*(height-16), vx:0, vy:0, targetIdx:-1, cd:0 }); }
      renderPets();
    }
    function renderPets(){ gridEl.querySelectorAll('.pet').forEach(p=>p.remove()); gridRect(); for(const p of state.pets){ const el=document.createElement('div'); el.className='pet'; const localX = p.x - 8; const localY = p.y - 8; el.style.transform = `translate(${localX}px, ${localY}px)`; gridEl.appendChild(el); } }
    function findNearestOreIdx(x,y){ let best=-1, bestD=1e9; for(let i=0;i<25;i++){ const ore=state.grid[i]; if(!ore) continue; const d=Math.hypot(ore.x-x, ore.y-y); if(d<bestD){ bestD=d; best=i; } } return best; }
    function petsFrame(ts){ if(!state.inRun) return; const gr=gridRect(); const dt=Math.min(0.05,(ts-state.lastAnimTs)/1000 || 0.016); state.lastAnimTs=ts; for(const p of state.pets){ if(p.targetIdx<0 || !state.grid[p.targetIdx]) p.targetIdx = findNearestOreIdx(p.x,p.y); if(p.targetIdx>=0){ const c=cellCenter(p.targetIdx); const dx=c.x-p.x, dy=c.y-p.y; const dist=Math.hypot(dx,dy)||1; const speed = dist<28 ? PET.moveSpeed*(dist/28) : PET.moveSpeed; const steerX = (dx/dist)*speed - p.vx; const steerY = (dy/dist)*speed - p.vy; p.vx += steerX*0.12; p.vy += steerY*0.12; } else { p.vx += (Math.random()-0.5)*10*dt; p.vy += (Math.random()-0.5)*10*dt; } }
      for(let i=0;i<state.pets.length;i++){
        for(let j=i+1;j<state.pets.length;j++){
          const a=state.pets[i], b=state.pets[j];
          const dx=b.x-a.x, dy=b.y-a.y;
          const d=Math.hypot(dx,dy);
          const r=PET.sepRadius;
          if(d<r){
            const push=(r-(d||0))/r*60;
            let nx, ny;
            if(d>0){
              nx=dx/d; ny=dy/d;
            }else{
              const ang=Math.random()*Math.PI*2;
              nx=Math.cos(ang); ny=Math.sin(ang);
            }
            a.vx -= nx*push; a.vy -= ny*push;
            b.vx += nx*push; b.vy += ny*push;
          }
        }
      }
      for(const p of state.pets){
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.x = Math.max(8, Math.min(gr.width-8, p.x));
        p.y = Math.max(8, Math.min(gr.height-8, p.y));
        if(p.targetIdx>=0){
          const ore = state.grid[p.targetIdx];
          if(!ore){
            p.targetIdx = -1;
            continue;
          }
          const dist = Math.hypot(ore.x - p.x, ore.y - p.y);
          p.cd -= dt;
          if(dist<=PET.atkRange && p.cd<=0){
            p.cd = PET.atkInterval;
            hit(p.targetIdx,'pet');
          }
        }
      }
      renderPets(); requestAnimationFrame(petsFrame); }

    const TAB_IDS = ['dungeon','inventory','upgrades','skills','aether','settings'];
    function activateTab(tabId){
      const target = TAB_IDS.includes(tabId) ? tabId : 'dungeon';
      document.querySelectorAll('.tab-btn').forEach(b=>{
        const active = b.dataset.tab === target;
        b.classList.toggle('active', active);
      });
      TAB_IDS.forEach(id=>{
        const section = document.querySelector('#tab-'+id);
        if(!section) return;
        const active = id === target;
        section.style.display = active ? (id==='dungeon' ? 'flex' : 'block') : 'none';
        section.classList.toggle('active', active);
      });
      screenEl.scrollTop = 0;
      screenEl.style.overflowY = target==='dungeon' ? 'hidden' : 'auto';
      renderTop();
      if(target==='dungeon'){
        renderGrid();
      } else if(target==='skills'){
        renderSkills();
      } else if(target==='aether'){
        renderAether();
      } else if(target==='inventory'){
        renderInventory();
      } else if(target==='settings'){
        detectPlayGamesBridge();
        refreshPlayGamesStatus();
        updatePlayGamesUI();
      }
    }

    document.querySelectorAll('.tab-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        SFX.ui();
        activateTab(btn.dataset.tab);
      })
    });
    $('#toggleRunBtn').addEventListener('click', ()=>{ ensureAudio(); SFX.ui(); startRun(); });
    $('#exitBtn').addEventListener('click', ()=>{
      if(!state.inRun) return;
      SFX.ui();
      bankAndExit(false);
    });
    $('#saveBtn').addEventListener('click', ()=>{ SFX.ui(); save(); });
    $('#resetBtn').addEventListener('click', ()=>{ SFX.ui(); if(confirm('정말 전체 초기화할까요? (세이브 전부 삭제)')){ try{ localStorage.removeItem(SAVE_KEY); }catch(e){} try{ LEGACY_KEYS.forEach(k=>localStorage.removeItem(k)); }catch(e){} location.reload(); } });
    $('#fullscreenBtn').addEventListener('click', ()=>{ SFX.ui(); if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } });
    $('#toggleSoundBtn').addEventListener('click', ()=>{ SFX.ui(); sfxEnabled=!sfxEnabled; $('#toggleSoundBtn').textContent = `효과음: ${sfxEnabled?'켜짐':'꺼짐'}`; });

    if(playGamesLoginBtn){
      playGamesLoginBtn.addEventListener('click', ()=>{
        SFX.ui();
        if(!playGamesState.login){ toast('Android 앱에서만 지원됩니다.'); return; }
        playGamesState.busy = true;
        updatePlayGamesUI();
        try{
          const res = playGamesState.login();
          if(res && typeof res.then === 'function'){
            res.then(val=>{
              if(typeof val !== 'undefined') setPlayGamesState(val);
              else refreshPlayGamesStatus();
            }).catch(err=>{
              console.warn('Play Games 로그인 실패', err);
              playGamesState.busy = false;
              updatePlayGamesUI();
            });
          } else if(typeof res !== 'undefined'){
            setPlayGamesState(res);
          } else {
            setTimeout(()=>{ refreshPlayGamesStatus(); }, 1000);
          }
        }catch(err){
          console.warn('Play Games 로그인 중 오류', err);
          playGamesState.busy = false;
          updatePlayGamesUI();
        }
        setTimeout(()=>{ if(playGamesState.busy) refreshPlayGamesStatus(); }, 1800);
        setTimeout(()=>{ if(playGamesState.busy){ playGamesState.busy = false; updatePlayGamesUI(); } }, 5000);
      });
    }

    // Export / Import for backup/move domains
    document.getElementById('exportBtn').addEventListener('click', ()=>{
      SFX.ui();
      const blob = new Blob([localStorage.getItem(SAVE_KEY)||'{}'], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'miner_save.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('importBtn').addEventListener('click', ()=>{
      SFX.ui();
      const i = document.createElement('input'); i.type='file'; i.accept='application/json';
      i.onchange = async ()=>{ const f=i.files?.[0]; if(!f) return; const text = await f.text();
        try{ JSON.parse(text); localStorage.setItem(SAVE_KEY, text); location.reload(); }
        catch(e){ alert('불러오기 실패: 잘못된 파일'); }
      };
      i.click();
    });

    document.getElementById('autoAdvanceBuyBtn').addEventListener('click', ()=>{
      if(state.aether.autoAdvanceOwned) return;
      if(state.highestFloor < 20) return toast('지하 20층 이상에서 해금 가능합니다.');
      if(state.player.ether < 150) return toast('에테르 부족');
      state.player.ether -= 150;
      state.aether.autoAdvanceOwned = true;
      state.aether.autoAdvanceEnabled = true;
      save(); renderAether(); renderTop(); toast('자동 이동 해금!');
    });
    document.getElementById('autoAdvanceChk').addEventListener('change', (e)=>{
      if(!state.aether.autoAdvanceOwned){ e.target.checked=false; return; }
      state.aether.autoAdvanceEnabled = e.target.checked; save();
    });
    document.getElementById('rebirthBuyBtn').addEventListener('click', ()=>{
      if(state.highestFloor < 20) return;
      let total = 0;
      const chosen = [];
      for(const p of REBIRTH_PERKS){
        if(rebirthPick[p.key]){
          const cost = perkCost(p);
          const lvl = p.getLevel(state);
          if(lvl >= p.max) continue;
          total += cost; chosen.push(p);
        }
      }
      if(total<=0) return;
      if(state.player.ether < total) return toast('에테르 부족');
      if(!confirm('선택한 보너스를 구매하고 환생하시겠습니까?')) return;
      state.player.ether -= total;
      for(const p of chosen){ if(typeof p.apply === 'function') p.apply({ state }); }
      if(state.inRun) bankAndExit(false);
      state.floor = 1; state.aether.rebirths = (state.aether.rebirths||0)+1;
      for(const k in rebirthPick){ delete rebirthPick[k]; }
      save(); renderAether(); renderTop(); toast('보너스 구매 및 환생 완료!');
    });
    document.addEventListener('change', (e)=>{
      const t = e.target;
      if(t && t.matches('input[data-perk]')){
        rebirthPick[t.dataset.perk] = t.checked ? 1 : 0;
        renderAether();
      }
    });

    function boot(){
      load();
      detectPlayGamesBridge();
      updatePlayGamesUI();
      refreshPlayGamesStatus();
      setTimeout(()=>{ if(!playGamesState.available){ detectPlayGamesBridge(); } if(playGamesState.check){ refreshPlayGamesStatus(); } }, 1200);
      renderGrid();
      renderInventory();
      renderUpgrades();
      renderSkills();
      renderAether();
      renderTop();
      renderSkillBar();
    }

    async function init(){
      await loadSpawnTable();
      boot();
      activateTab(document.querySelector('.tab-btn.active')?.dataset.tab || 'dungeon');
    }
    init();

    window.addEventListener('resize', ()=>{
      gridRectCache = null;
      renderGrid();
      if(state.inRun) spawnPets();
    });

    function toast(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',left:'50%',top:'14%',transform:'translateX(-50%)',background:'#11193a',border:'1px solid #263165',padding:'10px 14px',borderRadius:'12px',color:'#eaf2ff',zIndex:9999}); document.body.appendChild(t); setTimeout(()=>t.remove(),1100); }
    function refresh(){ renderTop(); renderGrid(); renderInventory(); renderUpgrades(); }

  })();
  </script>
<script>
// === Dungeon pixel hard-lock: measure once, pin width/height in px (never shrink until reload) ===
(function(){
  const KEY = 'GRID_PIXEL_LOCK';
  const grid = document.getElementById('grid');
  const gridWrap = grid ? grid.parentElement : null;
  const header = document.querySelector('header');
  if (!grid || !gridWrap) return;

  function bodyBG(){
    const c = getComputedStyle(document.body).backgroundColor;
    return (!c || c === 'transparent' || c === 'rgba(0, 0, 0, 0)') ? '#111' : c;
  }
  // Ensure banner/heading area is opaque without changing theme
  try{
    const h = header;
    const ad = document.getElementById('ad-container');
    const bg = bodyBG();
    if (h) h.style.backgroundColor = bg;
    if (ad) ad.style.backgroundColor = bg;
  }catch(e){}

  function measurePX(){
    // Use the visible .grid-wrap box (more stable than viewport values)
    const r = gridWrap.getBoundingClientRect();
    // Leave a small safety padding to avoid accidental overflow
    const pad = 8;
    const s = Math.floor(Math.max(200, Math.min(r.width, r.height) - pad));
    return s;
  }
  function apply(px){
    grid.style.width  = px + 'px';
    grid.style.height = px + 'px';
    grid.style.minWidth  = px + 'px';
    grid.style.minHeight = px + 'px';
    grid.style.maxWidth  = px + 'px';
    grid.style.maxHeight = px + 'px';
  }

  let lock = +(sessionStorage.getItem(KEY) || 0);

  function ensureLock(){
    if (!lock){
      // Two rAF to ensure layouts (ads, sticky header) have settled
      requestAnimationFrame(()=>requestAnimationFrame(()=>{
        lock = measurePX();
        sessionStorage.setItem(KEY, String(lock));
        apply(lock);
      }));
    } else {
      apply(lock);
    }
  }

  // Apply immediately at DOM ready if dungeon is initially visible
  function dungeonVisible(){
    const el = document.getElementById('tab-dungeon');
    return el && el.style.display !== 'none';
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    if (dungeonVisible()){
      ensureLock();
    }
  });

  // On tab click: if switching to dungeon, scroll to top and enforce lock
  document.addEventListener('click', function(e){
    const btn = e.target && e.target.closest && e.target.closest('.tab-btn');
    if (!btn) return;
    const t = btn.getAttribute('data-tab');
    if (t === 'dungeon'){
      try{ document.scrollingElement.scrollTop = 0; }catch(_){}
      const s = document.querySelector('.screen'); if (s) s.scrollTop = 0;
      ensureLock();
    }
  }, true);

  // Ignore resizes (no shrink), but if there was no lock yet and things just became visible, allow first lock
  window.addEventListener('resize', ()=>{
    if (!lock) ensureLock(); else apply(lock);
  }, {passive:true});
})();
</script>
<script>
function openTab(id){
  document.querySelectorAll('.tab').forEach(t=> t.classList.remove('active'));
  const el = (typeof id === 'string') ? document.getElementById(id) : id;
  if (el) el.classList.add('active');
  try{ document.scrollingElement.scrollTop = 0; }catch(e){}
  const s = document.querySelector('.screen'); if (s) s.scrollTop = 0;
  if (el && el.id === 'tab-dungeon' && typeof resizeDungeon === 'function'){
    requestAnimationFrame(()=>requestAnimationFrame(()=> resizeDungeon(true)));
  }
}
</script>
<script>
// --- Dungeon size lock based on viewport (prevents shrink on tab switches) ---
(function(){
  const gridEl = document.getElementById('grid') || document.querySelector('#tab-dungeon .grid') || document.querySelector('#tab-dungeon canvas');
  const tabDungeon = document.getElementById('tab-dungeon');
  function headerH(){
    const h = document.querySelector('header');
    return h ? h.offsetHeight : 0;
  }
  function measure(){
    const vw = window.innerWidth || document.documentElement.clientWidth || 360;
    const vh = window.innerHeight || document.documentElement.clientHeight || 640;
    const availH = Math.max(200, vh - headerH());
    return Math.floor(Math.min(vw, availH));
  }
  let LOCK = 0;
  window.resizeDungeon = function(allowIncreaseOnly){
    if (!tabDungeon) return;
    const size = measure();
    if (allowIncreaseOnly === true){
      if (size > LOCK) LOCK = size;
    } else {
      LOCK = Math.max(LOCK, size);
    }
    const px = LOCK || size;
    const target = gridEl || tabDungeon;
    if (target){
      target.style.width = px + 'px';
      target.style.height = px + 'px';
      target.style.maxWidth = px + 'px';
      target.style.maxHeight = px + 'px';
      target.style.minWidth = px + 'px';
      target.style.minHeight = px + 'px';
      const wrap = target.parentElement;
      if (wrap && getComputedStyle(wrap).display !== 'flex'){
        target.style.marginLeft = 'auto';
        target.style.marginRight = 'auto';
      }
    }
  };
  document.addEventListener('DOMContentLoaded', ()=>{
    const active = tabDungeon && tabDungeon.classList.contains('active');
    requestAnimationFrame(()=>requestAnimationFrame(()=>{
      if (active) resizeDungeon(false);
    }));
  });
  window.addEventListener('resize', ()=> resizeDungeon(true), {passive:true});
})();
</script>

<script>
// --- FIX: openTab toggles .active on real sections (ES5) ---
(function(){
  function showTab(id){
    // normalize id: accepts 'dungeon' or 'tab-dungeon'
    var tid = /^tab-/.test(String(id)) ? String(id) : ('tab-' + String(id));
    var secs = document.querySelectorAll('section[id^="tab-"]');
    for (var i=0;i<secs.length;i++){
      var el = secs[i];
      if (!el || !el.id) continue;
      if (el.id === tid){
        if (!/\bactive\b/.test(el.className)) el.className += ' active';
      } else {
        el.className = el.className.replace(/\bactive\b/g, '').trim();
      }
    }
    // scroll top
    try { document.documentElement.scrollTop = 0; } catch(e){}
    try { document.body.scrollTop = 0; } catch(e){}
  }

  window.openTab = function(id){ showTab(id || 'dungeon'); };

  // Ensure initial state: dungeon active
  function ensureInitial(){
    var dungeon = document.getElementById('tab-dungeon');
    if (dungeon && !/\bactive\b/.test(dungeon.className)) {
      dungeon.className += ' active';
    }
    // hide others
    var secs = document.querySelectorAll('section[id^="tab-"]');
    for (var i=0;i<secs.length;i++){
      var el = secs[i];
      if (el.id !== 'tab-dungeon') {
        el.className = el.className.replace(/\bactive\b/g, '').trim();
      }
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureInitial);
  } else {
    ensureInitial();
  }
})();
</script>

</body>
</html>
