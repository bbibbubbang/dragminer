<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>ë“œë˜ê·¸ ê´‘ì‚°</title>
  <style>
    :root{ --bg:#0f1220;--panel:#161a2e;--accent:#6ee7ff;--accent2:#a78bfa;--text:#eaf2ff;--muted:#9aa3b2;--danger:#ff6b6b;--ok:#22c55e; --bar:#1b2342; --banner-height:60px; }
    *{box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
    html,body{height:100%;margin:0; overscroll-behavior-y: none; overscroll-behavior-x: none;}
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif; background:linear-gradient(180deg, #0b0e1a 0%, #0f1220 100%); color:var(--text);}
    body.lock-v{ overflow:hidden; }
    .app{max-width:520px;margin:0 auto;display:flex;flex-direction:column;min-height:100vh;padding-bottom:16px;}
    .app{min-height:100dvh;padding-bottom:calc(16px + env(safe-area-inset-bottom,0px));}
    header{position:sticky;top:0;z-index:10;background:rgba(15,18,32,0.9);backdrop-filter: blur(6px);border-bottom:1px solid #22263f}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;gap:8px}
    .hud{display:flex;flex-direction:column;gap:2px;min-width:0}
    .hud-line{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
    .btn{appearance:none;border:none;background:var(--accent2);color:#0b0e1a;border-radius:12px;padding:10px 14px;font-weight:700;transition:transform .04s}
    .btn:active{transform:scale(.98)}
    .btn.secondary{background:#243b55;color:#eaf2ff;border:1px solid #2f3a63}
    .btn.danger{background:var(--danger);color:white}
    .btn.ghost{background:#0d132b;color:#cbd5ff;border:1px solid #263165}
    .btn:disabled{opacity:.6}

    .tabs{display:flex;gap:8px;padding:8px 12px;background:#0d1020;border-top:1px solid #22263f}
    .tab-btn{flex:1;border:none;padding:10px 0;border-radius:12px;background:#1a2040;color:#b9c3ff;font-weight:700;transition:transform .04s}
    .tab-btn:active{transform:scale(.98)}
    .tab-btn.active{background:var(--accent);color:#001018}

    .screen{flex:1;display:flex;flex-direction:column;padding:10px 12px;gap:10px;overflow-y:auto}
    .timerbar{height:10px;background:var(--bar);border-radius:999px;overflow:hidden;border:1px solid #283058}
    .timerbar > div{height:100%;background:linear-gradient(90deg, #22c55e, #facc15);width:100%}

    #tab-dungeon{flex:1;display:flex;flex-direction:column;overflow:hidden}
    .grid-wrap{position:relative;flex:1;display:flex;flex-direction:column;min-height:0}
    .grid{position:relative;background:#0e1328;padding:6px;border-radius:16px;border:1px solid #202a51;touch-action: none;flex:1}
    .grid-fx-layer{position:absolute;pointer-events:none;width:0;height:0;z-index:5;transform:translate3d(0,0,0);overflow:visible;}
    .ore{position:absolute;width:52px;height:52px;display:flex;align-items:center;justify-content:center;}
    .ore .name{display:none}
    .ore .hp{z-index:3}
    .hp{position:absolute;top:6px;left:6px;right:6px;height:8px;background:rgba(0,0,0,.35);border-radius:999px;border:1px solid rgba(255,255,255,.08);overflow:hidden}
    .hp>div{height:100%;background:linear-gradient(90deg,#34d399,#f59e0b);width:100%}

    .meteor-effect{position:absolute;width:42px;height:42px;clip-path:polygon(18% 4%,82% 0%,100% 32%,76% 56%,88% 86%,46% 100%,12% 82%,0% 38%);background:radial-gradient(circle at 32% 28%,rgba(255,237,205,.92) 0%,rgba(255,163,120,.9) 38%,rgba(214,59,32,.9) 68%,rgba(94,18,8,.78) 100%);box-shadow:0 0 22px rgba(255,106,64,.68),0 0 46px rgba(219,54,24,.45);transform-origin:center;opacity:.96;transition:transform var(--meteor-travel-duration,0.8s) linear,opacity .28s ease-out;animation:meteor-core-pulse .52s linear infinite alternate;pointer-events:none;mix-blend-mode:screen;z-index:6;}
    .meteor-echo{position:absolute;width:var(--meteor-echo-size,42px);height:var(--meteor-echo-size,42px);clip-path:polygon(50% 4%,95% 38%,78% 96%,22% 96%,5% 38%);background:radial-gradient(circle,rgba(255,72,72,.34) 0%,rgba(145,16,16,.28) 68%,rgba(115,12,12,0) 100%);border:1px solid rgba(255,116,116,.48);border-radius:50%;pointer-events:none;opacity:.55;mix-blend-mode:screen;transform-origin:center;transition:opacity .22s ease-out,transform .22s ease-out;z-index:5;}
    .meteor-effect::before{content:'';position:absolute;inset:-18% 20% -42% 10%;background:linear-gradient(180deg,rgba(255,198,142,.65) 0%,rgba(255,134,76,.35) 55%,rgba(124,28,8,0) 100%);filter:blur(4px);opacity:.85;transform:rotate(-6deg);border-radius:50%;}
    .meteor-effect::after{content:'';position:absolute;inset:14% -48% 12% 28%;background:radial-gradient(circle at 0% 50%,rgba(255,160,120,.85) 0%,rgba(255,118,72,.45) 40%,rgba(255,98,48,0) 75%);filter:blur(2px);opacity:.9;}
    .meteor-effect.fading{opacity:0;}
    @keyframes meteor-core-pulse{from{filter:drop-shadow(0 0 18px rgba(255,124,78,.68));}to{filter:drop-shadow(0 0 26px rgba(255,74,44,.85));}}
    .meteor-trail{position:absolute;height:28px;width:var(--meteor-trail-length,140px);border-radius:999px;background:linear-gradient(90deg,rgba(255,94,44,0) 0%,rgba(255,122,70,.38) 18%,rgba(255,108,58,.7) 52%,rgba(199,46,18,.45) 78%,rgba(120,18,12,0) 100%);filter:blur(1.2px) drop-shadow(0 0 16px rgba(255,104,48,.55));opacity:.78;transform-origin:0% 50%;pointer-events:none;mix-blend-mode:screen;animation:meteor-trail-fade var(--meteor-trail-life,.9s) ease-out forwards;}
    @keyframes meteor-trail-fade{0%{opacity:.6;}40%{opacity:.95;}100%{opacity:0;filter:blur(6px);}}
    .meteor-burst{position:absolute;width:72px;height:72px;border-radius:50%;background:radial-gradient(circle,rgba(255,237,205,.95) 0%,rgba(255,172,120,.65) 45%,rgba(255,106,68,.15) 74%,rgba(255,88,50,0) 100%);transform:translate(-50%,-50%) scale(.6);opacity:.95;animation:meteor-burst .48s ease-out forwards;mix-blend-mode:screen;box-shadow:0 0 28px rgba(255,134,86,.58),0 0 60px rgba(255,90,54,.32);}
    @keyframes meteor-burst{to{transform:translate(-50%,-50%) scale(2.1);opacity:0;filter:blur(16px);}}
    .meteor-flare{position:absolute;width:96px;height:96px;border-radius:50%;background:radial-gradient(circle,rgba(255,204,158,.85) 0%,rgba(255,121,70,.5) 40%,rgba(142,28,12,0) 70%);transform:translate(-50%,-50%) scale(.5);opacity:.9;animation:meteor-flare .52s ease-out forwards;pointer-events:none;mix-blend-mode:screen;}
    @keyframes meteor-flare{to{transform:translate(-50%,-50%) scale(1.9);opacity:0;filter:blur(18px);}}
    .meteor-shockwave{position:absolute;width:78px;height:78px;border:3px solid rgba(255,214,180,.85);border-radius:50%;transform:translate(-50%,-50%) scale(.55);opacity:.85;animation:meteor-shockwave .5s ease-out forwards;pointer-events:none;box-shadow:0 0 24px rgba(255,156,100,.42);}
    @keyframes meteor-shockwave{to{transform:translate(-50%,-50%) scale(2.45);opacity:0;border-width:0;filter:blur(8px);}}
    .meteor-fragment{position:absolute;width:11px;height:11px;border-radius:50%;background:radial-gradient(circle at 28% 32%,rgba(255,236,204,.95) 0%,rgba(255,142,94,.85) 52%,rgba(168,38,18,.8) 100%);box-shadow:0 0 10px rgba(255,118,70,.55);transform:translate(-50%,-50%) scale(.4);opacity:0;animation:meteor-fragment .68s ease-out forwards;mix-blend-mode:screen;}
    .meteor-fragment::after{content:'';position:absolute;inset:22%;border-radius:50%;background:radial-gradient(circle,rgba(255,255,255,.82) 0%,rgba(255,255,255,0) 70%);opacity:.85;}
    @keyframes meteor-fragment{0%{opacity:1;transform:translate(-50%,-50%) scale(.56);}100%{opacity:0;transform:translate(calc(-50% + var(--fx-dx,0px)),calc(-50% + var(--fx-dy,0px))) scale(.24);filter:blur(4px);}}
    .sonic-ring{position:absolute;width:52px;height:52px;border:2px solid rgba(255,255,255,.9);border-radius:50%;box-shadow:0 0 12px rgba(255,255,255,.35);transform:translate(-50%,-50%) scale(.25);opacity:.8;animation:sonic-ring .28s ease-out forwards;}
    @keyframes sonic-ring{to{transform:translate(-50%,-50%) scale(var(--ring-scale,2));opacity:0;}}

    .ore-shape{position:absolute;inset:0;border-radius:16px;--ore-clip:inset(0% round 16px);clip-path:var(--ore-clip);transition:transform .16s ease,filter .16s ease;transform:scale(1);}
    .ore-shape::before,.ore-shape::after{content:'';position:absolute;inset:0;clip-path:var(--ore-clip);pointer-events:none;}
    .ore-shape::before{background:linear-gradient(var(--ore-highlight-angle,135deg),rgba(255,255,255,.5),rgba(255,255,255,0) 60%);mix-blend-mode:screen;opacity:.75;}
    .ore-shape::after{background:linear-gradient(var(--ore-shadow-angle,315deg),rgba(15,23,42,.3),rgba(15,23,42,0) 55%);mix-blend-mode:multiply;opacity:.6;}
    .ore:hover .ore-shape{transform:scale(1.04);}

    .ore-shape.shape-rock{--ore-clip:polygon(14% 8%,83% 2%,100% 42%,82% 94%,20% 100%,2% 58%);--ore-highlight-angle:140deg;--ore-shadow-angle:320deg;filter:saturate(.92);}
    .ore-shape.shape-ingot{--ore-clip:polygon(12% 20%,88% 20%,100% 78%,0% 78%);--ore-highlight-angle:90deg;--ore-shadow-angle:270deg;border-radius:12px;}
    .ore-shape.shape-ingot::before{background:linear-gradient(180deg,rgba(255,255,255,.55) 0%,rgba(255,255,255,.15) 38%,rgba(255,255,255,0) 70%);}
    .ore-shape.shape-ingot::after{background:linear-gradient(180deg,rgba(15,23,42,0) 0%,rgba(15,23,42,.28) 80%);opacity:.55;}
    .ore-shape.shape-gem{--ore-clip:polygon(50% 0%,82% 16%,100% 48%,82% 82%,50% 100%,18% 82%,0% 48%,18% 16%);--ore-highlight-angle:120deg;--ore-shadow-angle:300deg;filter:saturate(1.04);}
    .ore-shape.shape-gem::before{background:
      conic-gradient(from 120deg at 50% 32%,rgba(255,255,255,.6) 0deg,rgba(255,255,255,0) 110deg),
      linear-gradient(140deg,rgba(255,255,255,.45) 0%,rgba(255,255,255,0) 56%),
      linear-gradient(40deg,rgba(255,255,255,.38) 0%,rgba(255,255,255,0) 60%);
      mix-blend-mode:screen;
      opacity:.9;
    }
    .ore-shape.shape-gem::after{background:
      radial-gradient(circle at 30% 68%,rgba(15,23,42,.18) 0%,rgba(15,23,42,0) 54%),
      radial-gradient(circle at 72% 76%,rgba(15,23,42,.32) 0%,rgba(15,23,42,0) 58%),
      linear-gradient(220deg,rgba(15,23,42,.4) 0%,rgba(15,23,42,0) 62%);
      opacity:.68;
    }
    .ore-shape.shape-crystal{--ore-clip:polygon(50% 0%,84% 18%,100% 52%,68% 100%,32% 100%,0% 52%,16% 18%);--ore-highlight-angle:105deg;--ore-shadow-angle:285deg;filter:saturate(1.08);}
    .ore-shape.shape-crystal::before{background:linear-gradient(120deg,rgba(255,255,255,.6) 0%,rgba(255,255,255,0) 45%);opacity:.8;}
    .ore-shape.shape-crystal::after{background:linear-gradient(310deg,rgba(15,23,42,.35) 0%,rgba(15,23,42,0) 60%);opacity:.62;}
    .ore-shape.shape-ether{--ore-clip:polygon(24% 10%,76% 10%,100% 50%,76% 90%,24% 90%,0% 50%);--ore-highlight-angle:90deg;--ore-shadow-angle:270deg;animation:ether-glow 2.4s ease-in-out infinite;}
    @keyframes ether-glow{0%,100%{filter:drop-shadow(0 0 6px rgba(168,85,247,.55));opacity:.95;}50%{filter:drop-shadow(0 0 14px rgba(216,180,254,.85));opacity:1;}}
    .dmg{position:absolute;pointer-events:none;font-weight:900;animation:float .6s ease-out forwards;white-space:nowrap;color:#fdf7d8;-webkit-text-stroke:1.2px rgba(10,14,30,0.85);text-shadow:0 0 6px rgba(10,14,30,0.9),0 0 18px rgba(10,14,30,0.75);letter-spacing:0.5px}
    .dmg.crit{color:#ffd1dc;-webkit-text-stroke:1.2px rgba(64,0,32,0.9);text-shadow:0 0 10px rgba(255,82,115,0.75),0 0 20px rgba(10,14,30,0.8)}
    @keyframes float{to{transform:translateY(-24px);opacity:0}}

    .pet{position:absolute;width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid #0e7490;box-shadow:0 0 10px rgba(34,211,238,.6)}
    .pet::after{content:'ğŸ¾';position:absolute;font-size:12px;left:50%;top:50%;transform:translate(-50%,-55%)}

    .row{display:flex;gap:8px;align-items:center}
    .panel{background:var(--panel);border:1px solid #232844;border-radius:16px;padding:12px}

    .settings-card{background:#0f1430;border:1px solid #273061;border-radius:12px;padding:12px;margin-top:12px}
    .settings-card h4{margin:0 0 4px 0}

    .inventory{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .inv-actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .inv-item{background:#0f1430;border:1px solid #1f2853;border-radius:12px;padding:10px}
    .inv-item h4{margin:0 0 6px 0}
    .price{color:#a3e635;font-weight:800}

    /* Skills */
    .skillshop{display:grid;grid-template-columns:1fr;gap:10px}
    .skill-card{background:#0f1430;border:1px solid #273061;border-radius:12px;padding:10px}
    .skill-card.owned-active,.skill-card.owned-passive{opacity:0.45}
    .skillbar{position:sticky;bottom:0;margin-top:8px;background:#0e1328;border:1px solid #1f2853;border-radius:12px;padding:6px;display:grid;grid-template-columns:repeat(5,1fr);gap:6px}
    @property --skill-ring-angle{syntax:'<angle>';inherits:false;initial-value:0deg}
    @keyframes skill-ring-spin{to{--skill-ring-angle:-360deg}}

    .skillbtn{height:44px;border-radius:10px;border:1px solid #30407a;background:#18224a;color:#dbe7ff;font-weight:800;touch-action:manipulation;position:relative;overflow:hidden}
    .skillbtn.duration-active{border:2px solid transparent;background:
      linear-gradient(#18224a,#18224a) padding-box,
      conic-gradient(from var(--skill-ring-angle), #f97316 0deg, #facc15 72deg, #22d3ee 144deg, #a855f7 216deg, #f472b6 288deg, #f97316 360deg) border-box;
      animation:skill-ring-spin 2.4s linear infinite;
    }
    .skillbtn.cd{position:relative}
    .skillbtn.cd::after{content:'';position:absolute;inset:0;background:rgba(0,0,0,.35);}
    .slotlist{display:grid;grid-template-columns:repeat(5,1fr);gap:6px;margin-top:8px}
    .slot{background:#0c1230;border:1px dashed #27408b;border-radius:10px;min-height:42px;display:flex;align-items:center;justify-content:center;cursor:pointer; font-size:12px; white-space:nowrap}

    /* Aether */
    .aether-grid{display:grid;grid-template-columns:1fr;gap:10px}
    .ae-card{background:#0f1430;border:1px solid #53338f;border-radius:12px;padding:10px}
    .ae-card h4{margin:0 0 6px 0}
    .ae-meta{color:#c4b5fd}
    .ae-balance{display:flex;align-items:center;gap:6px}
    .ae-gain{font-weight:800;color:#93c5fd;opacity:0;transition:opacity .2s ease}
    .ae-gain.show{opacity:1}
    .hud-gain{margin-left:6px;display:inline-block;min-width:0}

    footer{padding:8px 0}
    #ad-container{min-height:var(--banner-height);height:var(--banner-height);display:flex;justify-content:center;align-items:center;width:100%}
  
/* --- Sticky header, stable UI, centered grid --- */
header{ position: sticky; top:0; z-index:3000; }
#ad-container{ width:100%; min-height:var(--banner-height); height:var(--banner-height); display:flex; align-items:center; justify-content:center; }

/* Never allow accidental blur/fade of UI in any viewer */
body, .app, .screen, header, .tabs, .grid-wrap, .grid, button, .btn, .tab-btn{ filter:none !important; opacity:1 !important; }

/* Make grid container center its content; grid itself will be pixel-locked by JS */
.grid-wrap{ position:relative; flex:1; display:flex; flex-direction:column; min-height:0; }
.grid{ margin:0 auto; flex:none; }


/* --- Stable tabs: no display:none to prevent dungeon shrink --- */



/* --- Safer tab visibility (prevent overlap) --- */

/* Keep dungeon laid out even when hidden to avoid shrink on re-show */



/* --- FIX: real tab sections visibility --- */
section[id^="tab-"]{ display:none; }
section[id^="tab-"].active{ display:block; }
#tab-dungeon.active{ display:flex; } /* dungeon keeps flex */

</style>
</head>
<body>
  <div class="app">
    <header>
      <div id="ad-container"><!-- Google AdSense --></div>

      <div class="topbar">
        <div class="hud mono">
          <div class="hud-line" id="hud1">ğŸ’° <span id="hudGold">0</span> Â· âœ¨ <span id="hudEther">0</span><span id="hudAeGain" class="ae-gain hud-gain"></span></div>
          <div class="hud-line" id="hud2">ğŸ—¡ï¸ 1 Â· ğŸ—¼ ì§€í•˜ 1ì¸µ</div>
        </div>
        <div class="row">
          <button id="toggleRunBtn" class="btn">ë˜ì „ ë„ì „</button>
          <button id="exitBtn" class="btn danger" disabled>ë‚˜ê°€ê¸°</button>
        </div>
      </div>
      <div class="timerbar"><div id="timeFill"></div></div>
      <div class="tabs">
        <button class="tab-btn" data-tab="dungeon">â›ï¸ ë˜ì „</button>
        <button class="tab-btn" data-tab="inventory">ğŸ’ ì¸ë²¤í† ë¦¬</button>
        <button class="tab-btn" data-tab="upgrades">ğŸ“ˆ ì—…ê·¸ë ˆì´ë“œ</button>
        <button class="tab-btn" data-tab="skills">ğŸª„ ìŠ¤í‚¬</button>
        <button class="tab-btn" data-tab="aether">ğŸ”® ì—í…Œë¥´</button>
        <button class="tab-btn" data-tab="settings">âš™ï¸ ì„¤ì •</button>
      </div>
    </header>

    <main class="screen">
      <section id="tab-dungeon" class="panel">
        <div class="row" style="justify-content:space-between;margin-bottom:6px">
          <div class="mono" id="timeMono">â³ <span id="timeLeft">--</span>s</div>
        </div>
        <div class="grid-wrap">
          <div id="grid" class="grid"></div>
          <div id="gridFxLayer" class="grid-fx-layer"></div>
          <div id="skillBar" class="skillbar" style="display:none"></div>
        </div>
      </section>

      <section id="tab-inventory" class="panel" >
        <div class="inv-actions">
          <div class="row" style="gap:8px">
            <input type="checkbox" id="autoSellChkInv" style="width:18px;height:18px">
            <label for="autoSellChkInv" class="mono">ê´‘ì„ ìë™íŒë§¤</label>
          </div>
          <button id="sellAllGlobal" class="btn secondary">ëª¨ë“  ê´‘ë¬¼ íŒë§¤</button>
        </div>
        <div class="inventory" id="inventoryList"></div>
      </section>

      <section id="tab-upgrades" class="panel" >
        <div id="upgrades"></div>
      </section>

      <section id="tab-skills" class="panel" >
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div class="row"><span>ì•¡í‹°ë¸Œ ìŠ¬ë¡¯:</span> <b id="slotCount" class="mono">0/5</b></div>
        </div>
        <div class="slotlist" id="slotList"></div>
        <h4 style="margin:10px 0 6px 0">íŒ¨ì‹œë¸Œ ìŠ¤í‚¬ ìƒì </h4>
        <div class="skillshop" id="skillShopPassive"></div>
        <h4 style="margin:14px 0 6px 0">ì•¡í‹°ë¸Œ ìŠ¤í‚¬ ìƒì </h4>
        <div class="skillshop" id="skillShopActive"></div>
      </section>

      <section id="tab-aether" class="panel" >
        <div class="row" style="justify-content:space-between">
          <div class="mono ae-balance">ì—í…Œë¥´: <b id="aeBalance">0</b><span id="aeGainFlash" class="ae-gain"></span></div>
          <div class="mono">í™˜ìƒ: <b id="rebirths">0íšŒ</b></div>
        </div>
        <div class="ae-card">
          <h4>í™˜ìƒ ì¤€ë¹„</h4>
          <div class="ae-meta">ì§€í•˜ 20ì¸µ ì´ìƒì—ì„œ í™˜ìƒ ê°€ëŠ¥. ì•„ë˜ ë³´ë„ˆìŠ¤ë¥¼ ì´ë²ˆ í™˜ìƒì— í•¨ê»˜ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—í…Œë¥´ë¡œ êµ¬ë§¤í•œ ìŠ¤í‚¬ë“¤ì€ í™˜ìƒí•´ë„ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>
          <div id="rebirthPerks" class="aether-grid" style="margin-top:8px"></div>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="mono">ì´ ë¹„ìš©: <b id="rebirthTotal">0</b> ì—í…Œë¥´</div>
            <button id="rebirthBuyBtn" class="btn danger" disabled>ë³´ë„ˆìŠ¤ êµ¬ë§¤ + í™˜ìƒ</button>
          </div>
        </div>
        <div class="ae-card">
          <h4>ìë™ ë„ì „</h4>
          <div class="row" style="justify-content:space-between;flex-wrap:wrap">
            <div class="ae-meta">ë˜ì „ ì¢…ë£Œ ì‹œ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ë„ì „í•©ë‹ˆë‹¤.</div>
            <div class="row">
              <input type="checkbox" id="autoChallengeChk" style="width:18px;height:18px" disabled>
              <label for="autoChallengeChk" class="mono" style="margin-left:6px">í™œì„±í™”</label>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="autoChallengeBuyBtn" class="btn" disabled>ì—í…Œë¥´ 300 ì†Œëª¨ í›„ í•´ê¸ˆ</button>
          </div>
        </div>
      </section>

      <section id="tab-settings" class="panel" >
        <div class="row" style="flex-wrap:wrap;gap:10px">
          <button id="saveBtn" class="btn secondary">ìˆ˜ë™ ì €ì¥</button>
          <button id="exportBtn" class="btn secondary">ë‚´ë³´ë‚´ê¸°</button>
          <button id="importBtn" class="btn secondary">ë¶ˆëŸ¬ì˜¤ê¸°</button>
          <button id="fullscreenBtn" class="btn secondary">ì „ì²´í™”ë©´</button>
          <button id="toggleSoundBtn" class="btn ghost">íš¨ê³¼ìŒ: ì¼œì§</button>
          <button id="resetBtn" class="btn danger">ì´ˆê¸°í™”</button>
        </div>
        <div class="settings-card">
          <h4>í‘œì‹œ ì„¤ì •</h4>
          <div class="row" style="flex-wrap:wrap;gap:10px">
            <button id="toggleDamageBtn" class="btn ghost">ë°ë¯¸ì§€ í‘œì‹œ: ì¼œì§</button>
          </div>
        </div>
        <div class="settings-card" id="playGamesCard">
          <div class="row" style="justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
            <div>
              <h4>Google Play ê²Œì„ì¦ˆ</h4>
              <div class="mono" id="playGamesStatus">ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸ ì¤‘...</div>
            </div>
            <button id="playGamesLoginBtn" class="btn" style="min-width:120px">ë¡œê·¸ì¸</button>
          </div>
          <div class="mono" id="playGamesHelp" style="margin-top:8px;opacity:.72">êµ¬ê¸€ í”Œë ˆì´ ê²Œì„ì¦ˆ ê³„ì •ìœ¼ë¡œ ì—…ì ê³¼ ì €ì¥ì„ ì—°ë™í•©ë‹ˆë‹¤.</div>
        </div>
      </section>
    </main>

    
  </div>
  <script src="data/upgrades.js"></script>
  <script src="data/skills.js"></script>
  <script src="data/aether.js"></script>
  <script>
    (function(){
      function blockEvent(e){
        if (e && typeof e.preventDefault === 'function') e.preventDefault();
      }
      var copyEvents = ['copy', 'cut'];
      for (var i = 0; i < copyEvents.length; i++){
        document.addEventListener(copyEvents[i], blockEvent);
      }
      document.addEventListener('dragstart', blockEvent);
      document.addEventListener('selectstart', function(e){
        var target = e ? e.target : null;
        if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) return;
        blockEvent(e);
      });
    })();
  </script>
  <script>
  (()=>{

    const ORES = [
      { key:'Stone',    name:'ì„ì¬',     color:'#a3a3a3', hp:  60, value: 10,   tier:1, shape:'rock' },
      { key:'Copper',   name:'êµ¬ë¦¬',     color:'#ef9a9a', hp: 120, value: 20,   tier:1, shape:'ingot' },
      { key:'Iron',     name:'ì² ',       color:'#90caf9', hp: 220, value: 40,   tier:2, shape:'ingot' },
      { key:'Silver',   name:'ì€',       color:'#cfd8dc', hp: 380, value: 90,   tier:3, shape:'ingot' },
      { key:'Gold',     name:'ê¸ˆ',       color:'#f6e05e', hp: 650, value: 200,  tier:3, shape:'ingot' },
      { key:'Platinum', name:'ë°±ê¸ˆ',     color:'#e5e7eb', hp: 900, value: 320,  tier:4, shape:'ingot' },
      { key:'Sapphire', name:'ì‚¬íŒŒì´ì–´', color:'#60a5fa', hp:1200, value: 480,  tier:4, shape:'gem' },
      { key:'Ruby',     name:'ë£¨ë¹„',     color:'#f43f5e', hp:1400, value: 600,  tier:5, shape:'gem' },
      { key:'Emerald',  name:'ì—ë©”ë„ë“œ', color:'#34d399', hp:1650, value: 800,  tier:5, shape:'gem' },
      { key:'Mythril',  name:'ë¯¸ìŠ¤ë¦´',   color:'#93c5fd', hp:2200, value:1200, tier:6, shape:'crystal' },
      { key:'Diamond',  name:'ë‹¤ì´ì•„ëª¬ë“œ', color:'#b9f6ff', hp:3000, value:1800, tier:6, shape:'gem' }
    ];
    window.ORE_DATA = ORES;
    const ORE_BY_KEY = new Map(ORES.map(ore=>[ore.key, ore]));
    const ORE_SHINE_START_VALUE = ORE_BY_KEY.get('Silver')?.value ?? Infinity;
    const ORE_MAX_VALUE = Math.max(...ORES.map(o=>o.value||0), 0);

    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function normalizeShine(value){
      if(!Number.isFinite(value) || value <= ORE_SHINE_START_VALUE) return 0;
      if(ORE_MAX_VALUE <= ORE_SHINE_START_VALUE) return 0;
      return clamp01((value - ORE_SHINE_START_VALUE) / (ORE_MAX_VALUE - ORE_SHINE_START_VALUE));
    }
    function hexToRgb(hex){
      if(typeof hex !== 'string') return { r: 255, g: 255, b: 255 };
      let clean = hex.trim().replace('#','');
      if(clean.length === 3){ clean = clean.split('').map(ch=>ch+ch).join(''); }
      const num = parseInt(clean, 16);
      if(!Number.isFinite(num)) return { r: 255, g: 255, b: 255 };
      return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
    }
    function rgbToHex({r,g,b}){
      const toHex = (n)=>{ const clamped = Math.max(0, Math.min(255, Math.round(n))); return clamped.toString(16).padStart(2,'0'); };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    function mixHex(a,b,ratio){
      const t = clamp01(ratio);
      const ca = hexToRgb(a || '#ffffff');
      const cb = hexToRgb(b || '#ffffff');
      return rgbToHex({
        r: ca.r + (cb.r - ca.r) * t,
        g: ca.g + (cb.g - ca.g) * t,
        b: ca.b + (cb.b - ca.b) * t
      });
    }
    function hexToRgba(hex, alpha){
      const { r, g, b } = hexToRgb(hex);
      return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${clamp01(alpha)})`;
    }
    function computeOreVisuals(color, value){
      const shine = normalizeShine(value);
      if(shine <= 0){
        return {
          background: color,
          glow: 'inset 0 1px 0 rgba(255,255,255,0.15), inset 0 -2px 4px rgba(15,23,42,0.45)'
        };
      }
      const highlight = mixHex(color, '#ffffff', 0.45 + 0.25 * shine);
      const midTone = mixHex(color, '#f8fafc', 0.18 + 0.22 * shine);
      const rim = mixHex(color, '#0f172a', 0.35 + 0.25 * shine);
      const accent = mixHex(color, '#e2e8f0', 0.3 + 0.3 * shine);
      const sparkleSize = (18 + 10 * shine).toFixed(1);
      const midStop = (52 + 8 * shine).toFixed(1);
      const baseStop = (78 + 6 * shine).toFixed(1);
      const background = `radial-gradient(circle at 28% 28%, ${highlight} 0%, ${highlight} ${sparkleSize}%, ${midTone} ${midStop}%, ${color} ${baseStop}%, ${rim} 100%)`;
      const outerGlow = `0 0 ${(6 + 10 * shine).toFixed(1)}px ${hexToRgba(accent, 0.25 + 0.2 * shine)}`;
      const innerHighlight = `inset 0 1px 0 rgba(255,255,255,${(0.2 + 0.25 * shine).toFixed(2)})`;
      const innerShade = `inset 0 -3px 6px rgba(15,23,42,${(0.55 - 0.1 * shine).toFixed(2)})`;
      return {
        background,
        glow: `${innerHighlight}, ${innerShade}, ${outerGlow}`
      };
    }
    function applyOreVisuals(ore){
      if(!ore || ore.type === 'EtherOre') return;
      const def = ORE_BY_KEY.get(ore.type);
      if(!def) return;
      const visuals = computeOreVisuals(def.color, def.value);
      ore.bg = visuals.background;
      ore.glow = visuals.glow;
      ore.shape = def.shape || null;
    }
    const ORE_SPAWN_CONFIG = {
      ores: ORES.map(o=>o.key),
      baseline: { Stone:60, Copper:30, Iron:10 },
      introOrder: ['Silver','Gold','Platinum','Sapphire','Ruby','Emerald','Mythril','Diamond']
    };

    function buildIntroMap(cfg){
      const intro = {};
      ['Stone','Copper','Iron'].forEach(name=>{ if(cfg.ores.includes(name)) intro[name] = 1; });
      let step = 1;
      for(const name of cfg.introOrder){
        if(!cfg.ores.includes(name)) continue;
        if(typeof intro[name] === 'number') continue;
        intro[name] = step * 10;
        step++;
      }
      for(const name of cfg.ores){
        if(typeof intro[name] !== 'number') intro[name] = step * 10;
      }
      return intro;
    }

    function orderedByTier(cfg, intro){
      const order = [...cfg.ores];
      return order.sort((a,b)=>{
        const diff = (intro[a] || 0) - (intro[b] || 0);
        if(diff !== 0) return diff;
        return cfg.ores.indexOf(a) - cfg.ores.indexOf(b);
      });
    }

    function cloneInitProb(cfg){
      const result = Object.fromEntries(cfg.ores.map(name=>[name, 0]));
      for(const [name, value] of Object.entries(cfg.baseline || {})){
        if(result.hasOwnProperty(name)) result[name] = value;
      }
      const sum = Object.values(result).reduce((acc,val)=>acc+val,0);
      if(Math.abs(sum - 100) > 1e-9){
        for(const key of Object.keys(result)){
          result[key] = result[key] * 100 / (sum || 1);
        }
      }
      return result;
    }

    function availableBefore(intro, order, floor){
      return order.filter(name => (intro[name] || 0) < floor);
    }

    function availableIncl(intro, order, floor){
      return order.filter(name => (intro[name] || 0) <= floor);
    }

    function round2(val){
      return Math.round(val * 100) / 100;
    }

    function cascadeDeduct(prob, amount, donorsLowToHigh, everZero){
      let remaining = amount;
      const deducted = new Set();
      for(const name of donorsLowToHigh){
        if(remaining <= 0) break;
        const take = Math.min(prob[name] || 0, remaining);
        if(take <= 0) continue;
        prob[name] = round2((prob[name] || 0) - take);
        remaining = round2(remaining - take);
        deducted.add(name);
        if(prob[name] <= 1e-9){
          prob[name] = 0;
          everZero.add(name);
        }
      }
      return { got: round2(amount - remaining), deducted };
    }

    function weightedRedistribute(prob, total, recipsLowToHigh){
      if(total <= 0 || !recipsLowToHigh.length) return { recipients:new Set(), total:0 };
      const K = recipsLowToHigh.length;
      const wsum = K * (K + 1) / 2;
      const shares = recipsLowToHigh.map((_, idx)=> total * (K - idx) / wsum);
      const rounded = shares.map(share => round2(share));
      const roundedSum = rounded.reduce((acc,val)=>acc + val, 0);
      const delta = round2(total - roundedSum);
      if(rounded.length){
        rounded[0] = round2(rounded[0] + delta);
      }
      const recipients = new Set();
      recipsLowToHigh.forEach((name, idx)=>{
        const gain = rounded[idx] || 0;
        if(gain <= 0) return;
        prob[name] = round2((prob[name] || 0) + gain);
        recipients.add(name);
      });
      return { recipients, total: rounded.reduce((acc,val)=>acc+val,0) };
    }

    function getProbabilitiesAtFloor(cfg, floor, luckLevel){
      const intro = buildIntroMap(cfg);
      const order = orderedByTier(cfg, intro);
      const prob = cloneInitProb(cfg);
      const everZero = new Set();
      const DIAMOND = cfg.ores.find(name => /diamond/i.test(name)) || order[order.length - 1];
      const perFloorBase = 1.0;
      const luck = Number.isFinite(luckLevel) ? Math.max(0, Math.floor(luckLevel)) : 0;
      const perFloor = perFloorBase + 0.10 * luck;
      const maxFloor = Math.max(1, Math.floor(floor));
      for(let f=1; f<=maxFloor; f++){
        const recipientsThisFloor = new Set();
        const newOres = order.filter(name => (intro[name] || 0) === f);
        if(f > 1 && newOres.length){
          const donors = availableBefore(intro, order, f).filter(name => !everZero.has(name) && (prob[name] || 0) > 0);
          for(const name of newOres){
            const { got } = cascadeDeduct(prob, 10.0, donors, everZero);
            if(got > 0){
              prob[name] = round2((prob[name] || 0) + got);
              recipientsThisFloor.add(name);
            }
          }
        }
        if(f > 1){
          const donors = availableBefore(intro, order, f).filter(name => !everZero.has(name) && (prob[name] || 0) > 0);
          const donorSum = donors.reduce((acc,name)=> acc + (prob[name] || 0), 0);
          if(donors.length >= 2 && donorSum >= perFloor){
            const { got, deducted } = cascadeDeduct(prob, perFloor, donors, everZero);
            if(got > 0){
              const recips = availableBefore(intro, order, f)
                .filter(name => !everZero.has(name) && !deducted.has(name));
              const { recipients } = weightedRedistribute(prob, got, recips);
              recipients.forEach(name => recipientsThisFloor.add(name));
            }
          }
        }
        let sum = 0;
        for(const name of cfg.ores){
          prob[name] = round2(prob[name] || 0);
          sum += prob[name];
        }
        const delta = round2(100 - sum);
        if(Math.abs(delta) > 1e-9){
          const candidates = order.filter(name => recipientsThisFloor.has(name));
          const eligible = candidates.length ? candidates : availableIncl(intro, order, f).filter(name => !everZero.has(name));
          const target = eligible.length ? eligible[0] : DIAMOND;
          prob[target] = round2((prob[target] || 0) + delta);
          if(prob[target] <= 1e-9){
            prob[target] = 0;
            everZero.add(target);
          }
        }
        if((prob[DIAMOND] || 0) >= 100) break;
      }
      return prob;
    }

    const ORE_PROB_CACHE = new Map();
    function getCachedProbabilities(floor, luckLevel){
      const key = `${Math.max(1, Math.floor(floor || 1))}|${Math.max(0, Math.floor(luckLevel || 0))}`;
      if(!ORE_PROB_CACHE.has(key)){
        ORE_PROB_CACHE.set(key, getProbabilitiesAtFloor(ORE_SPAWN_CONFIG, Math.max(1, Math.floor(floor || 1)), Math.max(0, Math.floor(luckLevel || 0))));
      }
      const stored = ORE_PROB_CACHE.get(key) || {};
      return { ...stored };
    }
    const ACTIVE_SKILLS = window.ACTIVE_SKILL_DATA;
    const BERSERK_SKILL = ACTIVE_SKILLS.find(s=>s.key==='berserk');
    const PASSIVE_SKILLS = window.PASSIVE_SKILL_DATA;
    const PASSIVE_DISPLAY_INFO = {
      power: { label:'ê¸°ì´ˆê³µê²©ë ¥', unit:'', perLevel:1 },
      sharp: {
        label:'ì¹˜ëª…íƒ€ í™•ë¥ ',
        unit:'%',
        calcTotal: (level) => Math.min(40, level * 3),
        calcDelta: (level) => {
          const current = Math.min(40, level * 3);
          const next = Math.min(40, (level + 1) * 3);
          return Math.max(0, next - current);
        },
      },
      merchant: { label:'íŒë§¤ ë³´ë„ˆìŠ¤', unit:'%', perLevel:10 },
      petmaster: {
        label:'í«',
        unit:'ë§ˆë¦¬',
        perLevel:1,
        formatDelta: (value) => {
          const num = Number.isFinite(value) ? value : 0;
          return Number.isInteger(num) ? num.toString() : num.toFixed(2).replace(/\.0+$/,'').replace(/0+$/,'');
        },
      },
    };
    const REBIRTH_PERKS = window.REBIRTH_PERK_DATA;
    const UPGRADE_INFO = window.UPGRADE_INFO;
    const UPGRADE_DEFAULTS = window.UPGRADE_DEFAULTS;
    const UPGRADE_CONFIG = window.UPGRADE_CONFIG;
    const getUpgradeLevel = window.getUpgradeLevel;
    const computePetBehaviorStats = window.computePetBehaviorStats;
    const computeRefineryMultiplier = window.computeRefineryMultiplier;
    const ETHER_SPAWN_SETTINGS = window.ETHER_SPAWN_SETTINGS || {
      baseDelay: 15,
      reductionPerLevel: 0.5,
      maxLevel: 10,
    };
    const computeEtherSpawnReduction = typeof window.computeEtherSpawnReduction === 'function'
      ? window.computeEtherSpawnReduction
      : (level = 0) => {
          const rawLevel = Math.max(0, Math.floor(level || 0));
          const cap = Number.isFinite(ETHER_SPAWN_SETTINGS.maxLevel)
            ? ETHER_SPAWN_SETTINGS.maxLevel
            : rawLevel;
          const per = Number.isFinite(ETHER_SPAWN_SETTINGS.reductionPerLevel)
            ? ETHER_SPAWN_SETTINGS.reductionPerLevel
            : 0.5;
          const clamped = Number.isFinite(cap) ? Math.min(rawLevel, cap) : rawLevel;
          return clamped * per;
        };
    const ETHER_SPAWN_BASE_DELAY = Number.isFinite(ETHER_SPAWN_SETTINGS.baseDelay)
      ? ETHER_SPAWN_SETTINGS.baseDelay
      : 15;

    function getEtherLocatorLevel(state){
      if(typeof getUpgradeLevel === 'function'){
        return getUpgradeLevel(state, 'etherLocator');
      }
      const entry = state?.upgrades?.etherLocator;
      if(entry && typeof entry.level === 'number' && Number.isFinite(entry.level)){
        return Math.max(0, Math.floor(entry.level));
      }
      return 0;
    }

    function computeEtherSpawnDelay(perkLevel = 0, upgradeLevel = 0){
      const perkReduction = computeEtherSpawnReduction(perkLevel);
      const upgradeReduction = computeEtherSpawnReduction(upgradeLevel);
      const totalReduction = Math.min(ETHER_SPAWN_BASE_DELAY, perkReduction + upgradeReduction);
      return Math.max(0, ETHER_SPAWN_BASE_DELAY - totalReduction);
    }
    const VERSION = 'miner_v2.6.1';
    // ê³ ì • ì„¸ì´ë¸Œí‚¤ + êµ¬ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜
    const SAVE_KEY = 'miner_save_v1';
    const LEGACY_KEYS = Object.keys(localStorage).filter(k=>/^miner_v/.test(k));

    // ---------- Audio ----------
    let audioCtx = null, audioResumePromise = null, sfxEnabled = true;
    const AUDIO_UNLOCK_EVENTS = ['pointerdown','touchstart','mousedown','keydown'];
    const AUDIO_UNLOCK_OPTS = { passive:true };
    let audioUnlockBound = false;
    function ensureAudio(){
      if(!audioCtx){
        const Ctor = window.AudioContext || window.webkitAudioContext;
        if(!Ctor) return null;
        audioCtx = new Ctor();
      }
      if(audioCtx?.state === 'suspended' && audioCtx.resume){
        if(!audioResumePromise){
          audioResumePromise = audioCtx.resume().catch(err=>{
            console.warn('AudioContext resume failed', err);
          }).finally(()=>{ audioResumePromise = null; });
          if(audioResumePromise?.then){
            audioResumePromise.then(()=>{
              if(audioCtx?.state === 'running') removeAudioUnlockListeners();
            }).catch(()=>{});
          }
        }
      }
      if(audioCtx?.state === 'running'){
        removeAudioUnlockListeners();
      }
      return audioCtx;
    }
    function addAudioUnlockListeners(){
      if(audioUnlockBound) return;
      audioUnlockBound = true;
      AUDIO_UNLOCK_EVENTS.forEach(evt=>{
        document.addEventListener(evt, handleAudioUnlock, AUDIO_UNLOCK_OPTS);
      });
    }
    function removeAudioUnlockListeners(){
      if(!audioUnlockBound) return;
      audioUnlockBound = false;
      AUDIO_UNLOCK_EVENTS.forEach(evt=>{
        document.removeEventListener(evt, handleAudioUnlock, AUDIO_UNLOCK_OPTS);
      });
    }
    function handleAudioUnlock(){
      if(!ensureAudio()) return;
      if(audioCtx?.state === 'running'){
        removeAudioUnlockListeners();
      }
    }
    addAudioUnlockListeners();
    function beep(freq=600, dur=0.06, type='square', gain=0.03){
      if(!sfxEnabled) return;
      const ctx = ensureAudio();
      if(!ctx) return;
      const t = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(ctx.destination);
      o.start(t);
      o.stop(t+dur);
    }
    const HIT_SOUNDS = [
      'sounds/impactMetal_heavy_000.ogg',
      'sounds/impactMetal_heavy_001.ogg',
      'sounds/impactMetal_heavy_002.ogg',
      'sounds/impactMetal_heavy_003.ogg',
      'sounds/impactMetal_heavy_004.ogg'
    ];
    let hitSoundBuffers = [];
    let hitSoundPromise = null;
    function decodeAudio(arrayBuffer){
      if(!audioCtx) return Promise.resolve(null);
      if(typeof audioCtx.decodeAudioData !== 'function') return Promise.resolve(null);
      if(audioCtx.decodeAudioData.length === 1){
        try{
          return audioCtx.decodeAudioData(arrayBuffer);
        }catch(err){
          return Promise.reject(err);
        }
      }
      return new Promise((resolve, reject)=>{
        try{
          audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
        }catch(err){ reject(err); }
      });
    }
    function loadHitSounds(){
      if(hitSoundBuffers.length) return Promise.resolve(hitSoundBuffers);
      if(hitSoundPromise) return hitSoundPromise;
      ensureAudio();
      hitSoundPromise = Promise.all(HIT_SOUNDS.map(async (url)=>{
        try{
          const resp = await fetch(url);
          if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
          const buf = await resp.arrayBuffer();
          return await decodeAudio(buf);
        }catch(err){
          console.warn('Failed to load ore hit sound', url, err);
          return null;
        }
      })).then(results=>{
        hitSoundBuffers = results.filter(Boolean);
        return hitSoundBuffers;
      }).catch(err=>{
        console.warn('Ore hit sound load failed', err);
        return [];
      });
      return hitSoundPromise;
    }
    function playBuffer(buffer, gainValue=0.6){
      const ctx = ensureAudio();
      if(!buffer || !ctx) return;
      const source = ctx.createBufferSource();
      const gain = ctx.createGain();
      gain.gain.value = gainValue;
      source.buffer = buffer;
      source.connect(gain);
      gain.connect(ctx.destination);
      try{ source.start(); }
      catch(err){ console.warn('Failed to start buffer', err); }
    }
    async function playOreHit(volume=0.65){
      if(!sfxEnabled) return false;
      ensureAudio();
      try{
        const buffers = await loadHitSounds();
        if(buffers && buffers.length){
          const buffer = buffers[Math.floor(Math.random()*buffers.length)];
          playBuffer(buffer, volume);
          return true;
        }
      }catch(err){
        console.warn('Ore hit playback failed', err);
      }
      return false;
    }
    const SFX = {
      async hit(){
        const played = await playOreHit(0.7);
        if(!played) beep(520,0.03,'square',0.035);
      },
      async crit(){
        const played = await playOreHit(0.75);
        if(!played) beep(900,0.05,'square',0.045);
      },
      break(){},
      skill(){ beep(700,0.08,'triangle',0.05); },
      deny(){ beep(180,0.12,'square',0.04); },
      ui(){ beep(430,0.05,'triangle',0.035); }
    };

    const MAX_RUN_TIME = 20;

    // ---------- Game State ----------
    const state = {
      player: { atkBase: 10, atk: 10, critChanceBase: 0.10, critChance: 0.10, critMult: 2.0, gold: 0, ether: 0 },
      upgrades: (()=>{
        const defaults = {};
        for(const [key, def] of Object.entries(UPGRADE_DEFAULTS||{})){
          if(def && typeof def === 'object' && !Array.isArray(def)) defaults[key] = { ...def };
        }
        defaults.oreMul = {};
        return defaults;
      })(),
      aether: { luck:0, petPlus:0, etherHaste:0, rebirths:0, autoChallengeOwned:false, autoChallengeEnabled:false },

      floor: 1,
      highestFloor: 1,
      inventory: {},
      oreSales: {},
      loot: {},
      grid: new Array(25).fill(null),
      inRun:false,
      timeLeft: 0.0,
      timers: { spawn:null, tick:null },
      animFrameId: 0,
      pets: [],
      pointerState: {},
      lastAnimTs: 0,
      runStartTs: 0,
      etherSpawned: false,

      // Skills
      skillsOwnedActive: {},
      skillsOwnedPassive: {},
      skillSlots: [null,null,null,null,null],
      skillCooldowns: {},
      skillAuto: {},
      skillHasteUntil: 0,
      skillAtkBuffUntil: 0,

      currentSpawnIntervalMs: 0,

      // Passive bonuses
      passive: { sellBonus: 0, petPlus: 0, berserkUnlimit:false },

      // Run-time flags
      runFlags: { berserkBoostActive:false, berserkBoostPrevExpiry:null, hasteActive:false },

      // Settings
      settings: { autoSell:false, showDamageNumbers:true, sfxEnabled:true },

      lastTickReal: 0,
      visibilityPauseTs: 0,
    };

    const AUTO_CHALLENGE_COST = 300;

    function ensurePassiveDefaults(){
      state.passive = state.passive || {};
      if(typeof state.passive.sellBonus !== 'number') state.passive.sellBonus = 0;
      if(typeof state.passive.petPlus !== 'number') state.passive.petPlus = 0;
      if(typeof state.passive.berserkUnlimit !== 'boolean') state.passive.berserkUnlimit = false;
    }

    function ensureSkillAutoDefaults(){
      if(!state.skillAuto || typeof state.skillAuto !== 'object' || Array.isArray(state.skillAuto)){
        state.skillAuto = {};
      }
      for(const sk of ACTIVE_SKILLS){
        if(sk.autoToggleKey && typeof state.skillAuto[sk.autoToggleKey] !== 'boolean'){
          state.skillAuto[sk.autoToggleKey] = false;
        }
      }
    }

    function ensureSettingsDefaults(){
      if(!state.settings || typeof state.settings !== 'object' || Array.isArray(state.settings)){
        state.settings = { autoSell:false, showDamageNumbers:true, sfxEnabled:true };
        return;
      }
      if(typeof state.settings.autoSell !== 'boolean') state.settings.autoSell = false;
      if(typeof state.settings.showDamageNumbers !== 'boolean') state.settings.showDamageNumbers = true;
      if(typeof state.settings.sfxEnabled !== 'boolean') state.settings.sfxEnabled = true;
    }

    function resetRunFlags(){
      state.runFlags = state.runFlags || {};
      state.runFlags.berserkBoostActive = false;
      state.runFlags.berserkBoostPrevExpiry = null;
      state.runFlags.hasteActive = false;
    }

    function clampRunTime(value){
      if(!Number.isFinite(value)) return 0;
      return Math.max(0, Math.min(MAX_RUN_TIME, Math.round(value * 10) / 10));
    }

    function setRunTime(value){
      state.timeLeft = clampRunTime(value);
    }

    function addRunTime(amount){
      setRunTime(state.timeLeft + amount);
    }

    function reduceRunTime(amount){
      setRunTime(state.timeLeft - amount);
    }

    ensurePassiveDefaults();
    ensureSkillAutoDefaults();
    ensureSettingsDefaults();
    resetRunFlags();

    state.currentSpawnIntervalMs = (() => {
      const level = getUpgradeLevel(state, 'spawn');
      if(typeof window.spawnIntervalForLevel === 'function'){
        return window.spawnIntervalForLevel(level);
      }
      return Math.max(600, 2200 * Math.pow(0.94, level));
    })();

    // ---------- Save/Load (stable key + migration) ----------
    function save(){
      const { atk, ...player } = state.player;
      const { critChance, ...restPlayer } = player;
      const payload = {
        __version: VERSION,
        player: restPlayer,
        upgrades:state.upgrades, floor:state.floor, highestFloor:state.highestFloor,
        inventory:state.inventory, oreSales:state.oreSales, skillsOwnedActive:state.skillsOwnedActive, skillsOwnedPassive:state.skillsOwnedPassive,
        skillSlots:state.skillSlots, passive:state.passive, aether:state.aether, settings:state.settings, skillAuto:state.skillAuto
      };
      try{ localStorage.setItem(SAVE_KEY, JSON.stringify(payload)); }catch(e){ console.warn('save failed', e); }
    }
    function load(){
      let raw = localStorage.getItem(SAVE_KEY);
      if(!raw){
        for(const k of LEGACY_KEYS){
          raw = localStorage.getItem(k);
          if(raw){ try{ localStorage.setItem(SAVE_KEY, raw); }catch(e){} break; }
        }
      }
      if(!raw) return;
      try{
        const s = JSON.parse(raw);
        Object.assign(state.player,s.player||{});
        delete state.player.atk;
        const savedUpgrades = s.upgrades || {};
        if(savedUpgrades.oreMul && typeof savedUpgrades.oreMul === 'object'){
          state.upgrades.oreMul = { ...state.upgrades.oreMul, ...savedUpgrades.oreMul };
        }
        for(const [key, def] of Object.entries(UPGRADE_DEFAULTS || {})){
          const saved = savedUpgrades[key];
          const lvl = typeof saved === 'number' ? saved
            : (saved && typeof saved.level === 'number' ? saved.level : def.level || 0);
          const normalized = Math.max(0, lvl);
          const clamped = typeof clampUpgradeLevelToConfig === 'function'
            ? clampUpgradeLevelToConfig(key, normalized)
            : normalized;
          state.upgrades[key] = { level: clamped };
        }
        state.floor=s.floor||1; state.highestFloor=s.highestFloor||1;
        state.inventory=s.inventory||state.inventory;
        state.oreSales = s.oreSales || state.oreSales;
        state.skillsOwnedActive=s.skillsOwnedActive||{};
        state.skillsOwnedPassive=s.skillsOwnedPassive||{};
        state.skillSlots=s.skillSlots||[null,null,null,null,null];
        state.passive=s.passive||state.passive;
        state.aether = s.aether || state.aether;
        state.skillAuto = s.skillAuto || state.skillAuto || {};
        if(state.aether){
          if(typeof state.aether.autoChallengeOwned !== 'boolean'){
            state.aether.autoChallengeOwned = !!state.aether.autoAdvanceOwned;
          }
          if(typeof state.aether.autoChallengeEnabled !== 'boolean'){
            state.aether.autoChallengeEnabled = !!state.aether.autoAdvanceEnabled;
          }
          delete state.aether.autoAdvanceOwned;
          delete state.aether.autoAdvanceEnabled;
        }
        state.settings = s.settings || state.settings;
        ensureSettingsDefaults();
        sfxEnabled = state.settings.sfxEnabled !== false;
        ensurePassiveDefaults();
        ensureSkillAutoDefaults();
        resetRunFlags();
        if(typeof state.player.atkBase === 'undefined'){
          state.player.atkBase = (typeof s.player?.atk === 'number') ? s.player.atk : 10;
        }
        if(typeof state.player.critChanceBase !== 'number'){
          const savedCrit = typeof s.player?.critChance === 'number' ? s.player.critChance : state.player.critChance;
          const critCfg = UPGRADE_CONFIG?.crit;
          const perLevel = critCfg?.effectPerLevel || 0;
          const critLvl = state.upgrades?.crit?.level || 0;
          const estimatedBase = typeof savedCrit === 'number' ? savedCrit - (perLevel * critLvl) : undefined;
          const base = (typeof estimatedBase === 'number' && !Number.isNaN(estimatedBase)) ? estimatedBase : 0.10;
          state.player.critChanceBase = Math.max(0.01, +base.toFixed(4));
        }
        applyPetBehaviorUpgrade();
      }catch(e){ console.warn('load failed', e); }
    }

    // ---------- Skills ----------
    // ë°ì´í„°ëŠ” data/skills.jsì—ì„œ ë¡œë“œë©ë‹ˆë‹¤.

    // ---------- Rebirth-only Aether ----------
    // ë°ì´í„°ëŠ” data/aether.jsì—ì„œ ë¡œë“œë©ë‹ˆë‹¤.
    function toFiniteNumber(value, fallback=0){
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    }

    function calcLinearCost(base, stepRate, level){
      const safeBase = Math.max(0, toFiniteNumber(base, 0));
      const safeRate = Math.max(0, toFiniteNumber(stepRate, 0));
      const safeLevel = Math.max(0, toFiniteNumber(level, 0));
      const multiplier = 1 + (safeRate * safeLevel);
      return Math.floor(safeBase * multiplier);
    }

    function rollOverCritTier(chance, baseMultiplier){
      const safeChance = Number.isFinite(chance) ? chance : 0;
      const safeBaseMult = Number.isFinite(baseMultiplier) ? baseMultiplier : 2;
      let remaining = Math.max(0, safeChance);
      let tier = 0;

      while(remaining > 0){
        const chunk = Math.min(remaining, 1);
        if(chunk >= 0.999999){
          tier += 1;
          remaining = Math.max(0, remaining - 1);
          continue;
        }
        if(Math.random() < chunk){
          tier += 1;
          remaining = Math.max(0, remaining - chunk);
        } else {
          break;
        }
      }

      if(tier <= 0) return { tier: 0, multiplier: 1 };
      const multiplier = safeBaseMult + Math.max(0, tier - 1);
      return { tier, multiplier };
    }

    const REBIRTH_COST_GROWTH = 1.2;

    function perkCost(p){
      if(!p) return 0;
      const level = Math.max(0, typeof p.getLevel === 'function' ? toFiniteNumber(p.getLevel(state), 0) : 0);
      const base = Math.max(0, toFiniteNumber(p.base, 0));
      const multiplier = Math.pow(REBIRTH_COST_GROWTH, level);
      return Math.floor(base * multiplier);
    }
    const rebirthPick = {}; // {key:1}

    // ---------- Ores ----------
    // ë°ì´í„°ëŠ” data/probabilities.jsì—ì„œ ë¡œë“œë©ë‹ˆë‹¤.

    for(const o of ORES){
      state.inventory[o.key]=state.inventory[o.key]||0;
      state.loot[o.key]=0;
      state.oreSales[o.key]=state.oreSales[o.key]||0;
      const initialLevel = Math.max(0, Math.floor((state.oreSales[o.key]||0) / 10));
      state.upgrades.oreMul[o.key]=initialLevel;
    }

    const PET_BASE = window.PET_BEHAVIOR_BASE || {};
    const PET = {
      moveSpeed: Number.isFinite(PET_BASE.moveSpeed) ? PET_BASE.moveSpeed : 180,
      atkInterval: Number.isFinite(PET_BASE.atkInterval) ? PET_BASE.atkInterval : 0.5,
      sepRadius: 24,
      atkRange: 18,
      swingDuration: 0.24,
      swingArc: Math.PI * 0.85,
      swingRadius: Number.isFinite(PET_BASE.swingRadius) ? PET_BASE.swingRadius : 28,
    };

    const BASE_PET_STYLE = {
      bg: '#22d3ee',
      border: '#0e7490',
      glow: 'rgba(34,211,238,0.6)',
      damageMul: 1,
    };

    const SPECIAL_PET_STYLES = [
      { bg:'#ef4444', border:'#b91c1c', glow:'rgba(248,113,113,0.8)' },
      { bg:'#f97316', border:'#c2410c', glow:'rgba(251,146,60,0.8)' },
      { bg:'#facc15', border:'#a16207', glow:'rgba(250,204,21,0.75)' },
      { bg:'#22c55e', border:'#15803d', glow:'rgba(34,197,94,0.75)' },
      { bg:'#3b82f6', border:'#1d4ed8', glow:'rgba(59,130,246,0.75)' },
      { bg:'#4338ca', border:'#312e81', glow:'rgba(99,102,241,0.8)' },
      { bg:'#a855f7', border:'#7c3aed', glow:'rgba(168,85,247,0.82)' },
    ];

    const $ = sel => document.querySelector(sel);
    const gridEl = $('#grid');
    const gridWrapEl = document.querySelector('#tab-dungeon .grid-wrap');
    const gridFxLayerEl = $('#gridFxLayer');
    const skillBarEl = $('#skillBar');
    const screenEl = $('.screen');
    const aeGainFlashEl = $('#aeGainFlash');
    const hudGoldEl = $('#hudGold');
    const hudEtherEl = $('#hudEther');
    const hudAeGainEl = $('#hudAeGain');
    let aeGainFlashTimer = null;
    let hudAeGainTimer = null;
    let gridRectCache = null;
    let lastGridRectValid = null;
    let gridSafeMargin = { x: 6, y: 6 };

    const ORE_SIZE = 52;
    const ORE_RADIUS = ORE_SIZE / 2;
    const PET_SIZE = 16;
    const PET_RADIUS = PET_SIZE / 2;
    const GRID_SAFE_MARGIN = 6;

    function applyPetBehaviorUpgrade(){
      const rawLevel = getUpgradeLevel(state, 'petAi');
      const level = typeof clampPetBehaviorLevel === 'function'
        ? clampPetBehaviorLevel(rawLevel)
        : rawLevel;
      let stats = null;
      if(typeof computePetBehaviorStats === 'function'){
        try {
          stats = computePetBehaviorStats(level);
        }catch(err){
          console.warn('Failed to compute pet behavior stats', err);
        }
      }
      const base = window.PET_BEHAVIOR_BASE || {};
      const fallback = {
        moveSpeed: Math.min(320, (Number.isFinite(base.moveSpeed) ? base.moveSpeed : 180) + 12 * Math.max(0, level)),
        atkInterval: Math.max(0.24, (Number.isFinite(base.atkInterval) ? base.atkInterval : 0.5) - 0.015 * Math.max(0, level)),
        swingRadius: Math.min(42, (Number.isFinite(base.swingRadius) ? base.swingRadius : 28) + 1.4 * Math.max(0, level)),
      };
      const next = stats || fallback;
      if(Number.isFinite(next.moveSpeed)) PET.moveSpeed = next.moveSpeed;
      if(Number.isFinite(next.atkInterval)) PET.atkInterval = next.atkInterval;
      if(Number.isFinite(next.swingRadius)) PET.swingRadius = next.swingRadius;
      const baseRadius = Math.max(ORE_RADIUS + 12, PET.swingRadius * 0.9);
      const defaultContact = Math.max(ORE_RADIUS + 2, PET.swingRadius * 0.75);
      for(const pet of state.pets){
        if(!pet) continue;
        const scale = Number.isFinite(pet.radiusScale) ? pet.radiusScale : 1;
        const maxRadius = baseRadius * Math.max(0.6, Math.min(1.4, scale));
        pet.maxRadius = maxRadius;
        pet.contactRadius = Math.max(ORE_RADIUS + 2, Math.min(maxRadius - 1, defaultContact));
        pet.orbitSpeed = Math.max(0.3, (PET.moveSpeed / Math.max(ORE_RADIUS + 8, PET.swingRadius)) * 0.55);
        const prevFollow = Number.isFinite(pet.followStrength) ? pet.followStrength : 0;
        const followTarget = Math.max(prevFollow, PET.moveSpeed / 24);
        pet.followStrength = Math.max(3, followTarget);
      }
    }

    window.applyPetBehaviorUpgrade = applyPetBehaviorUpgrade;

    applyPetBehaviorUpgrade();

    function parseCssPx(v){
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : 0;
    }

    function computeGridSafeMargins(){
      if(!gridEl) return gridSafeMargin;
      try{
        const style = window.getComputedStyle(gridEl);
        const padLeft = parseCssPx(style.paddingLeft);
        const padRight = parseCssPx(style.paddingRight);
        const padTop = parseCssPx(style.paddingTop);
        const padBottom = parseCssPx(style.paddingBottom);
        const borderLeft = parseCssPx(style.borderLeftWidth);
        const borderRight = parseCssPx(style.borderRightWidth);
        const borderTop = parseCssPx(style.borderTopWidth);
        const borderBottom = parseCssPx(style.borderBottomWidth);
        const radiusTL = parseCssPx(style.borderTopLeftRadius);
        const radiusTR = parseCssPx(style.borderTopRightRadius);
        const radiusBL = parseCssPx(style.borderBottomLeftRadius);
        const radiusBR = parseCssPx(style.borderBottomRightRadius);
        const safeX = Math.max(
          GRID_SAFE_MARGIN,
          padLeft + borderLeft,
          padRight + borderRight,
          radiusTL + borderLeft,
          radiusTR + borderRight,
          radiusBL + borderLeft,
          radiusBR + borderRight,
          radiusTL,
          radiusTR,
          radiusBL,
          radiusBR
        );
        const safeY = Math.max(
          GRID_SAFE_MARGIN,
          padTop + borderTop,
          padBottom + borderBottom,
          radiusTL + borderTop,
          radiusTR + borderTop,
          radiusBL + borderBottom,
          radiusBR + borderBottom,
          radiusTL,
          radiusTR,
          radiusBL,
          radiusBR
        );
        gridSafeMargin = { x: safeX, y: safeY };
      }catch(e){ gridSafeMargin = { x: GRID_SAFE_MARGIN, y: GRID_SAFE_MARGIN }; }
      return gridSafeMargin;
    }

    function currentGridMargins(){
      if(gridRectCache && Number.isFinite(gridRectCache.marginX) && Number.isFinite(gridRectCache.marginY)){
        return { x: gridRectCache.marginX, y: gridRectCache.marginY };
      }
      return computeGridSafeMargins();
    }

    function clamp(value, min, max){
      if(value < min) return min;
      if(value > max) return max;
      return value;
    }

    function normalizeAngle(angle){
      if(!Number.isFinite(angle)) return 0;
      let a = angle;
      while(a > Math.PI) a -= Math.PI * 2;
      while(a <= -Math.PI) a += Math.PI * 2;
      return a;
    }

    function spawnAxisInfo(size, desiredMargin = GRID_SAFE_MARGIN, entitySize = ORE_SIZE){
      const actual = Math.max(0, size || 0);
      const desired = Math.max(0, Number.isFinite(desiredMargin) ? desiredMargin : GRID_SAFE_MARGIN);
      const objectSize = Math.max(0, Number.isFinite(entitySize) ? entitySize : ORE_SIZE);
      const radius = objectSize / 2;
      const available = Math.max(0, actual - objectSize);
      const margin = Math.min(desired, available / 2);
      const minCenter = radius + margin;
      const maxCenter = Math.max(minCenter, actual - (radius + margin));
      const span = Math.max(0, maxCenter - minCenter);
      return { start: minCenter, span, min: minCenter, max: maxCenter, size: actual, margin, radius, objectSize };
    }

    function clampAxisValue(val, axis){
      if(!axis) return val;
      const min = Number.isFinite(axis.min) ? axis.min : Number.isFinite(axis.start) ? axis.start : 0;
      const maxRaw = Number.isFinite(axis.max) ? axis.max : (Number.isFinite(axis.start) ? axis.start : 0) + Math.max(0, Number.isFinite(axis.span) ? axis.span : 0);
      const max = Math.max(min, maxRaw);
      if(!Number.isFinite(val)) return min;
      if(max <= min) return min;
      return Math.min(max, Math.max(min, val));
    }

    function clampOreToGrid(ore, axisX, axisY){
      if(!ore) return;
      ore.x = clampAxisValue(ore.x, axisX);
      ore.y = clampAxisValue(ore.y, axisY);
      const gridWidth = axisX?.size ?? gridRectCache?.innerWidth ?? gridRectCache?.width ?? lastGridRectValid?.innerWidth ?? lastGridRectValid?.width ?? ORE_SIZE;
      const gridHeight = axisY?.size ?? gridRectCache?.innerHeight ?? gridRectCache?.height ?? lastGridRectValid?.innerHeight ?? lastGridRectValid?.height ?? ORE_SIZE;
      const availableX = Math.max(0, gridWidth - ORE_SIZE);
      const availableY = Math.max(0, gridHeight - ORE_SIZE);
      const marginX = Number.isFinite(axisX?.margin) ? axisX.margin : Math.min(GRID_SAFE_MARGIN, availableX / 2);
      const marginY = Number.isFinite(axisY?.margin) ? axisY.margin : Math.min(GRID_SAFE_MARGIN, availableY / 2);
      const minCenterX = ORE_RADIUS + marginX;
      const maxCenterX = Math.max(minCenterX, gridWidth - (ORE_RADIUS + marginX));
      const minCenterY = ORE_RADIUS + marginY;
      const maxCenterY = Math.max(minCenterY, gridHeight - (ORE_RADIUS + marginY));
      ore.x = Math.min(Math.max(ore.x, minCenterX), maxCenterX);
      ore.y = Math.min(Math.max(ore.y, minCenterY), maxCenterY);
    }

    function clampPetToGrid(pet, axisX, axisY){
      if(!pet) return;
      const gridWidth = axisX?.size ?? gridRectCache?.innerWidth ?? gridRectCache?.width ?? lastGridRectValid?.innerWidth ?? lastGridRectValid?.width ?? PET_SIZE;
      const gridHeight = axisY?.size ?? gridRectCache?.innerHeight ?? gridRectCache?.height ?? lastGridRectValid?.innerHeight ?? lastGridRectValid?.height ?? PET_SIZE;
      const marginX = Number.isFinite(axisX?.margin) ? axisX.margin : Math.min(GRID_SAFE_MARGIN, Math.max(0, (gridWidth - PET_SIZE) / 2));
      const marginY = Number.isFinite(axisY?.margin) ? axisY.margin : Math.min(GRID_SAFE_MARGIN, Math.max(0, (gridHeight - PET_SIZE) / 2));
      const minCenterX = Number.isFinite(axisX?.min) ? axisX.min : PET_RADIUS + marginX;
      const maxCenterX = Number.isFinite(axisX?.max) ? axisX.max : Math.max(minCenterX, gridWidth - (PET_RADIUS + marginX));
      const minCenterY = Number.isFinite(axisY?.min) ? axisY.min : PET_RADIUS + marginY;
      const maxCenterY = Number.isFinite(axisY?.max) ? axisY.max : Math.max(minCenterY, gridHeight - (PET_RADIUS + marginY));
      const safeX = Number.isFinite(pet.x) ? pet.x : minCenterX;
      const safeY = Number.isFinite(pet.y) ? pet.y : minCenterY;
      pet.x = Math.min(Math.max(safeX, minCenterX), maxCenterX);
      pet.y = Math.min(Math.max(safeY, minCenterY), maxCenterY);
    }

    const playGamesCardEl = document.getElementById('playGamesCard');
    const playGamesStatusEl = document.getElementById('playGamesStatus');
    const playGamesLoginBtn = document.getElementById('playGamesLoginBtn');
    const playGamesHelpEl = document.getElementById('playGamesHelp');

    const playGamesState = {
      available:false,
      signedIn:false,
      busy:false,
      canLogin:false,
      initialized:false,
      playerName:'',
      check:null,
      login:null,
      bridge:null
    };

    function parsePlayGamesBool(v){
      if(typeof v === 'boolean') return v;
      if(typeof v === 'number') return v !== 0;
      if(typeof v === 'string'){
        const norm = v.trim().toLowerCase();
        if(!norm) return false;
        if(['true','1','yes','y','signed_in','connected','ok','success','logged_in','login','signedin'].includes(norm)) return true;
        if(['false','0','no','n','signed_out','disconnected','fail','failed','error','logged_out','logout','signedout','not_signed_in','not signed in','not_signedin'].includes(norm)) return false;
        if(norm.includes('required') || norm.includes('sign_out') || norm.includes('signed_out') || norm.includes('logout')) return false;
        if((norm.includes('signed_in') || norm.includes('sign_in')) && !norm.includes('required')) return true;
      }
      return !!v;
    }

    function parsePlayGamesPayload(payload){
      if(typeof payload === 'string'){
        const parts = payload.split(/[|,:]/).map(s=>s.trim()).filter(Boolean);
        if(parts.length>1){
          return { signedIn: parsePlayGamesBool(parts[0]), name: parts.slice(1).join(' ') };
        }
        return { signedIn: parsePlayGamesBool(payload) };
      }
      if(typeof payload === 'object' && payload){
        const keys = ['signedIn','isSignedIn','loggedIn','isLoggedIn','success','status','state'];
        let signed;
        for(const k of keys){
          if(Object.prototype.hasOwnProperty.call(payload,k)){
            signed = payload[k];
            break;
          }
        }
        if(typeof signed === 'string'){
          const lower = signed.trim().toLowerCase();
          if(lower){
            if(lower.includes('required') || lower.includes('fail') || lower.includes('error') || lower.includes('denied') || lower.includes('sign_out') || lower.includes('signed_out') || lower.includes('logout')) signed = false;
            else if(lower.includes('signed_in') || lower.includes('sign_in') || lower.includes('connected') || lower.includes('success') || lower.includes('authorized') || lower.includes('granted') || lower === 'ok') signed = true;
          }
        }
        const name = payload.displayName || payload.playerName || payload.name || payload.nickname;
        return { signedIn: typeof signed === 'undefined' ? undefined : parsePlayGamesBool(signed), name: name? String(name) : undefined };
      }
      if(typeof payload === 'undefined') return { signedIn: undefined };
      return { signedIn: parsePlayGamesBool(payload) };
    }

    function updatePlayGamesUI(){
      if(!playGamesCardEl) return;
      if(playGamesStatusEl){
        if(!playGamesState.available){
          playGamesStatusEl.textContent = 'Android ì•±ì—ì„œë§Œ ì§€ì›ë©ë‹ˆë‹¤.';
        } else if(!playGamesState.initialized){
          playGamesStatusEl.textContent = 'ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸ ì¤‘...';
        } else if(playGamesState.signedIn){
          playGamesStatusEl.textContent = playGamesState.playerName ? `ë¡œê·¸ì¸ë¨ (${playGamesState.playerName})` : 'ë¡œê·¸ì¸ë¨';
        } else {
          playGamesStatusEl.textContent = playGamesState.busy ? 'ë¡œê·¸ì¸ ì¤‘...' : 'ë¡œê·¸ì¸ í•„ìš”';
        }
      }
      if(playGamesHelpEl){
        if(!playGamesState.available){
          playGamesHelpEl.textContent = 'Android WebView ì•±ì—ì„œ í”Œë ˆì´ ê²Œì„ì¦ˆ ì—°ë™ ì‹œ í‘œì‹œë©ë‹ˆë‹¤.';
        } else if(playGamesState.signedIn){
          playGamesHelpEl.textContent = 'í”Œë ˆì´ ê²Œì„ì¦ˆì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.';
        } else if(playGamesState.canLogin){
          playGamesHelpEl.textContent = 'êµ¬ê¸€ í”Œë ˆì´ ê²Œì„ì¦ˆ ê³„ì •ìœ¼ë¡œ ì—…ì ê³¼ ì €ì¥ì„ ì—°ë™í•©ë‹ˆë‹¤.';
        } else {
          playGamesHelpEl.textContent = 'ë¡œê·¸ì¸ì€ ì•±ì—ì„œë§Œ ì§€ì›ë©ë‹ˆë‹¤.';
        }
      }
      if(playGamesLoginBtn){
        const showBtn = playGamesState.available && playGamesState.canLogin && playGamesState.initialized && !playGamesState.signedIn;
        playGamesLoginBtn.style.display = showBtn ? 'inline-flex' : 'none';
        playGamesLoginBtn.disabled = playGamesState.busy;
        playGamesLoginBtn.textContent = playGamesState.busy ? 'ë¡œê·¸ì¸ ì¤‘...' : 'ë¡œê·¸ì¸';
      }
    }

    function setPlayGamesState(payload){
      const parsed = parsePlayGamesPayload(payload);
      playGamesState.available = true;
      playGamesState.initialized = true;
      if(typeof parsed.signedIn !== 'undefined'){
        playGamesState.signedIn = !!parsed.signedIn;
        if(!playGamesState.signedIn && !parsed.name) playGamesState.playerName = '';
      }
      if(parsed.name){
        playGamesState.playerName = parsed.name;
      } else if(!playGamesState.signedIn){
        playGamesState.playerName = '';
      }
      playGamesState.busy = false;
      updatePlayGamesUI();
    }

    function detectPlayGamesBridge(){
      const candidates = [
        window.PlayGames,
        window.playGames,
        window.Android && window.Android.PlayGames,
        window.Android
      ].filter(Boolean);
      for(const cand of candidates){
        if(!cand) continue;
        const checkNames = ['isPlayGamesSignedIn','isPlayGamesLoggedIn','playGamesIsSignedIn','getPlayGamesLoginState','getPlayGamesSignedIn','fetchPlayGamesLoginState','isSignedIn','isSignedInPlayGames'];
        let check = null;
        for(const name of checkNames){
          if(typeof cand[name] === 'function'){ check = cand[name].bind(cand); break; }
          if(typeof cand[name] !== 'undefined'){ check = ()=> cand[name]; break; }
        }
        const loginNames = ['signInPlayGames','signInToPlayGames','playGamesSignIn','startPlayGamesLogin','loginPlayGames','loginToPlayGames','playGamesLogin','requestPlayGamesSignIn','triggerPlayGamesLogin'];
        let login = null;
        for(const name of loginNames){
          if(typeof cand[name] === 'function'){ login = cand[name].bind(cand); break; }
        }
        if(check || login){
          playGamesState.bridge = cand;
          playGamesState.check = check;
          playGamesState.login = login;
          playGamesState.canLogin = !!login;
          if(!check && login && !playGamesState.initialized){
            playGamesState.initialized = true;
            playGamesState.signedIn = false;
          }
          playGamesState.available = true;
          updatePlayGamesUI();
          return true;
        }
      }
      if(!playGamesState.available){
        playGamesState.check = null;
        playGamesState.login = null;
        playGamesState.canLogin = false;
      }
      updatePlayGamesUI();
      return false;
    }

    function refreshPlayGamesStatus(){
      if(!playGamesState.check){ updatePlayGamesUI(); return; }
      try{
        const res = playGamesState.check();
        if(res && typeof res.then === 'function'){
          res.then(val=>{ setPlayGamesState(val); }).catch(err=>{ console.warn('Play Games ìƒíƒœ í™•ì¸ ì‹¤íŒ¨', err); });
        } else if(typeof res !== 'undefined'){
          setPlayGamesState(res);
        }
      }catch(err){ console.warn('Play Games ìƒíƒœ í™•ì¸ ì¤‘ ì˜¤ë¥˜', err); }
    }

    window.__setPlayGamesLoginState = setPlayGamesState;
    window.__playGamesLoginState = setPlayGamesState;
    window.onPlayGamesLoginState = setPlayGamesState;
    window.PlayGamesLoginState = setPlayGamesState;
    window.updatePlayGamesLoginState = setPlayGamesState;
    window.requestPlayGamesStatus = refreshPlayGamesStatus;

    function randWeighted(items){ const total = items.reduce((a,b)=>a+b.weight,0); let r = Math.random()*total; for(const it of items){ if((r-=it.weight) <= 0) return it; } return items[0]; }
    function defaultOrePool(){ return ORES.map(o=>({ ...o, weight: 1 })); }
    function eligibleOresForFloor(f){
      const floor = Math.max(1, Math.floor(f));
      const luckLevel = state.aether?.luck || 0;
      const distribution = getCachedProbabilities(floor, luckLevel);
      const pool = [];
      for(const ore of ORES){
        const chance = Math.max(0, distribution[ore.key] || 0);
        if(!(chance > 0)) continue;
        const weight = Math.max(1, Math.round(chance * 100));
        pool.push({ ...ore, weight });
      }
      return pool.length ? pool : defaultOrePool();
    }
    function gridRect(){
      const r = gridEl.getBoundingClientRect();
      const innerWidth = Math.max(0, gridEl ? (gridEl.clientWidth || 0) : (r.width || 0));
      const innerHeight = Math.max(0, gridEl ? (gridEl.clientHeight || 0) : (r.height || 0));
      const hasSize = innerWidth > 0 && innerHeight > 0;
      if(hasSize){
        const newMargins = computeGridSafeMargins();
        if(gridRectCache){
          const prevInnerWidth = Number.isFinite(gridRectCache.innerWidth) ? gridRectCache.innerWidth : (gridRectCache.width || 0);
          const prevInnerHeight = Number.isFinite(gridRectCache.innerHeight) ? gridRectCache.innerHeight : (gridRectCache.height || 0);
          const widthChanged = Math.abs(prevInnerWidth - innerWidth) > 0.5 || Math.abs((gridRectCache.width || 0) - (r.width || 0)) > 0.5;
          const heightChanged = Math.abs(prevInnerHeight - innerHeight) > 0.5 || Math.abs((gridRectCache.height || 0) - (r.height || 0)) > 0.5;
          if(widthChanged || heightChanged){
            const prev = gridRectCache;
            const prevMarginX = Number.isFinite(prev.marginX) ? prev.marginX : newMargins.x;
            const prevMarginY = Number.isFinite(prev.marginY) ? prev.marginY : newMargins.y;
            const oldAxisX = spawnAxisInfo(prevInnerWidth, prevMarginX);
            const oldAxisY = spawnAxisInfo(prevInnerHeight, prevMarginY);
            const newAxisX = spawnAxisInfo(innerWidth, newMargins.x);
            const newAxisY = spawnAxisInfo(innerHeight, newMargins.y);
            const oldInnerW = Math.max(1, oldAxisX.span || 0);
            const oldInnerH = Math.max(1, oldAxisY.span || 0);
            for(let i=0;i<state.grid.length;i++){
              const ore = state.grid[i];
              if(!ore) continue;
              const nx = Math.max(0, Math.min(1, (ore.x - oldAxisX.start) / oldInnerW));
              const ny = Math.max(0, Math.min(1, (ore.y - oldAxisY.start) / oldInnerH));
              ore.x = newAxisX.start + nx * (newAxisX.span || 0);
              ore.y = newAxisY.start + ny * (newAxisY.span || 0);
              clampOreToGrid(ore, newAxisX, newAxisY);
            }
            const oldPetAxisX = spawnAxisInfo(prevInnerWidth, prevMarginX, PET_SIZE);
            const oldPetAxisY = spawnAxisInfo(prevInnerHeight, prevMarginY, PET_SIZE);
            const newPetAxisX = spawnAxisInfo(innerWidth, newMargins.x, PET_SIZE);
            const newPetAxisY = spawnAxisInfo(innerHeight, newMargins.y, PET_SIZE);
            for(const pet of state.pets){
              const oldSpanX = oldPetAxisX.span || 0;
              const oldSpanY = oldPetAxisY.span || 0;
              const nx = oldSpanX > 0 ? Math.max(0, Math.min(1, (pet.x - oldPetAxisX.start) / oldSpanX)) : 0.5;
              const ny = oldSpanY > 0 ? Math.max(0, Math.min(1, (pet.y - oldPetAxisY.start) / oldSpanY)) : 0.5;
              const newSpanX = newPetAxisX.span || 0;
              const newSpanY = newPetAxisY.span || 0;
              pet.x = newPetAxisX.start + Math.max(0, Math.min(1, nx)) * newSpanX;
              pet.y = newPetAxisY.start + Math.max(0, Math.min(1, ny)) * newSpanY;
              clampPetToGrid(pet, newPetAxisX, newPetAxisY);
            }
          }
        }
        gridRectCache = {
          left:r.left,
          top:r.top,
          width:r.width,
          height:r.height,
          right:r.right,
          bottom:r.bottom,
          innerWidth,
          innerHeight,
          marginX:newMargins.x,
          marginY:newMargins.y
        };
        lastGridRectValid = gridRectCache;
        return gridRectCache;
      }
      if(lastGridRectValid){
        gridRectCache = lastGridRectValid;
        if(Number.isFinite(gridRectCache.marginX) && Number.isFinite(gridRectCache.marginY)){
          gridSafeMargin = { x: gridRectCache.marginX, y: gridRectCache.marginY };
        }
        return gridRectCache;
      }
      if(gridRectCache){
        if(Number.isFinite(gridRectCache.marginX) && Number.isFinite(gridRectCache.marginY)){
          gridSafeMargin = { x: gridRectCache.marginX, y: gridRectCache.marginY };
        }
        return gridRectCache;
      }
      const fallbackMargins = computeGridSafeMargins();
      gridRectCache = {
        left:r.left,
        top:r.top,
        width:ORE_SIZE,
        height:ORE_SIZE,
        right:r.left + ORE_SIZE,
        bottom:r.top + ORE_SIZE,
        innerWidth:ORE_SIZE,
        innerHeight:ORE_SIZE,
        marginX:fallbackMargins.x,
        marginY:fallbackMargins.y
      };
      return gridRectCache;
    }
    function cellCenter(idx){ const o = state.grid[idx]; return { x:o.x, y:o.y }; }
    function oreIndexFromPoint(x,y){ const gr = gridRect(); const localX = x - gr.left; const localY = y - gr.top; if(localX<0 || localY<0 || localX>gr.width || localY>gr.height) return -1; for(let i=0;i<25;i++){ const o=state.grid[i]; if(!o) continue; const h=ORE_RADIUS; if(localX>=o.x-h && localX<=o.x+h && localY>=o.y-h && localY<=o.y+h) return i; } return -1; }

    function oreLevel(key){
      if(!key) return 0;
      const sold = state.oreSales?.[key] || 0;
      const level = Math.max(0, Math.floor(sold / 10));
      if(state.upgrades?.oreMul){
        state.upgrades.oreMul[key] = level;
      }
      return level;
    }

    function levelMultiplier(level){
      const oreLevel = Math.max(0, level);
      const upgradeLevel = getUpgradeLevel(state, 'refinery');
      if(typeof computeRefineryMultiplier === 'function'){
        try{
          return computeRefineryMultiplier(upgradeLevel, oreLevel);
        }catch(err){
          console.warn('Failed to compute refinery multiplier', err);
        }
      }
      const perLevel = 0.01 + 0.0025 * upgradeLevel;
      const flat = 1 + 0.01 * upgradeLevel;
      return (1 + oreLevel * perLevel) * flat;
    }

    function formatMultiplier(mult){
      const str = mult.toFixed(2);
      const num = parseFloat(str);
      return Number.isFinite(num) ? num.toString() : str;
    }

    function sellMultiplier(key){
      const lvl = oreLevel(key);
      const upgMul = levelMultiplier(lvl);
      const passiveMul = 1 + (state.passive.sellBonus||0);
      return upgMul * passiveMul;
    }

    function processOreSale(key, amount, baseValue){
      if(!key || amount<=0 || !Number.isFinite(baseValue)) return 0;
      const oreInfo = ORE_BY_KEY.get(key);
      const passiveMul = 1 + (state.passive.sellBonus||0);
      let sold = state.oreSales[key]||0;
      let remaining = amount;
      let gold = 0;
      while(remaining>0){
        const currentLevel = Math.max(0, Math.floor(sold / 10));
        const lvlMul = levelMultiplier(currentLevel);
        gold += baseValue * lvlMul * passiveMul;
        sold += 1;
        remaining -= 1;
      }
      state.oreSales[key] = sold;
      const level = Math.max(0, Math.floor(sold / 10));
      state.upgrades.oreMul[key] = level;
      return Math.round(gold);
    }

    function calcCritChance(){
      const cfg = UPGRADE_CONFIG?.crit;
      const base = (typeof state.player.critChanceBase === 'number') ? state.player.critChanceBase : 0.10;
      const lvl = getUpgradeLevel(state, 'crit');
      const perLevel = cfg?.effectPerLevel || 0.02;
      const totalRaw = base + (perLevel * lvl);
      const total = Math.max(0, +totalRaw.toFixed(4));
      state.player.critChance = total;
      return total;
    }

    function calcAtk() {
      const L = Math.max(0, getUpgradeLevel(state, 'atk'));
      const powerPassive = PASSIVE_SKILLS.find((sk) => sk.key === 'power');
      const maxPowerLevel = powerPassive ? passiveMaxLevel(powerPassive) : 0;
      const ownedPower = Math.min(maxPowerLevel, state.skillsOwnedPassive?.power || 0);
      const baseFloor = 10 + ownedPower;
      const storedBase = (typeof state.player.atkBase === 'number') ? state.player.atkBase : 10;
      const base = Math.max(storedBase, baseFloor);
      state.player.atkBase = base;
      const fallbackMultiplier = () => {
        const perLevel = 0.12;
        const milestoneBonus = 0.35;
        const milestoneStep = 10;
        const per = Math.pow(1 + perLevel, Math.max(0, L));
        const bonus = Math.pow(1 + milestoneBonus, Math.floor(Math.max(0, L) / milestoneStep));
        return per * bonus;
      };
      const multiplier = typeof window.computeAtkMultiplier === 'function'
        ? window.computeAtkMultiplier(L)
        : fallbackMultiplier();
      const atk = Math.max(1, Math.ceil(base * multiplier));
      state.player.atk = atk;
      calcCritChance();
      return atk;
    }

    function fmtFloor(n){ return `ì§€í•˜ ${n}ì¸µ`; }
    function renderHud(){
      calcAtk();
      if(hudGoldEl){ hudGoldEl.textContent = state.player.gold; }
      if(hudEtherEl){ hudEtherEl.textContent = state.player.ether; }
      $('#hud2').textContent = `ğŸ—¡ï¸ ${state.player.atk} Â· ğŸ—¼ ${fmtFloor(state.floor)}`;
    }
    function renderTop(){
      renderHud();
      $('#timeLeft').textContent = state.inRun? state.timeLeft.toFixed(1) : '--';
      $('#exitBtn').disabled = !state.inRun;
      $('#toggleRunBtn').textContent = state.inRun? 'ì§„í–‰ ì¤‘' : 'ë˜ì „ ë„ì „';
      $('#toggleRunBtn').disabled = state.inRun;
      const fill = state.inRun? Math.max(0, Math.min(1, state.timeLeft / MAX_RUN_TIME)) : 1;
      document.getElementById('timeFill').style.width = (fill*100)+'%';
      const isDungeonVisible = document.querySelector('#tab-dungeon').style.display !== 'none';
      document.body.classList.toggle('lock-v', isDungeonVisible);
    }

    function syncFxLayerBounds(){
      if(!gridFxLayerEl || !gridWrapEl || !gridEl) return;
      const gridBox = gridEl.getBoundingClientRect();
      const wrapBox = gridWrapEl.getBoundingClientRect();
      if(!gridBox || !wrapBox) return;
      const width = Math.max(0, gridBox.width);
      const height = Math.max(0, gridBox.height);
      gridFxLayerEl.style.width = width + 'px';
      gridFxLayerEl.style.height = height + 'px';
      gridFxLayerEl.style.left = (gridBox.left - wrapBox.left) + 'px';
      gridFxLayerEl.style.top = (gridBox.top - wrapBox.top) + 'px';
    }

    function spawnMeteorFragments(cx, cy, count){
      if(!gridFxLayerEl) return;
      const pieces = Math.max(4, Math.floor(count));
      for(let i=0;i<pieces;i++){
        const frag = document.createElement('div');
        frag.className = 'meteor-fragment';
        frag.style.left = cx + 'px';
        frag.style.top = cy + 'px';
        const angle = Math.random() * Math.PI * 2;
        const distance = 40 + Math.random() * 44;
        frag.style.setProperty('--fx-dx', `${Math.cos(angle) * distance}px`);
        frag.style.setProperty('--fx-dy', `${Math.sin(angle) * distance}px`);
        gridFxLayerEl.appendChild(frag);
        setTimeout(()=>frag.remove(), 640);
      }
    }

    function triggerMeteorImpact(cx, cy, onImpact){
      if(gridFxLayerEl){
        const burst = document.createElement('div');
        burst.className = 'meteor-burst';
        burst.style.left = cx + 'px';
        burst.style.top = cy + 'px';
        gridFxLayerEl.appendChild(burst);
        const flare = document.createElement('div');
        flare.className = 'meteor-flare';
        flare.style.left = cx + 'px';
        flare.style.top = cy + 'px';
        gridFxLayerEl.appendChild(flare);
        const shockwave = document.createElement('div');
        shockwave.className = 'meteor-shockwave';
        shockwave.style.left = cx + 'px';
        shockwave.style.top = cy + 'px';
        gridFxLayerEl.appendChild(shockwave);
        setTimeout(()=>burst.remove(), 520);
        setTimeout(()=>flare.remove(), 560);
        setTimeout(()=>shockwave.remove(), 520);
        spawnMeteorFragments(cx, cy, 16);
      }
      if(typeof onImpact === 'function'){
        onImpact();
      }
    }

    function spawnMeteorEcho(x, y, size, meteorEl){
      if(!gridFxLayerEl) return;
      const echo = document.createElement('div');
      echo.className = 'meteor-echo';
      echo.style.left = x + 'px';
      echo.style.top = y + 'px';
      if(Number.isFinite(size)){
        echo.style.setProperty('--meteor-echo-size', `${size}px`);
      }
      const rotation = (Math.random() * 360) - 180;
      echo.style.transform = `translate(-50%, -50%) rotate(${rotation}deg) scale(1)`;
      if(meteorEl && meteorEl.parentNode === gridFxLayerEl){
        gridFxLayerEl.insertBefore(echo, meteorEl);
      } else {
        gridFxLayerEl.appendChild(echo);
      }
      requestAnimationFrame(()=>{
        requestAnimationFrame(()=>{
          echo.style.opacity = '0';
          echo.style.transform = `translate(-50%, -50%) rotate(${rotation}deg) scale(0.72)`;
        });
      });
      setTimeout(()=>echo.remove(), 260);
    }

    function spawnMeteorSkillEffect(onImpact){
      if(!gridFxLayerEl || !gridEl){
        if(typeof onImpact === 'function') onImpact();
        return;
      }
      syncFxLayerBounds();
      const gr = gridRect();
      const width = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
      const height = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
      const startX = Math.max(gridSafeMargin.x + 8, ORE_RADIUS * 0.6);
      const startY = Math.max(gridSafeMargin.y + 8, ORE_RADIUS * 0.6);
      const centerX = width / 2;
      const centerY = height / 2;
      const meteor = document.createElement('div');
      meteor.className = 'meteor-effect';
      const size = 42;
      const half = size / 2;
      const dx = centerX - startX;
      const dy = centerY - startY;
      const distance = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx);
      const travelSpeed = 420;
      const travelDuration = Math.max(0.35, distance / travelSpeed);
      meteor.style.setProperty('--meteor-travel-duration', `${travelDuration}s`);
      meteor.style.transform = `translate(${startX - half}px, ${startY - half}px) rotate(${angle}rad) scale(0.45)`;
      gridFxLayerEl.appendChild(meteor);
      spawnMeteorEcho(startX, startY, size, meteor);
      let impacted = false;
      const travelMs = travelDuration * 1000;
      const echoInterval = 80;
      let echoRaf = null;
      let echoStartTime = null;
      let lastEchoAt = -Infinity;
      const runEcho = (now) => {
        if(impacted) return;
        if(echoStartTime === null){
          echoStartTime = now;
        }
        const elapsed = now - echoStartTime;
        const progress = Math.min(1, elapsed / travelMs);
        if(elapsed - lastEchoAt >= echoInterval){
          const echoX = startX + dx * progress;
          const echoY = startY + dy * progress;
          spawnMeteorEcho(echoX, echoY, size, meteor);
          lastEchoAt = elapsed;
        }
        if(progress < 1){
          echoRaf = requestAnimationFrame(runEcho);
        }
      };
      const impactNow = () => {
        if(impacted) return;
        impacted = true;
        if(echoRaf !== null){
          cancelAnimationFrame(echoRaf);
          echoRaf = null;
        }
        spawnMeteorEcho(centerX, centerY, size, meteor);
        meteor.classList.add('fading');
        triggerMeteorImpact(centerX, centerY, onImpact);
        setTimeout(()=>meteor.remove(), 360);
      };
      requestAnimationFrame(()=>{
        requestAnimationFrame(()=>{
          meteor.addEventListener('transitionend', impactNow, { once: true });
          meteor.style.transform = `translate(${centerX - half}px, ${centerY - half}px) rotate(${angle}rad) scale(1.18)`;
          echoRaf = requestAnimationFrame(runEcho);
        });
      });
      setTimeout(impactNow, (travelDuration + 0.25) * 1000);
    }

    function spawnSonicRing(cx, cy, scale){
      if(!gridFxLayerEl) return;
      syncFxLayerBounds();
      const ring = document.createElement('div');
      ring.className = 'sonic-ring';
      ring.style.left = cx + 'px';
      ring.style.top = cy + 'px';
      if(Number.isFinite(scale)){
        ring.style.setProperty('--ring-scale', String(scale));
      }
      gridFxLayerEl.appendChild(ring);
      setTimeout(()=>ring.remove(), 360);
    }

    function applyMeteorImpactDamage(){
      if(!state.inRun) return;
      let touched = false;
      let broke = false;
      for(let i=0;i<25;i++){
        const ore = state.grid[i];
        if(!ore) continue;
        touched = true;
        const dmg = Math.max(10, Math.floor(ore.maxHp * 0.35));
        ore.hp -= dmg;
        if(ore.hp <= 0){
          onOreBroken(i, ore);
          broke = true;
        }
      }
      if(touched){
        renderGrid();
        if(!broke) renderTop();
      }
    }

    function applySonicPulseDamage(cx, cy, radius, damage){
      if(!state.inRun) return;
      let touched = false;
      let broke = false;
      for(let i=0;i<25;i++){
        const ore = state.grid[i];
        if(!ore) continue;
        const dist = Math.hypot(ore.x - cx, ore.y - cy);
        if(dist > radius) continue;
        touched = true;
        ore.hp -= damage;
        if(ore.hp <= 0){
          onOreBroken(i, ore);
          broke = true;
        }
      }
      if(touched){
        renderGrid();
        if(!broke) renderTop();
      }
    }

    function renderGrid(){ gridEl.innerHTML='';
      const gr = gridRect();
      const margins = currentGridMargins();
      const gridWidth = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
      const gridHeight = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
      const axisX = spawnAxisInfo(gridWidth, margins.x);
      const axisY = spawnAxisInfo(gridHeight, margins.y);
      for(let i=0;i<25;i++){
        const ore = state.grid[i];
        if(!ore) continue;
        applyOreVisuals(ore);
        clampOreToGrid(ore, axisX, axisY);
        const el = document.createElement('div');
        el.className='ore';
        el.dataset.type = ore.type;
        const shapeEl = document.createElement('div');
        shapeEl.className = 'ore-shape';
        const oreInfo = ore.type === 'EtherOre' ? null : ORE_BY_KEY.get(ore.type);
        const shapeKey = ore.type === 'EtherOre' ? 'ether' : (ore.shape || oreInfo?.shape || null);
        if(shapeKey){
          shapeEl.classList.add(`shape-${shapeKey}`);
        }
        shapeEl.style.background = ore.bg || '';
        if(ore.glow){
          shapeEl.style.boxShadow = ore.glow;
        }else{
          shapeEl.style.boxShadow = '';
        }
        const nameEl = document.createElement('span');
        nameEl.className = 'name';
        nameEl.textContent = ore.label || oreInfo?.name || ore.type;
        shapeEl.appendChild(nameEl);
        el.appendChild(shapeEl);
        let localX = ore.x - ORE_RADIUS;
        let localY = ore.y - ORE_RADIUS;
        const maxLeft = Math.max(0, gridWidth - ORE_SIZE);
        const maxTop = Math.max(0, gridHeight - ORE_SIZE);
        const minLeft = Math.max(0, (axisX?.min ?? axisX?.start ?? ORE_RADIUS) - ORE_RADIUS);
        const minTop = Math.max(0, (axisY?.min ?? axisY?.start ?? ORE_RADIUS) - ORE_RADIUS);
        const safeLeft = Math.min(Math.max(minLeft, (axisX?.max ?? axisX?.start ?? ORE_RADIUS) - ORE_RADIUS), maxLeft);
        const safeTop = Math.min(Math.max(minTop, (axisY?.max ?? axisY?.start ?? ORE_RADIUS) - ORE_RADIUS), maxTop);
        if(localX < minLeft || localX > safeLeft){
          localX = Math.min(Math.max(localX, minLeft), safeLeft);
          ore.x = localX + ORE_RADIUS;
        }
        if(localY < minTop || localY > safeTop){
          localY = Math.min(Math.max(localY, minTop), safeTop);
          ore.y = localY + ORE_RADIUS;
        }
        el.style.transform=`translate(${localX}px, ${localY}px)`;
        el.dataset.idx=i;
        const hp=document.createElement('div');
        hp.className='hp';
        const f=document.createElement('div');
        hp.appendChild(f);
        const ratio=Math.max(0,Math.min(1,ore.hp/ore.maxHp));
        f.style.width=(ratio*100)+'%';
        el.appendChild(hp);
        gridEl.appendChild(el);
        ore.el = el;
      }
      renderPets();
      syncFxLayerBounds(); }

    function renderInventory(){ const box=$('#inventoryList'); box.innerHTML='';
      const chk = document.getElementById('autoSellChkInv'); if(chk){ chk.checked = !!state.settings.autoSell; chk.onchange = ()=>{ state.settings.autoSell = !!chk.checked; save(); toast(`ìë™íŒë§¤ ${chk.checked?'ON':'OFF'}`); }; }
      for(const t of ORES){
        const inv = state.inventory[t.key]||0;
        const lvl = oreLevel(t.key);
        const levelMul = levelMultiplier(lvl);
        const totalMul = sellMultiplier(t.key);
        const li=document.createElement('div');
        li.className='inv-item';
        li.innerHTML = `<h4>${t.name} <span class="small">(${t.key})</span></h4>`+
          `<div class="mono">ë ˆë²¨: ${lvl}</div>`+
          `<div class="mono">íŒë§¤ ê¸ˆì•¡: x${formatMultiplier(levelMul)}</div>`+
          `<div class="mono">íŒë§¤ëŸ‰: ${state.oreSales[t.key]||0}</div>`+
          `<div>ê°€ì¹˜: <span class="price">${Math.round(t.value*totalMul)}</span> ê³¨ë“œ</div>`+
          `<div class="row" style="margin-top:6px;gap:6px;flex-wrap:wrap">`+
            `<button class="btn secondary" data-sellall="${t.key}">ëª¨ë‘ íŒë§¤</button>`+
            `<button class="btn secondary" data-sell="${t.key}">1ê°œ íŒë§¤</button>`+
          `</div>`+
          `<div class="row" style="margin-top:6px"><div class="mono">ë³´ìœ : ${inv}</div></div>`;
        box.appendChild(li);
      }
      box.querySelectorAll('[data-sell]').forEach(btn=> btn.addEventListener('click', ()=>{
        const k=btn.dataset.sell;
        const t=ORES.find(o=>o.key===k);
        if(state.inventory[k]>0){
          SFX.ui();
          state.inventory[k]--;
          const gained = processOreSale(k,1,t.value);
          if(gained>0){
            state.player.gold+=gained;
          }
          save();
          refresh();
        }
      }));
      box.querySelectorAll('[data-sellall]').forEach(btn=> btn.addEventListener('click', ()=>{ SFX.ui(); sellAllOf(btn.dataset.sellall); }));
      $('#sellAllGlobal').onclick = ()=>{ SFX.ui(); sellAllOres(); };
    }
    function sellAllOf(key){
      const t=ORES.find(o=>o.key===key);
      const n=state.inventory[key]||0;
      if(n>0){
        state.inventory[key]=0;
        const gained = processOreSale(key, n, t.value);
        if(gained>0){
          state.player.gold+=gained;
        }
        save();
        refresh();
      }
    }
    function sellAllOres(){
      let total=0;
      for(const t of ORES){
        const n=state.inventory[t.key]||0;
        if(n>0){
          const gained = processOreSale(t.key, n, t.value);
          if(gained>0){
            total += gained;
          }
          state.inventory[t.key]=0;
        }
      }
      if(total>0){
        state.player.gold += total;
        save();
        refresh();
      }
    }

    function renderUpgrades(){
      const cont=$('#upgrades'); cont.innerHTML='';
      calcAtk();
      for(const info of UPGRADE_INFO || []){
        const desc = typeof info.getDescription === 'function' ? info.getDescription(state) : '';
        const cost = typeof info.getCost === 'function' ? info.getCost(state) : 0;
        const baseLevel = typeof info.getLevel === 'function' ? info.getLevel(state) : null;
        const levelLabel = typeof info.getLevelLabel === 'function'
          ? info.getLevelLabel(state)
          : (baseLevel !== null && baseLevel !== undefined ? `Lv ${baseLevel}` : '');
        cont.appendChild(upgradeCard(info.title, levelLabel, desc, cost, ()=>{
          const check = typeof info.canBuy === 'function' ? info.canBuy(state) : true;
          if(check !== true){
            if(typeof check === 'string' && check){ toast(check); }
            SFX.deny();
            return;
          }
          const price = typeof info.getCost === 'function' ? info.getCost(state) : cost;
          if(!spend(price)){ SFX.deny(); return; }
          if(typeof info.onBuy === 'function'){
            info.onBuy({ state, restartSpawnTimer, spawnPets, applyPetBehaviorUpgrade, renderAether });
          }
          SFX.ui();
          save();
          refresh();
        }));
      }
    }
    function upgradeCard(title, levelLabel, desc, cost, onBuy){
      const wrap=document.createElement('div');
      wrap.className='inv-item';
      const headerRight = levelLabel ? `<span class="mono">${levelLabel}</span>` : '';
      wrap.innerHTML = `
        <div class="row" style="justify-content:space-between;align-items:center;margin:0 0 4px 0">
          <h4 style="margin:0">${title}</h4>
          ${headerRight}
        </div>
        <div class="mono">${desc}</div>
        <div class="row" style="margin-top:8px;justify-content:space-between">
          <div class="row"><span>ê°€ê²©:</span> <b class="price">${cost}</b></div>
          <button class="btn">êµ¬ë§¤</button>
        </div>`;
      wrap.querySelector('.btn').addEventListener('click', onBuy);
      return wrap;
    }
    function spend(amount){ if(state.player.gold < amount){ toast('ê³¨ë“œ ë¶€ì¡±'); return false; } state.player.gold -= amount; return true; }
    function spendAe(amount){ if(state.player.ether < amount){ toast('ì—í…Œë¥´ ë¶€ì¡±'); return false; } state.player.ether -= amount; return true; }

    function renderAether(){
      $('#aeBalance').textContent = state.player.ether;
      $('#rebirths').textContent = (state.aether?.rebirths||0)+'íšŒ';
      const canRebirth = state.highestFloor >= 20;
      const autoCost = AUTO_CHALLENGE_COST;
      const ownAuto = !!state.aether.autoChallengeOwned;
      $('#autoChallengeBuyBtn').disabled = ownAuto || !canRebirth || state.player.ether < autoCost;
      $('#autoChallengeBuyBtn').textContent = ownAuto ? 'í•´ê¸ˆë¨' : `ì—í…Œë¥´ ${autoCost} ì†Œëª¨ í›„ í•´ê¸ˆ`;
      $('#autoChallengeChk').disabled = !ownAuto;
      $('#autoChallengeChk').checked = !!state.aether.autoChallengeEnabled;

      const list = $('#rebirthPerks'); list.innerHTML='';
      let total = 0;
      for(const p of REBIRTH_PERKS){
        const lvl = p.getLevel(state);
        const maxed = lvl >= p.max;
        const cost = perkCost(p);
        const checked = !!rebirthPick[p.key];
        const row = document.createElement('div'); row.className='skill-card';
        const header = `<div class="row" style="justify-content:space-between"><b>${p.name}</b><span class="mono">Lv ${lvl}/${p.max}</span></div>`;
        const desc = `<div class="mono" style="opacity:.8;margin:4px 0 6px 0">${p.desc}</div>`;
        let extra = '';
        if(p.key === 'etherHaste'){
          const upgradeLevel = getEtherLocatorLevel(state);
          const currentDelay = computeEtherSpawnDelay(lvl, upgradeLevel);
          const perkReduction = computeEtherSpawnReduction(lvl);
          const upgradeReduction = computeEtherSpawnReduction(upgradeLevel);
          const formatSeconds = (value) => {
            if(!Number.isFinite(value)) return '--';
            const normalized = Math.max(0, value);
            if(normalized === 0) return '0.0';
            const decimals = Number.isInteger(normalized) ? 0 : 1;
            return normalized.toFixed(decimals);
          };
          const lines = [`í˜„ì¬ ë“±ì¥: ${formatSeconds(currentDelay)}ì´ˆ`];
          if(perkReduction > 0){
            lines.push(`<span style="opacity:.75">í™˜ìƒ ë³´ë„ˆìŠ¤: -${formatSeconds(perkReduction)}ì´ˆ</span>`);
          }
          if(upgradeReduction > 0){
            lines.push(`<span style="opacity:.75">ê³¨ë“œ ì—…ê·¸ë ˆì´ë“œ: -${formatSeconds(upgradeReduction)}ì´ˆ</span>`);
          }
          const content = lines.join('<br>');
          extra = `<div class="mono" style="margin:0 0 6px 0">${content}</div>`;
        }
        if(maxed && rebirthPick[p.key]){
          delete rebirthPick[p.key];
        }
        row.innerHTML = header + desc + extra;
        const footer = document.createElement('div');
        footer.className = 'row';
        footer.style.justifyContent = 'space-between';
        footer.style.marginTop = '6px';
        const priceLabel = document.createElement('div');
        priceLabel.className = 'mono';
        priceLabel.textContent = maxed ? 'ë¹„ìš© -- ì—í…Œë¥´' : `ë¹„ìš© ${cost} ì—í…Œë¥´`;
        footer.appendChild(priceLabel);
        if(maxed){
          const maxLabel = document.createElement('div');
          maxLabel.className = 'mono';
          maxLabel.textContent = 'ìµœëŒ€ ë ˆë²¨';
          footer.appendChild(maxLabel);
        } else {
          const label = document.createElement('label');
          label.className = 'row';
          label.style.gap = '6px';
          label.style.alignItems = 'center';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.dataset.perk = p.key;
          input.checked = checked;
          label.appendChild(input);
          const span = document.createElement('span');
          span.textContent = 'ì„ íƒ';
          label.appendChild(span);
          footer.appendChild(label);
        }
        row.appendChild(footer);
        list.appendChild(row);
        if(checked && !maxed){ total += cost; }
      }
      $('#rebirthTotal').textContent = total;
      const afford = state.player.ether >= total;
      $('#rebirthBuyBtn').disabled = !(canRebirth && afford && total>0);
    }

    function flashHudAetherGain(amount){
      if(!hudAeGainEl) return;
      if(typeof amount !== 'number' || !Number.isFinite(amount)) return;
      if(hudAeGainTimer){
        clearTimeout(hudAeGainTimer);
        hudAeGainTimer = null;
      }
      const formatted = amount > 0 ? `+${amount}` : `${amount}`;
      hudAeGainEl.textContent = formatted;
      hudAeGainEl.classList.add('show');
      hudAeGainTimer = setTimeout(()=>{
        hudAeGainEl.classList.remove('show');
        hudAeGainEl.textContent = '';
        hudAeGainTimer = null;
      }, 3000);
    }

    function flashAetherGain(amount){
      if(typeof amount !== 'number' || !Number.isFinite(amount)) return;
      flashHudAetherGain(amount);
      if(!aeGainFlashEl) return;
      if(aeGainFlashTimer){
        clearTimeout(aeGainFlashTimer);
        aeGainFlashTimer = null;
      }
      const formatted = amount > 0 ? `+${amount}` : `${amount}`;
      aeGainFlashEl.textContent = formatted;
      aeGainFlashEl.classList.add('show');
      aeGainFlashTimer = setTimeout(()=>{
        aeGainFlashEl.classList.remove('show');
        aeGainFlashEl.textContent = '';
        aeGainFlashTimer = null;
      }, 3000);
    }

    function syncSkillSlotsWithOwned(){
      if(!Array.isArray(state.skillSlots)){
        state.skillSlots = [null,null,null,null,null];
      }
      const desiredLength = Math.max(5, state.skillSlots.length);
      if(state.skillSlots.length < desiredLength){
        state.skillSlots = [...state.skillSlots, ...Array(desiredLength - state.skillSlots.length).fill(null)];
      }
      let changed = false;
      for(let i=0;i<state.skillSlots.length;i++){
        const def = ACTIVE_SKILLS[i];
        const should = def && state.skillsOwnedActive[def.key] ? def.key : null;
        if(state.skillSlots[i] !== should){
          state.skillSlots[i] = should;
          changed = true;
        }
      }
      return changed;
    }

    function passiveMaxLevel(sk){
      if(typeof sk.maxLevel === 'number' && sk.maxLevel > 0){ return sk.maxLevel; }
      if(sk.once){ return 1; }
      return 20;
    }

    function formatPassiveValue(value, cfg){
      const num = Number.isFinite(value) ? value : 0;
      let str;
      if(cfg && typeof cfg.decimals === 'number'){
        str = num.toFixed(cfg.decimals);
      }else if(Number.isInteger(num)){
        str = num.toString();
      }else{
        str = num.toFixed(2).replace(/\.0+$/,'').replace(/0+$/,'');
      }
      if(cfg?.unit === '%'){ return `${str}%`; }
      if(cfg?.unit){ return `${str}${cfg.unit}`; }
      return str;
    }

    function getPassiveSkillBaseCost(sk){
      if(!sk) return 0;
      if(Number.isFinite(sk.aeBase)) return sk.aeBase;
      return toFiniteNumber(sk.ae, 0);
    }

    function getPassiveSkillCost(sk, ownedLevel){
      const base = getPassiveSkillBaseCost(sk);
      return calcLinearCost(base, 0.10, ownedLevel);
    }

    function buildPassiveStatLine(sk, level, isMaxed){
      const cfg = PASSIVE_DISPLAY_INFO[sk.key];
      if(!cfg){ return ''; }
      const safeLevel = Math.max(0, level);
      const totalValue = cfg.calcTotal ? cfg.calcTotal(safeLevel) : safeLevel * (cfg.perLevel ?? 0);
      const baseText = `${cfg.label} ${formatPassiveValue(totalValue, cfg)}`;
      if(isMaxed){ return baseText; }
      const deltaValue = cfg.calcDelta ? cfg.calcDelta(safeLevel) : (cfg.perLevel ?? 0);
      if(!deltaValue){ return baseText; }
      const deltaText = cfg.formatDelta ? cfg.formatDelta(deltaValue, cfg) : formatPassiveValue(deltaValue, cfg);
      return `${baseText} (+${deltaText})`;
    }

    function renderSkills(){
      ensurePassiveDefaults();
      ensureSkillAutoDefaults();
      const slotsUpdated = syncSkillSlotsWithOwned();
      if(slotsUpdated){ save(); }
      const slotList = $('#slotList'); slotList.innerHTML='';
      for(let i=0;i<5;i++){
        const el=document.createElement('div'); el.className='slot'; const sk = state.skillSlots[i];
        el.textContent = sk ? ACTIVE_SKILLS.find(s=>s.key===sk).name : '+ ë¹ˆ ìŠ¬ë¡¯';
        el.addEventListener('click', ()=>{
          SFX.ui();
          toast('ì•¡í‹°ë¸Œ ìŠ¤í‚¬ì€ ìë™ìœ¼ë¡œ ìŠ¬ë¡¯ì— ë°°ì¹˜ë©ë‹ˆë‹¤.');
        });
        slotList.appendChild(el);
      }
      $('#slotCount').textContent = state.skillSlots.filter(Boolean).length + '/5';

      const shopP = $('#skillShopPassive'); shopP.innerHTML='';
      for(const sk of PASSIVE_SKILLS){
        const ownedCount = state.skillsOwnedPassive[sk.key] || 0;
        const maxLevel = passiveMaxLevel(sk);
        const displayLevel = Math.min(ownedCount, maxLevel);
        const isMaxed = ownedCount >= maxLevel;
        const owned = ownedCount > 0;
        const levelLabel = `Lv ${displayLevel}/${maxLevel}`;
        const statLine = buildPassiveStatLine(sk, displayLevel, isMaxed);
        const card = document.createElement('div'); card.className = 'skill-card';
        if(isMaxed){ card.classList.add('owned-passive'); }
        const descBlock = sk.desc ? `<div class="mono" style="opacity:.8;margin:4px 0 ${statLine?4:8}px 0">${sk.desc}</div>` : '';
        const statBlock = statLine ? `<div class="mono" style="margin:0 0 8px 0">${statLine}</div>` : '';
        const priceValue = isMaxed ? '--' : getPassiveSkillCost(sk, ownedCount);
        const buttonLabel = isMaxed
          ? (sk.once ? 'ë³´ìœ ì¤‘' : 'ìµœëŒ€ ë ˆë²¨')
          : (owned ? 'ì¶”ê°€ êµ¬ë§¤' : 'êµ¬ë§¤');
        const buttonDisabled = isMaxed;
        const priceRow = `<div class="row" style="justify-content:space-between${(!statLine && !sk.desc)?';margin-top:8px':''}"><div>ê°€ê²©: <b class="price">${priceValue}</b> ì—í…Œë¥´</div><button class="btn" ${buttonDisabled?'disabled':''}>${buttonLabel}</button></div>`;
        card.innerHTML = `<div class="row" style="justify-content:space-between"><b>${sk.name}</b><span class="mono">${levelLabel}</span></div>`+
                         descBlock +
                         statBlock +
                         priceRow;
        const buyBtn = card.querySelector('.btn');
        if(buyBtn){
          buyBtn.addEventListener('click', ()=>{
            if(ownedCount >= maxLevel){ toast('ìµœëŒ€ ë ˆë²¨ì…ë‹ˆë‹¤.'); SFX.deny(); return; }
            const currentOwned = state.skillsOwnedPassive[sk.key] || 0;
            const cost = getPassiveSkillCost(sk, currentOwned);
            if(!spendAe(cost)) { SFX.deny(); return; }
            if(!state.skillsOwnedPassive[sk.key]) state.skillsOwnedPassive[sk.key]=0;
            const nextLevel = Math.min(maxLevel, state.skillsOwnedPassive[sk.key] + 1);
            state.skillsOwnedPassive[sk.key] = nextLevel;
            if(typeof sk.apply === 'function'){ sk.apply({ state, restartSpawnTimer, spawnPets }); }
            ensurePassiveDefaults();
            toast(`${sk.name} ì ìš©!`); SFX.ui(); save(); renderSkills(); renderUpgrades(); renderTop();
          });
        }
        if(sk.toggleKey){
          const toggleRow = document.createElement('div');
          toggleRow.className = 'row';
          toggleRow.style.justifyContent = 'flex-end';
          toggleRow.style.marginTop = '8px';
          const label = document.createElement('label');
          label.className = 'row';
          label.style.alignItems = 'center';
          label.style.gap = '6px';
          const toggle = document.createElement('input');
          toggle.type = 'checkbox';
          toggle.style.width = '18px';
          toggle.style.height = '18px';
          toggle.checked = !!state.passive[sk.toggleKey];
          toggle.disabled = !owned;
          toggle.addEventListener('change', ()=>{
            if(!owned){ toggle.checked = false; return; }
            state.passive[sk.toggleKey] = !!toggle.checked;
            save();
            SFX.ui();
            toast(`${sk.name} ${toggle.checked?'ON':'OFF'}`);
          });
          const span = document.createElement('span');
          span.textContent = sk.toggleLabel || 'ON/OFF';
          label.appendChild(toggle);
          label.appendChild(span);
          toggleRow.appendChild(label);
          card.appendChild(toggleRow);
        }
        shopP.appendChild(card);
      }
      const shopA = $('#skillShopActive'); shopA.innerHTML='';
      for(const sk of ACTIVE_SKILLS){
        const owned = !!state.skillsOwnedActive[sk.key];
        const card = document.createElement('div'); card.className = 'skill-card';
        if(owned){ card.classList.add('owned-active'); }
        card.innerHTML = `<div class="row" style="justify-content:space-between"><b>${sk.name}</b><span class="mono">ì¿¨íƒ€ì„ ${sk.cd}s</span></div><div class="mono" style="opacity:.8;margin:4px 0 8px 0">${sk.desc}</div><div class="row" style="justify-content:space-between"><div>ê°€ê²©: <b class="price">${sk.ae}</b> ì—í…Œë¥´</div><button class="btn" ${owned?'disabled':''}>${owned?'ë³´ìœ ì¤‘':'êµ¬ë§¤'}</button></div>`;
        if(!owned){
          card.querySelector('.btn').addEventListener('click', ()=>{
            if(!spendAe(sk.ae)) { SFX.deny(); return; }
            state.skillsOwnedActive[sk.key]=true;
            toast(`${sk.name} íšë“!`);
            SFX.ui();
            save();
            renderSkills();
            renderSkillBar();
            renderTop();
          });
        }
        if(sk.autoToggleKey){
          const toggleRow = document.createElement('div');
          toggleRow.className = 'row';
          toggleRow.style.justifyContent = 'flex-end';
          toggleRow.style.marginTop = '8px';
          const label = document.createElement('label');
          label.className = 'row';
          label.style.alignItems = 'center';
          label.style.gap = '6px';
          const toggle = document.createElement('input');
          toggle.type = 'checkbox';
          toggle.style.width = '18px';
          toggle.style.height = '18px';
          toggle.checked = !!state.skillAuto[sk.autoToggleKey];
          toggle.disabled = !owned;
          toggle.addEventListener('change', ()=>{
            if(!owned){ toggle.checked = false; return; }
            state.skillAuto[sk.autoToggleKey] = !!toggle.checked;
            save();
            SFX.ui();
            toast(`${sk.name} ${toggle.checked ? 'ìë™ ì‚¬ìš© ON' : 'ìë™ ì‚¬ìš© OFF'}`);
          });
          const span = document.createElement('span');
          span.textContent = sk.autoToggleLabel || 'ìë™ ì‚¬ìš©';
          label.appendChild(toggle);
          label.appendChild(span);
          toggleRow.appendChild(label);
          card.appendChild(toggleRow);
        }
        shopA.appendChild(card);
      }
    }

    function attachSkillButtonEvents(btn, key){
      if(!btn || !key) return;
      const triggerSkill = ()=>{ SFX.ui(); useSkill(key); };
      let pointerActivated = false;
      btn.addEventListener('pointerdown', (ev)=>{
        if(btn.disabled) return;
        if(typeof ev.button === 'number' && ev.button !== 0) return;
        pointerActivated = true;
        ev.preventDefault();
        triggerSkill();
      }, {passive:false});
      btn.addEventListener('pointerup', ()=>{
        if(pointerActivated){
          setTimeout(()=>{ pointerActivated = false; }, 0);
        }
      });
      btn.addEventListener('pointercancel', ()=>{ pointerActivated = false; });
      btn.addEventListener('click', (ev)=>{
        if(pointerActivated){
          ev.preventDefault();
          pointerActivated = false;
          return;
        }
        triggerSkill();
      });
    }

    function isSkillDurationActive(key, nowTs){
      if(!key) return false;
      const ts = (typeof nowTs === 'number') ? nowTs : performance.now();
      switch(key){
        case 'haste':
          return state.skillHasteUntil > ts;
        case 'berserk':
          return state.skillAtkBuffUntil === Infinity || state.skillAtkBuffUntil > ts;
        default:
          return false;
      }
    }

    function renderSkillBar(){
      syncSkillSlotsWithOwned();
      if(!state.inRun){ skillBarEl.style.display='none'; return; }
      skillBarEl.style.display='grid'; skillBarEl.innerHTML='';
      const now = performance.now();
      for(let i=0;i<5;i++){
        const k = state.skillSlots[i];
        const b=document.createElement('button'); b.className='skillbtn'; b.textContent = k? ACTIVE_SKILLS.find(s=>s.key===k).name : '-';
        if(!k){ b.disabled=true; }
        else {
          const cd = Math.max(0, state.skillCooldowns[k]||0);
          if(cd>0){ b.classList.add('cd'); b.textContent = `${ACTIVE_SKILLS.find(s=>s.key===k).name} (${cd.toFixed(0)}s)`; b.disabled=true; }
          attachSkillButtonEvents(b, k);
          if(isSkillDurationActive(k, now)){
            b.classList.add('duration-active');
          }
        }
        skillBarEl.appendChild(b);
      }
    }

    function setCd(key, sec){ state.skillCooldowns[key] = sec; }

    function activateBerserk(){
      if(!state.skillsOwnedActive?.berserk) return { success:false };
      const currentCd = state.skillCooldowns.berserk || 0;
      if(currentCd > 0) return { success:false, reason:'cooldown' };
      const now = performance.now();
      const newUntil = now + 5000;
      const currentUntil = state.skillAtkBuffUntil;
      if(currentUntil !== Infinity){
        const finiteCurrent = Number.isFinite(currentUntil) ? currentUntil : 0;
        state.skillAtkBuffUntil = Math.max(finiteCurrent, newUntil);
      }
      if(state.runFlags){
        if(state.runFlags.berserkBoostActive){
          const prev = state.runFlags.berserkBoostPrevExpiry;
          const finitePrev = Number.isFinite(prev) ? prev : 0;
          state.runFlags.berserkBoostPrevExpiry = Math.max(finitePrev, newUntil);
        } else {
          state.runFlags.berserkBoostPrevExpiry = null;
        }
      }
      const cd = BERSERK_SKILL?.cd || 20;
      return { success:true, cd };
    }

    const AUTO_TIMEWARP_THRESHOLD = 5;

    const AUTO_SKILL_RULES = {
      haste: {
        shouldUse: (now) => state.skillHasteUntil <= now,
      },
      timewarp: {
        shouldUse: () => state.timeLeft <= AUTO_TIMEWARP_THRESHOLD,
      },
      sonic: {
        shouldUse: () => state.grid.some(o => o && o.type === 'EtherOre'),
      },
    };

    function maybeHandleAutoBerserk(){
      if(!state.inRun) return;
      state.runFlags = state.runFlags || {};
      const hasBoost = !!state.passive?.berserkUnlimit;
      const finalPhase = state.timeLeft <= 5;
      let needsUpdate = false;

      if(hasBoost){
        if(finalPhase){
          if(!state.runFlags.berserkBoostActive){
            state.runFlags.berserkBoostActive = true;
            state.runFlags.berserkBoostPrevExpiry = Number.isFinite(state.skillAtkBuffUntil)
              ? state.skillAtkBuffUntil
              : null;
            if(state.skillAtkBuffUntil !== Infinity){
              state.skillAtkBuffUntil = Infinity;
              needsUpdate = true;
            }
          }
        } else if(state.runFlags.berserkBoostActive){
          state.runFlags.berserkBoostActive = false;
          const prev = state.runFlags.berserkBoostPrevExpiry;
          state.runFlags.berserkBoostPrevExpiry = null;
          if(state.skillAtkBuffUntil === Infinity){
            if(Number.isFinite(prev) && prev > performance.now()){
              state.skillAtkBuffUntil = prev;
            } else {
              state.skillAtkBuffUntil = 0;
            }
            needsUpdate = true;
          }
        }
      } else if(state.runFlags.berserkBoostActive){
        state.runFlags.berserkBoostActive = false;
        state.runFlags.berserkBoostPrevExpiry = null;
        if(state.skillAtkBuffUntil === Infinity){
          state.skillAtkBuffUntil = 0;
          needsUpdate = true;
        }
      }

      if(needsUpdate){
        renderSkillBar(); renderGrid(); renderTop();
      }
    }

    function maybeHandleAutoSkills(){
      if(!state.inRun) return;
      if(!state.skillAuto || typeof state.skillAuto !== 'object') return;
      if(state.timeLeft <= 0) return;
      const now = performance.now();
      for(const sk of ACTIVE_SKILLS){
        if(!sk.autoToggleKey) continue;
        if(!state.skillAuto[sk.autoToggleKey]) continue;
        if(!state.skillsOwnedActive?.[sk.key]) continue;
        const cd = state.skillCooldowns[sk.key] || 0;
        if(cd > 0.05) continue;
        const rule = AUTO_SKILL_RULES[sk.key];
        if(rule && typeof rule.shouldUse === 'function' && !rule.shouldUse(now)) continue;
        useSkill(sk.key);
      }
    }

    function useSkill(key){
      if(!state.inRun) return;
      const sk = ACTIVE_SKILLS.find(s=>s.key===key); if(!sk) return;
      const cd = state.skillCooldowns[key]||0; if(cd>0){ SFX.deny(); return; }
      let cdOverride = null;
      let used = true;
      switch(key){
        case 'berserk': {
          const result = activateBerserk();
          if(!result.success){ SFX.deny(); return; }
          cdOverride = result.cd;
          SFX.skill();
          break;
        }
        case 'timewarp': addRunTime(3); SFX.skill(); break;
        case 'meteor': {
          spawnMeteorSkillEffect(()=>{
            applyMeteorImpactDamage();
          });
          SFX.skill();
          break;
        }
        case 'haste': {
          state.skillHasteUntil = performance.now()+5000;
          state.runFlags = state.runFlags || {};
          state.runFlags.hasteActive = true;
          restartSpawnTimer();
          SFX.skill();
          break;
        }
        case 'sonic': {
          const etherIdx = state.grid.findIndex(o => o && o.type === 'EtherOre');
          if(etherIdx < 0){
            used = false;
            SFX.deny();
            toast('ì—í…Œë¥´ ê´‘ì„ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return;
          }
          const target = state.grid[etherIdx];
          if(!target){ used = false; return; }
          const center = cellCenter(etherIdx);
          const pulseCount = 5;
          const interval = 140;
          const radius = ORE_RADIUS * 4;
          const atk = calcAtk();
          const dmgPerPulse = Math.max(4, Math.round(atk * 2));
          for(let i=0;i<pulseCount;i++){
            setTimeout(()=>{
              if(!state.inRun) return;
              spawnSonicRing(center.x, center.y, 4);
              applySonicPulseDamage(center.x, center.y, radius, dmgPerPulse);
            }, i * interval);
          }
          SFX.skill();
          break;
        }
        default: used = false;
      }
      if(!used) return;
      const nextCd = (cdOverride !== null) ? cdOverride : sk.cd;
      if(typeof nextCd === 'number'){ setCd(key, nextCd); }
      renderSkillBar(); renderGrid(); renderTop();
    }

    function floorHpMul(){ return Math.pow(1.1, state.floor-1); }
    function floorValMul(){ return 1 + 0.12*(state.floor-1); }
    function etherHpForFloor(){
      const baseHp = 500;
      const floorOffset = Math.max(0, state.floor - 1);
      const scale = Math.pow(1.15, floorOffset);
      return Math.round(baseHp * scale);
    }

    function startRun(){
      if(state.inRun) return;
      resetRunFlags();
      state.skillHasteUntil = 0;
      state.skillAtkBuffUntil = 0;
      state.inRun = true;
      state.etherSpawned=false;
      setRunTime(MAX_RUN_TIME);
      state.grid = new Array(25).fill(null);
      for(const o of ORES){ state.loot[o.key]=0; }
      Object.keys(state.skillCooldowns).forEach(k=> delete state.skillCooldowns[k]);
      restartSpawnTimer();
      state.runStartTs = performance.now();
      state.lastTickReal = state.runStartTs;
      startTick();
      renderSkillBar();
      gridRectCache = null;
      spawnPets();
      maybeHandleAutoSkills();
      refresh();
    }

    function startTick(){
      clearInterval(state.timers.tick);
      state.lastTickReal = performance.now();
      state.timers.tick = setInterval(()=>{
        if(!state.inRun) return;
        const now = performance.now();
        const delta = Math.max(0, (now - (state.lastTickReal || now)) / 1000);
        state.lastTickReal = now;
        const elapsed = (now - state.runStartTs)/1000;
        const etherHasteLevel = state.aether?.etherHaste || 0;
        const etherUpgradeLevel = getEtherLocatorLevel(state);
        const etherDelay = computeEtherSpawnDelay(etherHasteLevel, etherUpgradeLevel);
        if(!state.etherSpawned && elapsed >= etherDelay){ spawnEther(); }
        if(delta > 0){ reduceRunTime(delta); }
        const cdKeys = Object.keys(state.skillCooldowns);
        if(cdKeys.length){
          for(const k of cdKeys){ state.skillCooldowns[k] = Math.max(0, state.skillCooldowns[k]-delta); }
        }
        state.runFlags = state.runFlags || {};
        const hasteActiveNow = state.skillHasteUntil > now;
        if(state.runFlags.hasteActive !== hasteActiveNow){
          state.runFlags.hasteActive = hasteActiveNow;
          restartSpawnTimer();
        }
        maybeHandleAutoBerserk();
        maybeHandleAutoSkills();
        if(state.timeLeft<=0){ bankAndExit(false); return; }
        renderTop(); renderSkillBar();
      },100);
      state.lastAnimTs = performance.now();
      if(state.animFrameId){
        cancelAnimationFrame(state.animFrameId);
        state.animFrameId = 0;
      }
      state.animFrameId = requestAnimationFrame(petsFrame);
    }

    function pauseRunForVisibility(){
      if(!state.inRun) return;
      if(state.visibilityPauseTs) return;
      state.visibilityPauseTs = performance.now();
      clearInterval(state.timers.spawn); state.timers.spawn = null;
      clearInterval(state.timers.tick); state.timers.tick = null;
      if(state.animFrameId){
        cancelAnimationFrame(state.animFrameId);
        state.animFrameId = 0;
      }
    }

    function resumeRunAfterVisibility(){
      if(!state.inRun) return;
      if(!state.visibilityPauseTs) return;
      const now = performance.now();
      const pausedDuration = Math.max(0, now - state.visibilityPauseTs);
      state.visibilityPauseTs = 0;
      if(Number.isFinite(pausedDuration) && pausedDuration > 0){
        state.runStartTs += pausedDuration;
        if(state.skillHasteUntil > 0 && Number.isFinite(state.skillHasteUntil)){
          state.skillHasteUntil += pausedDuration;
        }
        if(state.skillAtkBuffUntil !== Infinity && Number.isFinite(state.skillAtkBuffUntil) && state.skillAtkBuffUntil > 0){
          state.skillAtkBuffUntil += pausedDuration;
        }
        if(state.runFlags && Number.isFinite(state.runFlags.berserkBoostPrevExpiry)){
          state.runFlags.berserkBoostPrevExpiry += pausedDuration;
        }
      }
      state.lastTickReal = now;
      state.lastAnimTs = now;
      restartSpawnTimer();
      startTick();
    }

    function getBaseSpawnIntervalMs(){
      const level = getUpgradeLevel(state, 'spawn');
      if(typeof window.spawnIntervalForLevel === 'function'){
        return window.spawnIntervalForLevel(level);
      }
      return Math.max(600, 2200 * Math.pow(0.94, level));
    }

    function restartSpawnTimer(){
      const baseInterval = getBaseSpawnIntervalMs();
      let interval = baseInterval;
      const now = (typeof performance !== 'undefined' && typeof performance.now === 'function')
        ? performance.now()
        : Date.now();
      if(state.skillHasteUntil > now) interval *= 0.5;
      state.currentSpawnIntervalMs = interval;
      clearInterval(state.timers.spawn); state.timers.spawn = setInterval(spawnOre, interval);
    }
    function exitRun(){ if(!state.inRun) return; bankAndExit(false); }

    function isAutoChallengeActive(){
      return !!(state.aether?.autoChallengeOwned && state.aether.autoChallengeEnabled);
    }

    function maybeStartAutoChallenge(){
      if(state.inRun) return;
      if(!isAutoChallengeActive()) return;
      startRun();
    }

    function bankAndExit(cleared){
      if(state.settings?.autoSell){
        let totalGold = 0;
        for(const k in state.loot){
          const oreDef = ORES.find(o=>o.key===k);
          const n = state.loot[k]||0;
          if(!oreDef || n<=0) continue;
          const gained = processOreSale(k, n, oreDef.value);
          if(gained>0){
            totalGold += gained;
          }
        }
        if(totalGold>0) state.player.gold += totalGold;
      } else {
        for(const k in state.loot){ state.inventory[k] = (state.inventory[k]||0) + state.loot[k]; }
      }
      for(const k in state.loot){ state.loot[k]=0; }
      state.inRun=false; clearInterval(state.timers.spawn); clearInterval(state.timers.tick);
      setRunTime(0);
      state.pets=[]; state.lastAnimTs=0; state.grid = new Array(25).fill(null);
      if(cleared){ state.floor++; if(state.floor>state.highestFloor) state.highestFloor=state.floor; }
      state.currentSpawnIntervalMs = getBaseSpawnIntervalMs();
      save();
      renderSkillBar();
      gridRectCache = null;
      refresh();
      if(isAutoChallengeActive()){
        setTimeout(()=>{ maybeStartAutoChallenge(); }, 250);
      }
    }

    function cancelRunWithoutRewards(){
      if(!state.inRun) return;
      for(const k in state.loot){ state.loot[k] = 0; }
      state.inRun = false;
      clearInterval(state.timers.spawn); state.timers.spawn = null;
      clearInterval(state.timers.tick); state.timers.tick = null;
      state.pets = [];
      state.lastAnimTs = 0;
      state.grid = new Array(25).fill(null);
      setRunTime(0);
      state.currentSpawnIntervalMs = getBaseSpawnIntervalMs();
      renderSkillBar();
      gridRectCache = null;
      refresh();
      if(isAutoChallengeActive()){
        setTimeout(()=>{ maybeStartAutoChallenge(); }, 0);
      }
    }

    function resetGoldProgression(){
      const freshUpgrades = {};
      for(const [key, def] of Object.entries(UPGRADE_DEFAULTS || {})){
        const baseLevel = def && typeof def.level === 'number' ? def.level : 0;
        freshUpgrades[key] = { level: baseLevel };
      }
      freshUpgrades.oreMul = {};
      state.upgrades = freshUpgrades;
      state.player.gold = 0;
      for(const ore of ORES){
        state.inventory[ore.key] = 0;
        state.oreSales[ore.key] = 0;
        state.loot[ore.key] = 0;
        state.upgrades.oreMul[ore.key] = 0;
      }
      state.floor = 1;
      state.highestFloor = 1;
      applyPetBehaviorUpgrade();
    }

    function spawnOre(){
      const empties = state.grid.map((v,i)=> v? null : i).filter(v=>v!==null); if(empties.length===0) return;
      const idx = empties[Math.floor(Math.random()*empties.length)];
      const pool = eligibleOresForFloor(state.floor);
      const base = randWeighted(pool);
      const elapsed = (performance.now() - state.runStartTs)/1000;
      const growth = 1 + 0.05 * Math.max(0, Math.floor(elapsed));
      const hp = Math.round(base.hp*floorHpMul()*growth*(state.skillAtkBuffUntil>performance.now()?0.9:1));
      const value = Math.round(base.value*floorValMul());
      const gr = gridRect();
      const margins = currentGridMargins();
      const gridWidth = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
      const gridHeight = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
      const axisX = spawnAxisInfo(gridWidth, margins.x);
      const axisY = spawnAxisInfo(gridHeight, margins.y);
      const ore = {
        type: base.key,
        label: base.name,
        hp,
        maxHp: hp,
        value,
        bg: base.color,
        x: axisX.start + (axisX.span>0 ? Math.random()*axisX.span : 0),
        y: axisY.start + (axisY.span>0 ? Math.random()*axisY.span : 0)
      };
      applyOreVisuals(ore);
      clampOreToGrid(ore, axisX, axisY);
      state.grid[idx] = ore;
      renderGrid();
    }

      function spawnEther(){
        const empties = state.grid.map((v,i)=> v? null : i).filter(v=>v!==null); if(empties.length===0) return;
        const idx = empties[Math.floor(Math.random()*empties.length)]; state.etherSpawned = true;
        const hp = etherHpForFloor();
        const gr = gridRect();
        const margins = currentGridMargins();
        const gridWidth = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
        const gridHeight = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
        const axisX = spawnAxisInfo(gridWidth, margins.x);
        const axisY = spawnAxisInfo(gridHeight, margins.y);
        const ore = {
          type:'EtherOre',
          label:'ì—í…Œë¥´ ê´‘ì„',
          hp,
          maxHp: hp,
          value: 0,
          bg:'#a855f7',
          x: axisX.start + (axisX.span>0 ? Math.random()*axisX.span : 0),
          y: axisY.start + (axisY.span>0 ? Math.random()*axisY.span : 0)
        };
        clampOreToGrid(ore, axisX, axisY);
        state.grid[idx] = ore; renderGrid(); }

    function onOreBroken(idx, ore){
      if(ore.type==='EtherOre'){
        state.player.ether += 10;
        flashAetherGain(10);
        state.grid[idx] = null;
        SFX.break();
        bankAndExit(true);
        return;
      }
      state.loot[ore.type] = (state.loot[ore.type]||0)+1;
      state.grid[idx] = null;
      addRunTime(0.25);
      SFX.break();
      renderTop();
    }

    function hit(idx, source='tap', opts={}){
      if(!state.inRun) return; const ore = state.grid[idx]; if(!ore) return;
      const atk = calcAtk();
      const dmgMul = Number.isFinite(opts?.damageMul) ? Math.max(0, opts.damageMul) : 1;
      let dmg = Math.round(atk * (state.skillAtkBuffUntil>performance.now()?2:1) * dmgMul);
      const canCrit = (source === 'tap' || source === 'pet');
      const critInfo = canCrit
        ? rollOverCritTier(state.player.critChance, state.player.critMult)
        : { tier: 0, multiplier: 1 };
      const isCrit = critInfo.tier > 0;
      if(isCrit) dmg = Math.floor(dmg * critInfo.multiplier);
      ore.hp -= dmg;
      const alive = ore.hp > 0;
      if(!alive){ onOreBroken(idx, ore); renderTop(); }
      renderGrid();
      const cell = state.grid[idx]?.el;
      const canShowDamage = !state.settings || state.settings.showDamageNumbers !== false;
      if(alive && cell && canShowDamage){
        const dm = document.createElement('div');
        dm.classList.add('dmg');
        if(isCrit) dm.classList.add('crit');
        const critLabel = isCrit
          ? (critInfo.tier > 1 ? `CRIT${Math.round(critInfo.multiplier * 100)}%` : 'CRIT')
          : '';
        dm.textContent = (isCrit ? `${critLabel} ` : '') + '-' + dmg;
        dm.style.left='50%';
        dm.style.top='38%';
        dm.style.transform='translateX(-50%)';
        cell.appendChild(dm);
        setTimeout(()=>dm.remove(), 520);
      }
      (isCrit?SFX.crit:SFX.hit)();
    }

    function onPointerDown(e){
      e.preventDefault();
      try{ gridEl.setPointerCapture?.(e.pointerId); }catch(err){ }
      trackPointer(e, true);
    }
    function onPointerMove(e){ e.preventDefault(); trackPointer(e, false); }
    function onPointerUp(e){
      try{ gridEl.releasePointerCapture?.(e.pointerId); }catch(err){ }
      const ps = state.pointerState[e.pointerId];
      if(ps) delete state.pointerState[e.pointerId];
    }
    function trackPointer(e, isDown){ const id=e.pointerId||0; const idx = oreIndexFromPoint(e.clientX, e.clientY); const inside = idx>=0; const prev = state.pointerState[id] || { idx:-1, inside:false }; if(isDown){ if(inside){ hit(idx,'tap'); state.pointerState[id]={idx,inside:true}; } else { state.pointerState[id]={idx,inside:false}; } } else { if(prev.idx!==idx){ prev.inside=false; prev.idx=idx; } if(!prev.inside && inside){ hit(idx,'tap'); prev.inside=true; prev.idx=idx; } if(prev.inside && !inside){ prev.inside=false; } state.pointerState[id]=prev; } }

    gridEl.addEventListener('pointerdown', onPointerDown, {passive:false});
    gridEl.addEventListener('pointermove', onPointerMove, {passive:false});
    gridEl.addEventListener('pointerup', onPointerUp, {passive:false});
    gridEl.addEventListener('pointercancel', onPointerUp, {passive:false});
    gridEl.addEventListener('lostpointercapture', onPointerUp);

    // Pull-to-refresh guard
    let startY = 0, atTop = false;
    document.addEventListener('touchstart', (e)=>{ startY = e.touches[0].clientY; atTop = (document.scrollingElement?.scrollTop || 0) <= 0; }, {passive:true});
    document.addEventListener('touchmove', (e)=>{ if(atTop){ const dy = e.touches[0].clientY - startY; if(dy > 5) e.preventDefault(); } }, {passive:false});

    function spawnPets(){
      state.pets = [];
      const baseCount = getUpgradeLevel(state, 'pet') + (state.passive.petPlus || 0);
      const specialCount = Math.max(0, state.aether?.petPlus || 0);
      const gr = gridRect();
      const width = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
      const height = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
      const margins = currentGridMargins();
      const petAxisX = spawnAxisInfo(width, margins.x, PET_SIZE);
      const petAxisY = spawnAxisInfo(height, margins.y, PET_SIZE);
      const randomCenter = (axis) => axis.start + (axis.span>0 ? Math.random()*axis.span : 0);

      const createPet = (style = BASE_PET_STYLE) => ({
        x: randomCenter(petAxisX),
        y: randomCenter(petAxisY),
        targetIdx: -1,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitDir: Math.random() < 0.5 ? 1 : -1,
        orbitSpeed: 1.2 + Math.random() * 0.6,
        radialOffset: Math.random() * Math.PI * 2,
        radiusScale: 1 + Math.random() * 0.2,
        maxRadius: PET.swingRadius,
        contactRadius: PET.swingRadius * 0.75,
        prevRadial: 0,
        prevContact: false,
        lastHitMs: -1,
        petalCount: 3,
        followStrength: 12,
        id: -1,
        damageMul: Number.isFinite(style.damageMul) ? style.damageMul : 1,
        color: style.bg || BASE_PET_STYLE.bg,
        borderColor: style.border || BASE_PET_STYLE.border,
        glow: style.glow || BASE_PET_STYLE.glow,
        special: !!style.special,
        styleIndex: typeof style.styleIndex === 'number' ? style.styleIndex : null,
      });

      const initPetMotion = (pet) => {
        pet.id = state.pets.length;
        pet.petalCount = Math.max(1, Number.isFinite(pet.petalCount) ? Math.round(pet.petalCount) : ((pet.id % 3) + 2));
        pet.orbitDir = pet.id % 2 === 0 ? 1 : -1;
        pet.orbitAngle = Number.isFinite(pet.orbitAngle) ? pet.orbitAngle : Math.random() * Math.PI * 2;
        pet.orbitSpeed = Math.max(0.3, Number.isFinite(pet.orbitSpeed) ? pet.orbitSpeed : (PET.moveSpeed / Math.max(ORE_RADIUS + 8, PET.swingRadius)) * 0.55);
        pet.radialOffset = Number.isFinite(pet.radialOffset) ? pet.radialOffset : Math.random() * Math.PI * 2;
        pet.radiusScale = Number.isFinite(pet.radiusScale) ? pet.radiusScale : 1;
        const baseRadius = Math.max(ORE_RADIUS + 12, PET.swingRadius * 0.9);
        pet.maxRadius = baseRadius * Math.max(0.6, Math.min(1.4, pet.radiusScale));
        const defaultContact = ORE_RADIUS + Math.min(2, PET.atkRange * 0.25);
        const desiredContact = Number.isFinite(pet.contactRadius) ? pet.contactRadius : defaultContact;
        pet.contactRadius = Math.max(ORE_RADIUS + 2, Math.min(pet.maxRadius - 1, desiredContact));
        const followBase = Number.isFinite(pet.followStrength) ? pet.followStrength : (PET.moveSpeed / 24);
        pet.followStrength = Math.max(3, followBase);
        pet.prevRadial = 0;
        pet.prevContact = false;
        pet.lastHitMs = -1;
        if(!Number.isFinite(pet.x) || !Number.isFinite(pet.y)){
          pet.x = randomCenter(petAxisX);
          pet.y = randomCenter(petAxisY);
        }
        clampPetToGrid(pet, petAxisX, petAxisY);
        pet.targetIdx = -1;
        return pet;
      };

      for(let i=0;i<baseCount;i++){
        state.pets.push(initPetMotion(createPet(BASE_PET_STYLE)));
      }
      for(let i=0;i<specialCount;i++){
        const styleDef = SPECIAL_PET_STYLES[i % SPECIAL_PET_STYLES.length] || {};
        state.pets.push(initPetMotion(createPet({ ...styleDef, damageMul: 2, special: true, styleIndex: i })));
      }
      renderPets();
      if(typeof applyPetBehaviorUpgrade === 'function'){
        applyPetBehaviorUpgrade();
      }
    }
    function renderPets(){
      gridEl.querySelectorAll('.pet').forEach(p=>p.remove());
      const gr = gridRect();
      const margins = currentGridMargins();
      const gridWidth = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
      const gridHeight = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
      const axisX = spawnAxisInfo(gridWidth, margins.x, PET_SIZE);
      const axisY = spawnAxisInfo(gridHeight, margins.y, PET_SIZE);
      for(const p of state.pets){
        clampPetToGrid(p, axisX, axisY);
        const el=document.createElement('div');
        el.className='pet';
        if(p.special) el.classList.add('pet-special');
        const localX = p.x - PET_RADIUS;
        const localY = p.y - PET_RADIUS;
        el.style.transform = `translate(${localX}px, ${localY}px)`;
        if(p.color) el.style.background = p.color;
        if(p.borderColor) el.style.borderColor = p.borderColor;
        if(p.glow) el.style.boxShadow = `0 0 10px ${p.glow}`;
        gridEl.appendChild(el);
      }
    }
    function findNearestOreIdx(x,y){ let best=-1, bestD=1e9; for(let i=0;i<25;i++){ const ore=state.grid[i]; if(!ore) continue; const d=Math.hypot(ore.x-x, ore.y-y); if(d<bestD){ bestD=d; best=i; } } return best; }
    function findNearestOreFromList(x,y,indices){
      let best=-1, bestD=1e9;
      for(const idx of indices){
        const ore = state.grid[idx];
        if(!ore) continue;
        const d = Math.hypot(ore.x - x, ore.y - y);
        if(d < bestD){
          bestD = d;
          best = idx;
        }
      }
      return best;
    }
    function choosePetTarget(p, oreIndices, claimCounts){
      if(!oreIndices.length) return -1;
      const multiPets = state.pets.length >= 2;
      const multiOres = oreIndices.length >= 2;
      if(!(multiPets && multiOres)){
        return findNearestOreFromList(p.x, p.y, oreIndices);
      }
      let bestIdx = -1;
      let bestCount = Infinity;
      let bestDist = Infinity;
      const counts = claimCounts || new Map();
      for(const idx of oreIndices){
        const ore = state.grid[idx];
        if(!ore) continue;
        const count = counts.get(idx) || 0;
        const dx = ore.x - p.x;
        const dy = ore.y - p.y;
        const distSq = dx*dx + dy*dy;
        if(count < bestCount || (count === bestCount && distSq < bestDist)){
          bestCount = count;
          bestDist = distSq;
          bestIdx = idx;
        }
      }
      if(bestIdx !== -1){
        return bestIdx;
      }
      return findNearestOreFromList(p.x, p.y, oreIndices);
    }

    function updatePetOrbitMotion(p, ore, dt, ts, gr, axisX, axisY){
      if(!p || !ore) return;
      const gridWidth = Math.max(axisX?.size || gr.innerWidth || gr.width || 0, 16);
      const gridHeight = Math.max(axisY?.size || gr.innerHeight || gr.height || 0, 16);
      const maxRadius = Math.max(ORE_RADIUS + 8, Number.isFinite(p.maxRadius) ? p.maxRadius : PET.swingRadius);
      const followBase = Number.isFinite(p.followStrength) ? p.followStrength : (PET.moveSpeed / 24);
      const followStrength = Math.max(3, followBase);
      const orbitSpeed = Math.max(0.3, Number.isFinite(p.orbitSpeed) ? p.orbitSpeed : (PET.moveSpeed / Math.max(ORE_RADIUS + 8, maxRadius)) * 0.55);
      const dir = (Number.isFinite(p.orbitDir) && p.orbitDir < 0) ? -1 : 1;
      const baseX = Number.isFinite(p.x) ? p.x : ore.x;
      const baseY = Number.isFinite(p.y) ? p.y : ore.y;
      const currentAngle = Number.isFinite(p.orbitAngle) ? p.orbitAngle : Math.atan2(baseY - ore.y, baseX - ore.x);
      const nextAngle = currentAngle + orbitSpeed * dt * dir;
      p.orbitAngle = nextAngle;
      const petalCount = Math.max(1, Number.isFinite(p.petalCount) ? Math.round(p.petalCount) : 3);
      const radialPhase = (Number.isFinite(p.radialOffset) ? p.radialOffset : 0) + petalCount * nextAngle;
      const attackExtendFactor = Number.isFinite(p.attackExtend) ? p.attackExtend : 1.12;
      const radial = Math.cos(radialPhase) * maxRadius * attackExtendFactor;
      const dirX = Math.cos(nextAngle);
      const dirY = Math.sin(nextAngle);
      const targetX = ore.x + dirX * radial;
      const targetY = ore.y + dirY * radial;
      const lerp = 1 - Math.exp(-followStrength * dt);
      const maxStep = Math.max(0, PET.moveSpeed * dt);
      const currentX = Number.isFinite(p.x) ? p.x : targetX;
      const currentY = Number.isFinite(p.y) ? p.y : targetY;
      let nextX = currentX + (targetX - currentX) * lerp;
      let nextY = currentY + (targetY - currentY) * lerp;
      const stepX = nextX - currentX;
      const stepY = nextY - currentY;
      const stepDist = Math.hypot(stepX, stepY);
      if(stepDist > maxStep && stepDist > 0){
        const scale = maxStep / stepDist;
        nextX = currentX + stepX * scale;
        nextY = currentY + stepY * scale;
      }
      p.x = nextX;
      p.y = nextY;
      clampPetToGrid(p, axisX, axisY);
      const prevContact = !!p.prevContact;
      const contactRadius = Math.max(ORE_RADIUS + 2, Number.isFinite(p.contactRadius) ? p.contactRadius : (ORE_RADIUS + Math.min(2, PET.atkRange * 0.25)));
      const dx = p.x - ore.x;
      const dy = p.y - ore.y;
      const distance = Math.hypot(dx, dy);
      const timeSinceHit = Number.isFinite(p.lastHitMs) ? (ts - p.lastHitMs) / 1000 : Infinity;
      const contactNow = distance <= contactRadius;
      if(contactNow && !prevContact && timeSinceHit >= Math.max(0.1, PET.atkInterval * 0.35) && p.targetIdx >= 0){
        hit(p.targetIdx,'pet',{ damageMul: p.damageMul || 1 });
        p.lastHitMs = ts;
      }
      p.prevContact = contactNow;
      p.prevRadial = radial;
    }
    function updatePetIdleMotion(p, dt, gr, axisX, axisY){
      const gridWidth = Math.max(axisX?.size || gr.innerWidth || gr.width || 0, 16);
      const gridHeight = Math.max(axisY?.size || gr.innerHeight || gr.height || 0, 16);
      const minDimension = Math.min(gridWidth, gridHeight);
      const centerX = gridWidth / 2;
      const centerY = gridHeight / 2;
      const dir = (Number.isFinite(p.orbitDir) && p.orbitDir < 0) ? -1 : 1;
      const orbitSpeed = Math.max(0.25, Number.isFinite(p.orbitSpeed) ? p.orbitSpeed * 0.6 : 0.8);
      const followBase = Number.isFinite(p.followStrength) ? p.followStrength : (PET.moveSpeed / 24);
      const followStrength = Math.max(3, followBase * 0.6);
      const angle = (Number.isFinite(p.orbitAngle) ? p.orbitAngle : Math.random() * Math.PI * 2) + orbitSpeed * dt * dir;
      p.orbitAngle = angle;
      const petalCount = Math.max(1, Number.isFinite(p.petalCount) ? Math.round(p.petalCount) : 3);
      const availableRadius = Math.max(8, (minDimension / 2) - 10);
      const idleRadiusBase = Math.min(Math.max(ORE_RADIUS + 6, minDimension * 0.18), availableRadius);
      const idleRadiusScaled = Math.min(availableRadius, idleRadiusBase * (1 + (p.id % 3) * 0.12));
      const idleRadius = Math.max(8, idleRadiusScaled);
      const radial = Math.cos((Number.isFinite(p.radialOffset) ? p.radialOffset : 0) + petalCount * angle) * idleRadius;
      const dirX = Math.cos(angle);
      const dirY = Math.sin(angle);
      const targetX = centerX + dirX * radial;
      const targetY = centerY + dirY * radial;
      const lerp = 1 - Math.exp(-followStrength * dt);
      const currentX = Number.isFinite(p.x) ? p.x : targetX;
      const currentY = Number.isFinite(p.y) ? p.y : targetY;
      let nextX = currentX + (targetX - currentX) * lerp;
      let nextY = currentY + (targetY - currentY) * lerp;
      const maxStep = Math.max(0, PET.moveSpeed * dt);
      const stepX = nextX - currentX;
      const stepY = nextY - currentY;
      const stepDist = Math.hypot(stepX, stepY);
      if(stepDist > maxStep && stepDist > 0){
        const scale = maxStep / stepDist;
        nextX = currentX + stepX * scale;
        nextY = currentY + stepY * scale;
      }
      p.x = nextX;
      p.y = nextY;
      clampPetToGrid(p, axisX, axisY);
      p.prevContact = false;
      p.prevRadial = 0;
    }

    function petsFrame(ts){
      if(!state.inRun){
        state.animFrameId = 0;
        return;
      }
      const gr = gridRect();
      const margins = currentGridMargins();
      const gridWidth = Math.max(0, (gr.innerWidth ?? gr.width) || 0);
      const gridHeight = Math.max(0, (gr.innerHeight ?? gr.height) || 0);
      const petAxisX = spawnAxisInfo(gridWidth, margins.x, PET_SIZE);
      const petAxisY = spawnAxisInfo(gridHeight, margins.y, PET_SIZE);
      const dt = Math.min(0.05,(ts - state.lastAnimTs)/1000 || 0.016);
      state.lastAnimTs = ts;
      const oreIndices = [];
      for(let i=0;i<25;i++){
        if(state.grid[i]) oreIndices.push(i);
      }
      const multiPets = state.pets.length >= 2;
      const multiOres = oreIndices.length >= 2;
      const oreTargetClaims = new Map();
      for(const p of state.pets){
        if(p.targetIdx>=0 && state.grid[p.targetIdx]){
          oreTargetClaims.set(p.targetIdx, (oreTargetClaims.get(p.targetIdx)||0)+1);
        } else {
          p.targetIdx = -1;
          p.prevContact = false;
        }
      }
      for(const p of state.pets){
        const hasTarget = p.targetIdx>=0 && state.grid[p.targetIdx];
        const targetCount = hasTarget ? (oreTargetClaims.get(p.targetIdx)||0) : 0;
        const needsRetarget = !hasTarget || (multiPets && multiOres && targetCount > 1);
        if(needsRetarget){
          if(hasTarget){
            const prevCount = oreTargetClaims.get(p.targetIdx) || 0;
            if(prevCount <= 1){
              oreTargetClaims.delete(p.targetIdx);
            } else {
              oreTargetClaims.set(p.targetIdx, prevCount - 1);
            }
          }
          const newIdx = choosePetTarget(p, oreIndices, oreTargetClaims);
          p.targetIdx = newIdx;
          if(newIdx >= 0){
            oreTargetClaims.set(newIdx, (oreTargetClaims.get(newIdx)||0)+1);
            p.prevContact = false;
          }
        }
      }
      for(const p of state.pets){
        const ore = (p.targetIdx>=0) ? state.grid[p.targetIdx] : null;
        if(ore){
          updatePetOrbitMotion(p, ore, dt, ts, gr, petAxisX, petAxisY);
        } else {
          updatePetIdleMotion(p, dt, gr, petAxisX, petAxisY);
        }
      }
      renderPets();
      state.animFrameId = requestAnimationFrame(petsFrame);
    }
    const TAB_IDS = ['dungeon','inventory','upgrades','skills','aether','settings'];
    function activateTab(tabId){
      const target = TAB_IDS.includes(tabId) ? tabId : 'dungeon';
      document.querySelectorAll('.tab-btn').forEach(b=>{
        const active = b.dataset.tab === target;
        b.classList.toggle('active', active);
      });
      TAB_IDS.forEach(id=>{
        const section = document.querySelector('#tab-'+id);
        if(!section) return;
        const active = id === target;
        section.style.display = active ? (id==='dungeon' ? 'flex' : 'block') : 'none';
        section.classList.toggle('active', active);
      });
      screenEl.scrollTop = 0;
      screenEl.style.overflowY = target==='dungeon' ? 'hidden' : 'auto';
      renderTop();
      if(target==='dungeon'){
        renderGrid();
      } else if(target==='skills'){
        renderSkills();
      } else if(target==='aether'){
        renderAether();
      } else if(target==='inventory'){
        renderInventory();
      } else if(target==='settings'){
        detectPlayGamesBridge();
        refreshPlayGamesStatus();
        updatePlayGamesUI();
      }
    }

    document.querySelectorAll('.tab-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        SFX.ui();
        activateTab(btn.dataset.tab);
      })
    });
    $('#toggleRunBtn').addEventListener('click', ()=>{ ensureAudio(); SFX.ui(); startRun(); });
    $('#exitBtn').addEventListener('click', ()=>{
      if(!state.inRun) return;
      SFX.ui();
      bankAndExit(false);
    });
    $('#saveBtn').addEventListener('click', ()=>{ SFX.ui(); save(); });
    $('#resetBtn').addEventListener('click', ()=>{
      SFX.ui();
      const answer = prompt('ì •ë§ ì „ì²´ ì´ˆê¸°í™”í• ê¹Œìš”? (ì„¸ì´ë¸Œ ì „ë¶€ ì‚­ì œ)\nì´ˆê¸°í™”ë¥¼ ì›í•˜ë©´ reset ì„ ì…ë ¥í•˜ì„¸ìš”.');
      if(answer && answer.trim().toLowerCase() === 'reset'){
        try{ localStorage.removeItem(SAVE_KEY); }catch(e){}
        try{ LEGACY_KEYS.forEach(k=>localStorage.removeItem(k)); }catch(e){}
        alert('ì„¸ì´ë¸Œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
        location.reload();
      }
    });
    $('#fullscreenBtn').addEventListener('click', ()=>{ SFX.ui(); if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } });
    const toggleSoundBtn = document.getElementById('toggleSoundBtn');
    function updateSoundToggleText(){
      if(!toggleSoundBtn) return;
      toggleSoundBtn.textContent = `íš¨ê³¼ìŒ: ${sfxEnabled ? 'ì¼œì§' : 'êº¼ì§'}`;
    }
    if(toggleSoundBtn){
      toggleSoundBtn.addEventListener('click', ()=>{
        SFX.ui();
        sfxEnabled = !sfxEnabled;
        state.settings.sfxEnabled = sfxEnabled;
        if(sfxEnabled) ensureAudio();
        updateSoundToggleText();
        save();
      });
    }

    const toggleDamageBtn = document.getElementById('toggleDamageBtn');
    function updateDamageToggleText(){
      if(!toggleDamageBtn) return;
      const enabled = !!(state.settings && state.settings.showDamageNumbers);
      toggleDamageBtn.textContent = `ë°ë¯¸ì§€ í‘œì‹œ: ${enabled ? 'ì¼œì§' : 'êº¼ì§'}`;
    }
    if(toggleDamageBtn){
      updateDamageToggleText();
      toggleDamageBtn.addEventListener('click', ()=>{
        SFX.ui();
        state.settings.showDamageNumbers = !state.settings.showDamageNumbers;
        if(!state.settings.showDamageNumbers){
          gridEl?.querySelectorAll('.dmg').forEach(el=>el.remove());
        }
        updateDamageToggleText();
        save();
      });
    }

    if(playGamesLoginBtn){
      playGamesLoginBtn.addEventListener('click', ()=>{
        SFX.ui();
        if(!playGamesState.login){ toast('Android ì•±ì—ì„œë§Œ ì§€ì›ë©ë‹ˆë‹¤.'); return; }
        playGamesState.busy = true;
        updatePlayGamesUI();
        try{
          const res = playGamesState.login();
          if(res && typeof res.then === 'function'){
            res.then(val=>{
              if(typeof val !== 'undefined') setPlayGamesState(val);
              else refreshPlayGamesStatus();
            }).catch(err=>{
              console.warn('Play Games ë¡œê·¸ì¸ ì‹¤íŒ¨', err);
              playGamesState.busy = false;
              updatePlayGamesUI();
            });
          } else if(typeof res !== 'undefined'){
            setPlayGamesState(res);
          } else {
            setTimeout(()=>{ refreshPlayGamesStatus(); }, 1000);
          }
        }catch(err){
          console.warn('Play Games ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜', err);
          playGamesState.busy = false;
          updatePlayGamesUI();
        }
        setTimeout(()=>{ if(playGamesState.busy) refreshPlayGamesStatus(); }, 1800);
        setTimeout(()=>{ if(playGamesState.busy){ playGamesState.busy = false; updatePlayGamesUI(); } }, 5000);
      });
    }

    // Export / Import for backup/move domains
    document.getElementById('exportBtn').addEventListener('click', ()=>{
      SFX.ui();
      const blob = new Blob([localStorage.getItem(SAVE_KEY)||'{}'], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'miner_save.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });
    document.getElementById('importBtn').addEventListener('click', ()=>{
      SFX.ui();
      const i = document.createElement('input'); i.type='file'; i.accept='application/json';
      i.onchange = async ()=>{ const f=i.files?.[0]; if(!f) return; const text = await f.text();
        try{ JSON.parse(text); localStorage.setItem(SAVE_KEY, text); location.reload(); }
        catch(e){ alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ì˜ëª»ëœ íŒŒì¼'); }
      };
      i.click();
    });

    document.getElementById('autoChallengeBuyBtn').addEventListener('click', ()=>{
      if(state.aether.autoChallengeOwned) return;
      if(state.highestFloor < 20) return toast('ì§€í•˜ 20ì¸µ ì´ìƒì—ì„œ í•´ê¸ˆ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
      const cost = AUTO_CHALLENGE_COST;
      if(state.player.ether < cost) return toast('ì—í…Œë¥´ ë¶€ì¡±');
      state.player.ether -= cost;
      state.aether.autoChallengeOwned = true;
      state.aether.autoChallengeEnabled = true;
      save(); renderAether(); renderTop(); toast('ìë™ ë„ì „ í•´ê¸ˆ!');
      maybeStartAutoChallenge();
    });
    document.getElementById('autoChallengeChk').addEventListener('change', (e)=>{
      if(!state.aether.autoChallengeOwned){ e.target.checked=false; return; }
      state.aether.autoChallengeEnabled = e.target.checked; save();
      if(e.target.checked){ maybeStartAutoChallenge(); }
    });
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){
        pauseRunForVisibility();
      } else {
        resumeRunAfterVisibility();
      }
    });
    document.getElementById('rebirthBuyBtn').addEventListener('click', ()=>{
      if(state.highestFloor < 20) return;
      let total = 0;
      const chosen = [];
      for(const p of REBIRTH_PERKS){
        if(rebirthPick[p.key]){
          const cost = perkCost(p);
          const lvl = p.getLevel(state);
          if(lvl >= p.max) continue;
          total += cost; chosen.push(p);
        }
      }
      if(total<=0) return;
      if(state.player.ether < total) return toast('ì—í…Œë¥´ ë¶€ì¡±');
      if(!confirm('ì„ íƒí•œ ë³´ë„ˆìŠ¤ë¥¼ êµ¬ë§¤í•˜ê³  í™˜ìƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
      state.player.ether -= total;
      for(const p of chosen){ if(typeof p.apply === 'function') p.apply({ state }); }
      if(state.inRun) cancelRunWithoutRewards();
      resetGoldProgression();
      state.aether.rebirths = (state.aether.rebirths||0)+1;
      for(const k in rebirthPick){ delete rebirthPick[k]; }
      save();
      renderAether();
      refresh();
      toast('ë³´ë„ˆìŠ¤ êµ¬ë§¤ ë° í™˜ìƒ ì™„ë£Œ!');
    });
    document.addEventListener('change', (e)=>{
      const t = e.target;
      if(t && t.matches('input[data-perk]')){
        rebirthPick[t.dataset.perk] = t.checked ? 1 : 0;
        renderAether();
      }
    });

    function boot(){
      load();
      updateSoundToggleText();
      updateDamageToggleText();
      detectPlayGamesBridge();
      updatePlayGamesUI();
      refreshPlayGamesStatus();
      setTimeout(()=>{ if(!playGamesState.available){ detectPlayGamesBridge(); } if(playGamesState.check){ refreshPlayGamesStatus(); } }, 1200);
      renderGrid();
      renderInventory();
      renderUpgrades();
      renderSkills();
      renderAether();
      renderTop();
      renderSkillBar();
      maybeStartAutoChallenge();
    }

    function init(){
      boot();
      activateTab(document.querySelector('.tab-btn.active')?.dataset.tab || 'dungeon');
    }
    init();

    window.addEventListener('resize', ()=>{
      gridRectCache = null;
      renderGrid();
      if(state.inRun) spawnPets();
    });

    function toast(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',left:'50%',top:'14%',transform:'translateX(-50%)',background:'#11193a',border:'1px solid #263165',padding:'10px 14px',borderRadius:'12px',color:'#eaf2ff',zIndex:9999}); document.body.appendChild(t); setTimeout(()=>t.remove(),1100); }
    function refresh(){ renderTop(); renderGrid(); renderInventory(); renderUpgrades(); }

  })();
  </script>
<script>
// === Dungeon pixel hard-lock: measure once, pin width/height in px (never shrink until reload) ===
(function(){
  const KEY = 'GRID_PIXEL_LOCK';
  const grid = document.getElementById('grid');
  const gridWrap = grid ? grid.parentElement : null;
  const header = document.querySelector('header');
  if (!grid || !gridWrap) return;

  function bodyBG(){
    const c = getComputedStyle(document.body).backgroundColor;
    return (!c || c === 'transparent' || c === 'rgba(0, 0, 0, 0)') ? '#111' : c;
  }
  // Ensure banner/heading area is opaque without changing theme
  try{
    const h = header;
    const ad = document.getElementById('ad-container');
    const bg = bodyBG();
    if (h) h.style.backgroundColor = bg;
    if (ad) ad.style.backgroundColor = bg;
  }catch(e){}

  function measurePX(){
    // Use the visible .grid-wrap box (more stable than viewport values)
    const r = gridWrap.getBoundingClientRect();
    // Leave a small safety padding to avoid accidental overflow
    const pad = 8;
    const s = Math.floor(Math.max(200, Math.min(r.width, r.height) - pad));
    return s;
  }
  function apply(px){
    grid.style.width  = px + 'px';
    grid.style.height = px + 'px';
    grid.style.minWidth  = px + 'px';
    grid.style.minHeight = px + 'px';
    grid.style.maxWidth  = px + 'px';
    grid.style.maxHeight = px + 'px';
  }

  let lock = +(sessionStorage.getItem(KEY) || 0);

  function ensureLock(){
    if (!lock){
      // Two rAF to ensure layouts (ads, sticky header) have settled
      requestAnimationFrame(()=>requestAnimationFrame(()=>{
        lock = measurePX();
        sessionStorage.setItem(KEY, String(lock));
        apply(lock);
      }));
    } else {
      apply(lock);
    }
  }

  // Apply immediately at DOM ready if dungeon is initially visible
  function dungeonVisible(){
    const el = document.getElementById('tab-dungeon');
    return el && el.style.display !== 'none';
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    if (dungeonVisible()){
      ensureLock();
    }
  });

  // On tab click: if switching to dungeon, scroll to top and enforce lock
  document.addEventListener('click', function(e){
    const btn = e.target && e.target.closest && e.target.closest('.tab-btn');
    if (!btn) return;
    const t = btn.getAttribute('data-tab');
    if (t === 'dungeon'){
      try{ document.scrollingElement.scrollTop = 0; }catch(_){}
      const s = document.querySelector('.screen'); if (s) s.scrollTop = 0;
      ensureLock();
    }
  }, true);

  // Ignore resizes (no shrink), but if there was no lock yet and things just became visible, allow first lock
  window.addEventListener('resize', ()=>{
    if (!lock) ensureLock(); else apply(lock);
  }, {passive:true});
})();
</script>
<script>
function openTab(id){
  document.querySelectorAll('.tab').forEach(t=> t.classList.remove('active'));
  const el = (typeof id === 'string') ? document.getElementById(id) : id;
  if (el) el.classList.add('active');
  try{ document.scrollingElement.scrollTop = 0; }catch(e){}
  const s = document.querySelector('.screen'); if (s) s.scrollTop = 0;
  if (el && el.id === 'tab-dungeon' && typeof resizeDungeon === 'function'){
    requestAnimationFrame(()=>requestAnimationFrame(()=> resizeDungeon(true)));
  }
}
</script>
<script>
// --- Dungeon size lock based on viewport (prevents shrink on tab switches) ---
(function(){
  const gridEl = document.getElementById('grid') || document.querySelector('#tab-dungeon .grid') || document.querySelector('#tab-dungeon canvas');
  const tabDungeon = document.getElementById('tab-dungeon');
  function headerH(){
    const h = document.querySelector('header');
    return h ? h.offsetHeight : 0;
  }
  function measure(){
    const vw = window.innerWidth || document.documentElement.clientWidth || 360;
    const vh = window.innerHeight || document.documentElement.clientHeight || 640;
    const availH = Math.max(200, vh - headerH());
    return Math.floor(Math.min(vw, availH));
  }
  let LOCK = 0;
  window.resizeDungeon = function(allowIncreaseOnly){
    if (!tabDungeon) return;
    const size = measure();
    if (allowIncreaseOnly === true){
      if (size > LOCK) LOCK = size;
    } else {
      LOCK = Math.max(LOCK, size);
    }
    const px = LOCK || size;
    const target = gridEl || tabDungeon;
    if (target){
      target.style.width = px + 'px';
      target.style.height = px + 'px';
      target.style.maxWidth = px + 'px';
      target.style.maxHeight = px + 'px';
      target.style.minWidth = px + 'px';
      target.style.minHeight = px + 'px';
      const wrap = target.parentElement;
      if (wrap && getComputedStyle(wrap).display !== 'flex'){
        target.style.marginLeft = 'auto';
        target.style.marginRight = 'auto';
      }
    }
  };
  document.addEventListener('DOMContentLoaded', ()=>{
    const active = tabDungeon && tabDungeon.classList.contains('active');
    requestAnimationFrame(()=>requestAnimationFrame(()=>{
      if (active) resizeDungeon(false);
    }));
  });
  window.addEventListener('resize', ()=> resizeDungeon(true), {passive:true});
})();
</script>

<script>
// --- FIX: openTab toggles .active on real sections (ES5) ---
(function(){
  function showTab(id){
    // normalize id: accepts 'dungeon' or 'tab-dungeon'
    var tid = /^tab-/.test(String(id)) ? String(id) : ('tab-' + String(id));
    var secs = document.querySelectorAll('section[id^="tab-"]');
    for (var i=0;i<secs.length;i++){
      var el = secs[i];
      if (!el || !el.id) continue;
      if (el.id === tid){
        if (!/\bactive\b/.test(el.className)) el.className += ' active';
      } else {
        el.className = el.className.replace(/\bactive\b/g, '').trim();
      }
    }
    // scroll top
    try { document.documentElement.scrollTop = 0; } catch(e){}
    try { document.body.scrollTop = 0; } catch(e){}
  }

  window.openTab = function(id){ showTab(id || 'dungeon'); };

  // Ensure initial state: dungeon active
  function ensureInitial(){
    var dungeon = document.getElementById('tab-dungeon');
    if (dungeon && !/\bactive\b/.test(dungeon.className)) {
      dungeon.className += ' active';
    }
    // hide others
    var secs = document.querySelectorAll('section[id^="tab-"]');
    for (var i=0;i<secs.length;i++){
      var el = secs[i];
      if (el.id !== 'tab-dungeon') {
        el.className = el.className.replace(/\bactive\b/g, '').trim();
      }
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureInitial);
  } else {
    ensureInitial();
  }
})();
</script>

</body>
</html>
