<!DOCTYPE html><html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>í´ë¦­ì»¤ ê´‘ì‚°</title>
  <style>
    :root{
      --bg:#0f1220;--panel:#161a2e;--accent:#6ee7ff;--accent2:#a78bfa;--text:#eaf2ff;--muted:#9aa3b2;--danger:#ff6b6b;--ok:#22c55e;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif; background:linear-gradient(180deg, #0b0e1a 0%, #0f1220 100%); color:var(--text);}
    .app{max-width:520px;margin:0 auto;display:flex;flex-direction:column;min-height:100vh;}
    header{position:sticky;top:0;z-index:10;background:rgba(15,18,32,0.9);backdrop-filter: blur(6px);border-bottom:1px solid #22263f}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;gap:8px}
    .stat{display:flex;align-items:center;gap:6px;background:var(--panel);padding:8px 10px;border-radius:12px;border:1px solid #232844;}
    .stat b{font-weight:700}
    .pill{font-size:12px;color:var(--muted)}
    .btn{appearance:none;border:none;background:var(--accent2);color:#0b0e1a;border-radius:12px;padding:10px 14px;font-weight:700}
    .btn.secondary{background:#243b55;color:#eaf2ff;border:1px solid #2f3a63}
    .btn.danger{background:var(--danger);color:white}
    .btn:disabled{opacity:.6}.tabs{display:flex;gap:8px;padding:8px 12px;background:#0d1020;border-top:1px solid #22263f}
.tab-btn{flex:1;border:none;padding:10px 0;border-radius:12px;background:#1a2040;color:#b9c3ff;font-weight:700}
.tab-btn.active{background:var(--accent);color:#001018}

.screen{flex:1;display:flex;flex-direction:column;padding:10px 12px;gap:10px}
.timerbar{height:10px;background:#1b2342;border-radius:999px;overflow:hidden;border:1px solid #283058}
.timerbar > div{height:100%;background:linear-gradient(90deg, #22c55e, #facc15);width:100%}

.grid{position:relative;display:grid;gap:6px;background:#0e1328;padding:6px;border-radius:16px;border:1px solid #202a51;grid-template-columns:repeat(5,1fr)}
.cell{position:relative;background:#121737;border:1px solid #1f2752;border-radius:10px;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;overflow:hidden}
.cell .ore{position:absolute;inset:6px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:900;color:#0a0e1e;text-shadow:0 1px 0 rgba(255,255,255,.2);} 
.ore .name{display:none}
.hp{position:absolute;top:6px;left:6px;right:6px;height:8px;background:rgba(0,0,0,.35);border-radius:999px;border:1px solid rgba(255,255,255,.08);overflow:hidden}
.hp>div{height:100%;background:linear-gradient(90deg,#34d399,#f59e0b);width:100%}
.dmg{position:absolute;pointer-events:none;font-weight:900;animation:float .6s ease-out forwards}
@keyframes float{to{transform:translateY(-24px);opacity:0}}

.pet{position:absolute;width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid #0e7490;box-shadow:0 0 10px rgba(34,211,238,.6)}
.pet::after{content:'ğŸ¾';position:absolute;font-size:12px;left:50%;top:50%;transform:translate(-50%,-55%)}

.modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;z-index:50}
.dialog{background:#0f1430;border:1px solid #263165;border-radius:16px;padding:16px;max-width:480px;width:90%}

.row{display:flex;gap:8px;align-items:center}
.panel{background:var(--panel);border:1px solid #232844;border-radius:16px;padding:12px}
.inventory{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.inv-item{background:#0f1430;border:1px solid #1f2853;border-radius:12px;padding:10px}
.inv-item h4{margin:0 0 6px 0}
.price{color:#a3e635;font-weight:800}
.small{font-size:12px;color:var(--muted)}
.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
footer{padding:10px 12px}
.hint{font-size:12px;color:#94a3b8;text-align:center}

  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="topbar">
        <div class="row">
          <div class="stat"><span>ğŸ’° ê³¨ë“œ</span><b id="gold">0</b></div>
          <div class="stat"><span>ğŸ—¡ï¸ ê³µê²©ë ¥</span><b id="atk">1</b></div>
          <div class="stat pill"><span>ğŸ¯ ì¹˜ëª…íƒ€</span><b id="crit">10%</b></div>
          <div class="stat pill"><span>ğŸ—¼ ì¸µ</span><b id="floor">ì§€í•˜ 1ì¸µ</b></div>
        </div>
        <div class="row">
          <button id="toggleRunBtn" class="btn">ë˜ì „ ì…ì¥</button>
          <button id="nextFloorBtn" class="btn secondary" disabled>ë‹¤ìŒ ì¸µ</button>
          <button id="exitBtn" class="btn danger" disabled>ë‚˜ê°€ê¸°</button>
        </div>
      </div>
      <div class="timerbar"><div id="timeFill"></div></div>
      <div class="tabs">
        <button class="tab-btn active" data-tab="dungeon">â›ï¸ ë˜ì „</button>
        <button class="tab-btn" data-tab="inventory">ğŸ’ ì¸ë²¤í† ë¦¬</button>
        <button class="tab-btn" data-tab="upgrades">ğŸ“ˆ ì—…ê·¸ë ˆì´ë“œ</button>
        <button class="tab-btn" data-tab="settings">âš™ï¸ ì„¤ì •</button>
      </div>
    </header><main class="screen">
  <section id="tab-dungeon" class="panel">
    <div class="row" style="justify-content:space-between;margin-bottom:6px">
      <div class="small">ìŠ¬ë¼ì´ë“œë¡œ ì—¬ëŸ¬ ì¹¸ì„ ì§€ë‚˜ê°€ë©° ì±„ê´‘. íˆíŠ¸ë°•ìŠ¤ ë°–â†’ì•ˆ ì¬ì§„ì… ì‹œ íƒ€ê²©!</div>
      <div class="small mono">ë‚¨ì€ì‹œê°„: <span id="timeLeft">--</span>s</div>
    </div>
    <div id="grid" class="grid"></div>
  </section>

  <section id="tab-inventory" class="panel" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-end;margin-bottom:8px">
      <h3 style="margin:0">ğŸ’ ì¸ë²¤í† ë¦¬</h3>
      <div class="small">ë˜ì „ì—ì„œ ë‚˜ê°€ì•¼ íšë“ìœ¼ë¡œ í™•ì •ë¼ìš”.</div>
    </div>
    <div class="inventory" id="inventoryList"></div>
  </section>

  <section id="tab-upgrades" class="panel" style="display:none">
    <h3 style="margin:0 0 8px 0">ğŸ“ˆ ì—…ê·¸ë ˆì´ë“œ</h3>
    <div id="upgrades"></div>
  </section>

  <section id="tab-settings" class="panel" style="display:none">
    <h3 style="margin:0 0 8px 0">âš™ï¸ ì„¤ì • & ì €ì¥</h3>
    <div class="row" style="flex-wrap:wrap;gap:10px">
      <button id="saveBtn" class="btn secondary">ìˆ˜ë™ ì €ì¥</button>
      <button id="fullscreenBtn" class="btn secondary">ì „ì²´í™”ë©´</button>
      <button id="resetBtn" class="btn danger">ì´ˆê¸°í™”</button>
    </div>
    <p class="small" style="margin-top:8px">ì§„í–‰ ìƒí™©ì€ ìë™/ìˆ˜ë™ìœ¼ë¡œ ë¸Œë¼ìš°ì €ì— ì €ì¥ë¼ìš” (localStorage).</p>
  </section>
</main>

<footer>
  <p class="hint">íŒ: ì†ê°€ë½ì„ ë–¼ê³  ë‹¤ì‹œ ë„£ìœ¼ë©´ ì¬íƒ€ê²©! í«ì„ ê³ ìš©í•´ ìë™ ì±„êµ´ì„ ì‹œì‘í•´ë´ìš”.</p>
</footer>

  </div>  <!-- ì¸µ ì„ íƒ ëª¨ë‹¬ -->  <div id="floorModal" class="modal">
    <div class="dialog">
      <h3 style="margin-top:0">ì§€í•˜ ì¸µ ì„ íƒ</h3>
      <p class="small">ë†’ì€ ì¸µì¼ìˆ˜ë¡ í¬ê·€ ê´‘ë¬¼ ì¶œí˜„ í™•ë¥ ì´ ì¦ê°€í•˜ë©°, íŠ¹ì • ê´‘ë¬¼ì€ ì§€ì • ì¸µ ì´ìƒì—ì„œë§Œ ë“±ì¥í•©ë‹ˆë‹¤.</p>
      <div class="row" style="margin:10px 0">
        <label>ì§€í•˜ <input id="floorInput" type="number" min="1" value="1" style="width:80px"> ì¸µ</label>
        <button id="floorConfirm" class="btn">ì…ì¥</button>
        <button id="floorCancel" class="btn secondary">ì·¨ì†Œ</button>
      </div>
      <div class="small" id="floorHint"></div>
    </div>
  </div>  <script>
  (()=>{
    const VERSION = 'miner_v1.4.0';

    // ---------- Game State ----------
    const state = {
      player: { atk: 1, critChance: 0.10, critMult: 2.0, gold: 0 },
      upgrades: {
        atk:   { level: 1, baseCost: 20,  scale: 1.55 },
        crit:  { level: 0, baseCost: 50,  scale: 1.7  },
        spawn: { level: 0, baseCost: 80,  scale: 1.8  }, // UI: ìƒì„± ì†ë„
        pet:   { level: 0, baseCost: 150, scale: 2.0  }, // +1 í« ê³ ìš©
        oreMul: {} // per-ore sell multiplier levels
      },
      floor: 1,
      highestFloor: 1,
      inventory: {},
      loot:      {}, // current run (unbanked)
      grid: new Array(25).fill(null),
      inRun:false,
      runTimeMax: 60,
      timeLeft: 0,
      timers: { spawn:null, tick:null },
      pets: [], // active pets during a run
      pointerState: {}, // per-pointer hitbox tracking
      lastAnimTs: 0,
    };

    // ---------- Ores ----------
    // tier: 1(common) .. 6(mythic), minFloor gate
    const ORES = [
      { key:'Stone',   name:'ì„ì¬',     color:'#a3a3a3', hp:  6, value: 1,  weight: 40, tier:1, minFloor:1 },
      { key:'Copper',  name:'êµ¬ë¦¬',     color:'#ef9a9a', hp: 12, value: 2,  weight: 36, tier:1, minFloor:1 },
      { key:'Iron',    name:'ì² ',       color:'#90caf9', hp: 22, value: 4,  weight: 30, tier:2, minFloor:2 },
      { key:'Silver',  name:'ì€',       color:'#cfd8dc', hp: 38, value: 9,  weight: 22, tier:3, minFloor:3 },
      { key:'Gold',    name:'ê¸ˆ',       color:'#f6e05e', hp: 65, value: 20, weight: 16, tier:3, minFloor:5 },
      { key:'Platinum',name:'ë°±ê¸ˆ',     color:'#e5e7eb', hp: 90, value: 32, weight: 10, tier:4, minFloor:8 },
      { key:'Sapphire',name:'ì‚¬íŒŒì´ì–´', color:'#60a5fa', hp:120, value: 48, weight: 7,  tier:4, minFloor:10 },
      { key:'Ruby',    name:'ë£¨ë¹„',     color:'#f43f5e', hp:140, value: 60, weight: 6,  tier:5, minFloor:12 },
      { key:'Emerald', name:'ì—ë©”ë„ë“œ', color:'#34d399', hp:165, value: 80, weight: 5,  tier:5, minFloor:15 },
      { key:'Mythril', name:'ë¯¸ìŠ¤ë¦´',   color:'#93c5fd', hp:220, value:120, weight: 3,  tier:6, minFloor:18 },
      { key:'Diamond', name:'ë‹¤ì´ì•„',   color:'#b9f6ff', hp:300, value:180, weight: 2,  tier:6, minFloor:22 },
    ];

    // initialize inventory & oreMul
    for(const o of ORES){ state.inventory[o.key]=state.inventory[o.key]||0; state.loot[o.key]=0; state.upgrades.oreMul[o.key] = state.upgrades.oreMul[o.key]||0; }

    // Pets
    const PET = { moveSpeed: 220, atkInterval: 0.55, radius: 14, sepRadius: 24, atkRange: 18 }; // speed px/s, cooldown sec

    // ---------- Helpers ----------
    const $ = sel => document.querySelector(sel);
    const gridEl = $('#grid');
    const floorModal = $('#floorModal');
    const floorInput = $('#floorInput');
    const floorHint  = $('#floorHint');

    function save(){ localStorage.setItem(VERSION, JSON.stringify({
      player:state.player, upgrades:state.upgrades, floor:state.floor, highestFloor:state.highestFloor, inventory:state.inventory
    })); }
    function load(){ const raw = localStorage.getItem(VERSION); if(!raw) return; try{ const s = JSON.parse(raw); Object.assign(state.player,s.player||{}); Object.assign(state.upgrades,s.upgrades||{}); state.floor=s.floor||1; state.highestFloor=s.highestFloor||1; state.inventory=s.inventory||state.inventory; }catch(e){ console.warn('load failed', e) } }

    function randWeighted(items){ const total = items.reduce((a,b)=>a+b.weight,0); let r = Math.random()*total; for(const it of items){ if((r-=it.weight) <= 0) return it; } return items[0]; }

    function eligibleOresForFloor(floor){
      // Increase chance for higher-tier ores slightly with floor
      const list = ORES.filter(o=> floor >= o.minFloor).map(o=>{
        const bonus = Math.max(0, floor - o.minFloor);
        const tierBoost = 1 + (o.tier-1)*0.03*bonus; // higher tier grows faster per floor above gate
        return { ...o, weight: Math.max(1, Math.round(o.weight * tierBoost)) };
      });
      // Normalize so commons still appear
      return list;
    }

    function cellIndexFromPoint(x,y){ const el = document.elementFromPoint(x,y); const cell = el && el.closest ? el.closest('.cell') : null; return cell? +cell.dataset.idx : -1; }
    function gridRect(){ return gridEl.getBoundingClientRect(); }
    function cellRect(idx){ return gridEl.children[idx].getBoundingClientRect(); }
    function cellCenter(idx){ const r = cellRect(idx); return { x:r.left + r.width/2, y:r.top + r.height/2 }; }
    function insideHitbox(idx, x, y){ if(idx<0) return false; const r = cellRect(idx); const padX=r.width*0.15, padY=r.height*0.15; return (x>r.left+padX && x<r.right-padX && y>r.top+padY && y<r.bottom-padY); }

    function sellMultiplier(key){ const lvl = state.upgrades.oreMul[key]||0; return Math.pow(1.2, lvl); }

    // ---------- UI Rendering ----------
    function fmtFloor(n){ return `ì§€í•˜ ${n}ì¸µ`; }
    function renderTop(){ $('#gold').textContent = state.player.gold.toLocaleString(); $('#atk').textContent  = state.player.atk.toString(); $('#crit').textContent = Math.round(state.player.critChance*100)+"%"; $('#floor').textContent= fmtFloor(state.floor); $('#timeLeft').textContent = state.inRun? state.timeLeft : '--'; $('#exitBtn').disabled = !state.inRun; $('#nextFloorBtn').disabled = !state.inRun; $('#toggleRunBtn').textContent = state.inRun? 'ì§„í–‰ ì¤‘' : 'ë˜ì „ ì…ì¥'; $('#toggleRunBtn').disabled = state.inRun; const fill = Math.max(0, Math.min(1, state.timeLeft / state.runTimeMax)); $('#timeFill').style.width = (fill*100)+'%'; }

    function renderGrid(){ if(!gridEl.childElementCount){ for(let i=0;i<25;i++){ const d=document.createElement('div'); d.className='cell'; d.dataset.idx=i; gridEl.appendChild(d); } } state.grid.forEach((ore, i)=>{ const c = gridEl.children[i]; c.innerHTML = ''; if(ore){ const el = document.createElement('div'); el.className='ore'; el.style.background = ore.bg; const hp = document.createElement('div'); hp.className='hp'; const hpfill = document.createElement('div'); hp.appendChild(hpfill); const ratio = Math.max(0, Math.min(1, ore.hp/ore.maxHp)); hpfill.style.width = (ratio*100)+'%'; c.appendChild(el); c.appendChild(hp); } }); renderPets(); }

    function renderInventory(){ const box = $('#inventoryList'); box.innerHTML=''; for(const t of ORES){ const inv = state.inventory[t.key]||0; const mul = sellMultiplier(t.key); const li=document.createElement('div'); li.className='inv-item'; li.innerHTML = `<h4>${t.name} <span class="small">(${t.key})</span></h4> <div class="small">ê°€ì¹˜: <span class="price">${Math.round(t.value*mul)}</span> ê³¨ë“œ</div> <div class="small">íŒë§¤ ë°°ìœ¨ Lv.${state.upgrades.oreMul[t.key]||0} Ã—${mul.toFixed(2)}</div> <div style="margin-top:6px" class="row"><div class="stat">ë³´ìœ : <b>${inv}</b></div></div> <div class="row" style="margin-top:6px;gap:6px;flex-wrap:wrap"> <button class="btn secondary" data-sellall="${t.key}">ëª¨ë‘ íŒë§¤</button> <button class="btn secondary" data-sell="${t.key}">1ê°œ íŒë§¤</button> <button class="btn" data-upg-ore="${t.key}">ì—…ê·¸ë ˆì´ë“œ</button> </div> <div class="small">ì—…ê·¸ë ˆì´ë“œ: ì´ ê´‘ì„ì„ ì¬ë£Œë¡œ ì†Œë¹„í•˜ì—¬ í•´ë‹¹ ê´‘ì„ì˜ íŒë§¤ ë°°ìœ¨ì„ ì˜êµ¬ ìƒìŠ¹ì‹œí‚µë‹ˆë‹¤.</div>`; box.appendChild(li); }
      box.querySelectorAll('[data-sell]').forEach(btn=>{ btn.addEventListener('click', ()=>{ const k=btn.dataset.sell; const t = ORES.find(o=>o.key===k); if(state.inventory[k]>0){ state.inventory[k]--; state.player.gold+=Math.round(t.value*sellMultiplier(k)); save(); refresh(); } }); });
      box.querySelectorAll('[data-sellall]').forEach(btn=>{ btn.addEventListener('click', ()=>{ const k=btn.dataset.sellall; const t = ORES.find(o=>o.key===k); const n = state.inventory[k]||0; if(n>0){ state.inventory[k]=0; state.player.gold+=Math.round(n*t.value*sellMultiplier(k)); save(); refresh(); } }); });
      box.querySelectorAll('[data-upg-ore]').forEach(btn=>{ btn.addEventListener('click', ()=>{ const k=btn.dataset.upgOre; oreUpgrade(k); }); }); }

    function oreUpgrade(key){ const lvl = state.upgrades.oreMul[key]||0; const cost = Math.floor(10 * Math.pow(1.6, lvl)); if( (state.inventory[key]||0) < cost){ toast(`${key} x${cost} í•„ìš”`); return; } state.inventory[key] -= cost; state.upgrades.oreMul[key] = lvl+1; toast(`${key} ë°°ìœ¨ ì—…!`); save(); refresh(); }

    function renderUpgrades(){ const cont = $('#upgrades'); cont.innerHTML=''; const atkCost = Math.floor(state.upgrades.atk.baseCost * Math.pow(state.upgrades.atk.scale, state.upgrades.atk.level-1)); cont.appendChild(upgradeCard('ğŸ—¡ï¸ ê³µê²©ë ¥', `í˜„ì¬: ${state.player.atk}`, atkCost, ()=>{ if(spend(atkCost)){ state.upgrades.atk.level++; state.player.atk += 1; toast('ê³µê²©ë ¥ +1'); save(); refresh(); } })); const critCost = Math.floor(state.upgrades.crit.baseCost * Math.pow(state.upgrades.crit.scale, state.upgrades.crit.level)); cont.appendChild(upgradeCard('ğŸ¯ ì¹˜ëª…íƒ€ í™•ë¥ ', `í˜„ì¬: ${(state.player.critChance*100).toFixed(1)}%`, critCost, ()=>{ if(state.player.critChance>=0.5){ toast('ìµœëŒ€ 50%'); return;} if(spend(critCost)){ state.upgrades.crit.level++; state.player.critChance += 0.02; toast('ì¹˜ëª…íƒ€ í™•ë¥  +2%'); save(); refresh(); } })); const spawnCost = Math.floor(state.upgrades.spawn.baseCost * Math.pow(state.upgrades.spawn.scale, state.upgrades.spawn.level)); cont.appendChild(upgradeCard('âš™ï¸ ìƒì„± ì†ë„', `ë ˆë²¨: ${state.upgrades.spawn.level}`, spawnCost, ()=>{ if(spend(spawnCost)){ state.upgrades.spawn.level++; toast('ìƒì„± ì†ë„ ì—…'); if(state.inRun) restartSpawnTimer(); save(); refresh(); } })); const petCost = Math.floor(state.upgrades.pet.baseCost * Math.pow(state.upgrades.pet.scale, state.upgrades.pet.level)); cont.appendChild(upgradeCard('ğŸ¤– ìë™ì±„êµ´ í«', `ë³´ìœ : ${state.upgrades.pet.level}ë§ˆë¦¬`, petCost, ()=>{ if(spend(petCost)){ state.upgrades.pet.level++; toast('í« +1 ê³ ìš©'); if(state.inRun) spawnPets(); save(); refresh(); } })); }

    function upgradeCard(title, desc, cost, onBuy){ const wrap=document.createElement('div'); wrap.className='inv-item'; wrap.innerHTML = `<h4 style="margin:0 0 4px 0">${title}</h4><div class="small">${desc}</div><div class="row" style="margin-top:8px;justify-content:space-between"><div class="row"><span>ê°€ê²©:</span> <b class="price">${cost}</b></div><button class="btn">êµ¬ë§¤</button></div>`; wrap.querySelector('.btn').addEventListener('click', onBuy); return wrap; }

    function spend(amount){ if(state.player.gold < amount){ toast('ê³¨ë“œê°€ ë¶€ì¡±í•´ìš”'); return false; } state.player.gold -= amount; return true; }
    function toast(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',left:'50%',top:'14%',transform:'translateX(-50%)',background:'#11193a',border:'1px solid #263165',padding:'10px 14px',borderRadius:'12px',color:'#eaf2ff',zIndex:9999}); document.body.appendChild(t); setTimeout(()=>t.remove(),1100); }
    function refresh(){ renderTop(); renderGrid(); renderInventory(); renderUpgrades(); }

    // ---------- Dungeon & Floors ----------
    function floorHpMul(){ return 1 + 0.25*(state.floor-1); }
    function floorValMul(){ return 1 + 0.15*(state.floor-1); }

    function openFloorSelect(){ floorInput.value = state.highestFloor; floorHint.textContent = `ìµœê³  ê¸°ë¡: ${fmtFloor(state.highestFloor)}`; floorModal.style.display='flex'; }
    function closeFloorSelect(){ floorModal.style.display='none'; }

    function startRun(){ if(state.inRun) return; // show floor picker
      openFloorSelect(); }

    function actuallyStartRun(){ state.inRun = true; state.timeLeft = state.runTimeMax; for(const o of ORES){ state.loot[o.key]=0; } state.grid = new Array(25).fill(null); restartSpawnTimer(); startTick(); spawnPets(); refresh(); }

    function startTick(){ state.timers.tick && clearInterval(state.timers.tick); state.timers.tick = setInterval(()=>{ if(!state.inRun) return; state.timeLeft--; if(state.timeLeft<=0){ bankAndExit(); } renderTop(); },1000); state.lastAnimTs = performance.now(); requestAnimationFrame(petsFrame); }

    function restartSpawnTimer(){ const baseMs=2200; const level=state.upgrades.spawn.level; let interval= baseMs*Math.pow(0.94, level); if(interval<600) interval=600; clearInterval(state.timers.spawn); state.timers.spawn = setInterval(spawnOre, interval); }
    function nextFloor(){ if(!state.inRun) return; state.floor++; if(state.floor>state.highestFloor) state.highestFloor=state.floor; state.grid = new Array(25).fill(null); toast(`${fmtFloor(state.floor)}ìœ¼ë¡œ ì´ë™!`); renderTop(); renderGrid(); }
    function exitRun(){ if(!state.inRun) return; bankAndExit(); }
    function bankAndExit(){ for(const k in state.loot){ state.inventory[k] = (state.inventory[k]||0) + state.loot[k]; } state.inRun=false; state.timeLeft=0; clearInterval(state.timers.spawn); clearInterval(state.timers.tick); state.pets=[]; state.lastAnimTs=0; if(state.floor>state.highestFloor) state.highestFloor=state.floor; toast('ë˜ì „ì„ ë– ë‚¬ìŠµë‹ˆë‹¤! ì¸ë²¤í† ë¦¬ì— ì¶”ê°€ë¨'); save(); refresh(); }

    function spawnOre(){ const empties = state.grid.map((v,i)=> v? null : i).filter(v=>v!==null); if(empties.length===0) return; const idx = empties[Math.floor(Math.random()*empties.length)]; const pool = eligibleOresForFloor(state.floor); const base = randWeighted(pool); const hp = Math.round(base.hp*floorHpMul()); const value = Math.round(base.value*floorValMul()); state.grid[idx] = { type: base.key, label: base.name, hp, maxHp: hp, value, bg: base.color }; renderGrid(); }

    function hit(idx, source='tap'){ if(!state.inRun) return; const ore = state.grid[idx]; if(!ore) return; let dmg = state.player.atk; if(Math.random() < state.player.critChance && source==='tap') dmg = Math.floor(dmg * state.player.critMult); ore.hp -= dmg; const cell = gridEl.children[idx]; const dm = document.createElement('div'); dm.className='dmg'; dm.textContent = '-' + dmg; dm.style.left='50%'; dm.style.top='38%'; dm.style.transform='translateX(-50%)'; cell.appendChild(dm); setTimeout(()=>dm.remove(), 620); if(ore.hp <= 0){ state.loot[ore.type] = (state.loot[ore.type]||0)+1; state.grid[idx] = null; } renderGrid(); }

    // ---------- Sliding / Hitbox pointer logic ----------
    function onPointerDown(e){ e.preventDefault(); trackPointer(e, true); }
    function onPointerMove(e){ trackPointer(e, false); }
    function onPointerUp(e){ const ps = state.pointerState[e.pointerId]; if(ps) delete state.pointerState[e.pointerId]; }

    function trackPointer(e, isDown){ const id=e.pointerId; const idx = cellIndexFromPoint(e.clientX, e.clientY); const inside = insideHitbox(idx, e.clientX, e.clientY) && state.grid[idx]; const prev = state.pointerState[id] || { idx:-1, inside:false }; if(isDown){ if(inside && idx>=0) { hit(idx,'tap'); state.pointerState[id] = { idx, inside:true }; } else { state.pointerState[id] = { idx, inside:false }; } } else { if(prev.idx !== idx){ prev.inside = false; prev.idx = idx; } if(!prev.inside && inside){ if(idx>=0) hit(idx,'tap'); prev.inside = true; prev.idx = idx; } if(prev.inside && !inside){ prev.inside = false; } state.pointerState[id] = prev; } }

    // ---------- Pets (RAF, smoothing & separation) ----------
    function spawnPets(){ state.pets = []; const count = state.upgrades.pet.level; const gr = gridRect(); for(let i=0;i<count;i++){ const p = { x: gr.left + Math.random()*gr.width, y: gr.top + Math.random()*gr.height, vx:0, vy:0, targetIdx: -1, cd:0 }; state.pets.push(p); } renderPets(); }

    function renderPets(){ gridEl.querySelectorAll('.pet').forEach(p=>p.remove()); const gr = gridRect(); for(const p of state.pets){ const el=document.createElement('div'); el.className='pet'; const localX = p.x - gr.left - 8; const localY = p.y - gr.top - 8; el.style.transform = `translate(${localX}px, ${localY}px)`; gridEl.appendChild(el); } }

    function findNearestOreIdx(x,y){ let best=-1, bestD=1e9; for(let i=0;i<25;i++){ const ore=state.grid[i]; if(!ore) continue; const c=cellCenter(i); const d=Math.hypot(c.x-x, c.y-y); if(d<bestD){ bestD=d; best=i; } } return best; }

    function petsFrame(ts){ if(!state.inRun) return; const gr = gridRect(); const dt = Math.min(0.05, (ts - state.lastAnimTs)/1000 || 0.016); state.lastAnimTs = ts; // seconds
      // steering
      for(const p of state.pets){ if(p.targetIdx<0 || !state.grid[p.targetIdx]){ p.targetIdx = findNearestOreIdx(p.x, p.y); } if(p.targetIdx>=0){ const c = cellCenter(p.targetIdx); let dx=c.x-p.x, dy=c.y-p.y; const dist = Math.hypot(dx,dy)||1; // seek
          const desiredX = (dx/dist) * PET.moveSpeed; const desiredY = (dy/dist) * PET.moveSpeed; // simple arrive
          const slowRad = 28; const speed = dist<slowRad ? PET.moveSpeed*(dist/slowRad) : PET.moveSpeed; const steerX = (dx/dist)*speed - p.vx; const steerY = (dy/dist)*speed - p.vy; p.vx += steerX*0.12; p.vy += steerY*0.12; // separation
        } else { // wander
          p.vx += (Math.random()-0.5)*10*dt; p.vy += (Math.random()-0.5)*10*dt; }
      }
      // pairwise separation
      for(let i=0;i<state.pets.length;i++){
        for(let j=i+1;j<state.pets.length;j++){
          const a=state.pets[i], b=state.pets[j]; const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy); const r=PET.sepRadius; if(d>0 && d<r){ const push=(r-d)/r*60; const nx=dx/d, ny=dy/d; a.vx -= nx*push; a.vy -= ny*push; b.vx += nx*push; b.vy += ny*push; }
        }
      }
      // integrate & attack
      for(const p of state.pets){ p.x += p.vx*dt; p.y += p.vy*dt; // bounds
        p.x = Math.max(gr.left+8, Math.min(gr.right-8, p.x)); p.y = Math.max(gr.top+8, Math.min(gr.bottom-8, p.y)); if(p.targetIdx>=0){ const c=cellCenter(p.targetIdx); const dist=Math.hypot(c.x-p.x, c.y-p.y); p.cd -= dt; if(dist<=PET.atkRange && p.cd<=0){ p.cd = PET.atkInterval; hit(p.targetIdx,'pet'); } } }
      renderPets(); requestAnimationFrame(petsFrame); }

    // ---------- Inventory actions ----------
    function sellAll(){ let total=0; for(const t of ORES){ const n = state.inventory[t.key]||0; const mul = sellMultiplier(t.key); total += n*t.value*mul; state.inventory[t.key]=0; } state.player.gold += Math.round(total); toast(`ì „ë¶€ íŒë§¤: +${Math.round(total)}ê³¨ë“œ`); save(); refresh(); }

    // ---------- Tabs & Events ----------
    document.querySelectorAll('.tab-btn').forEach(btn=>{ btn.addEventListener('click', ()=>{ document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); const t=btn.dataset.tab; ['dungeon','inventory','upgrades','settings'].forEach(id=>{ document.querySelector('#tab-'+id).style.display = (id===t? 'block':'none'); }) }) });

    gridEl.addEventListener('pointerdown', onPointerDown); gridEl.addEventListener('pointermove', onPointerMove); gridEl.addEventListener('pointerup', onPointerUp); gridEl.addEventListener('pointercancel', onPointerUp);
    $('#toggleRunBtn').addEventListener('click', startRun);
    $('#nextFloorBtn').addEventListener('click', nextFloor);
    $('#exitBtn').addEventListener('click', exitRun);
    $('#saveBtn').addEventListener('click', ()=>{ save(); toast('ì €ì¥ ì™„ë£Œ'); });
    $('#resetBtn').addEventListener('click', ()=>{ if(confirm('ì •ë§ ì´ˆê¸°í™”í• ê¹Œìš”? ëª¨ë“  ì§„í–‰ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.')){ localStorage.removeItem(VERSION); location.reload(); } });
    $('#fullscreenBtn').addEventListener('click', ()=>{ if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } });

    // floor modal
    $('#floorConfirm').addEventListener('click', ()=>{ const f = Math.max(1, parseInt(floorInput.value||'1')); state.floor = f; if(state.floor>state.highestFloor) state.highestFloor=state.floor; closeFloorSelect(); actuallyStartRun(); });
    $('#floorCancel').addEventListener('click', ()=>{ closeFloorSelect(); });

    // ---------- Boot ----------
    function boot(){ load(); renderGrid(); renderInventory(); renderUpgrades(); renderTop(); }
    boot();
  })();
  </script></body>
</html>
